                        ; --------------------------------------
                        ; zasm: assemble "_runtime.asm"
                        ; date: 2021-11-13 11:57:02
                        ; --------------------------------------


0202:                   	.org $202
0202:                   M8_C_boot:
0202: 3100F0   [10]     	ld sp,$F000
0205: C30202   [20]     	jp $202
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		binary.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Binary operators (A ? B -> A)
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
                        ; ***************************************************************************************
                        
0208:                   M8_C__c60_:
0208: 7C       [ 4]     	ld 		a,h 								 	; check if signs different.
0209: AA       [ 8]     	xor 	d
020A: 87       [12]     	add 	a,a 									; CS if different
020B: 3004     [19|24]  	jr 		nc,__less_samesign
020D: 7A       [23]     	ld 		a,d 									; different. set CS to sign of B
020E: 87       [27]     	add 	a,a 									; if set (negative) B must be < A as A is +ve
020F: 1805     [39]     	jr 		__less_returnc
0211:                   __less_samesign:
0211: D5       [11]     	push 	de 										; save DE
0212: EB       [15]     	ex 		de,hl 									; -1 if B < A
0213: ED52     [30]     	sbc 	hl,de 									; calculate B - A , hencs CS if < (Carry clear by add a,a)
0215: D1       [40]     	pop 	de 										; restore DE
0216:                   __less_returnc:
0216: 3E00     [ 7]     	ld 		a,0 									; A 0
0218: DE00     [14]     	sbc 	a,0 									; A $FF if CS.
021A: 6F       [18]     	ld 		l,a 									; put in HL
021B: 67       [22]     	ld 		h,a
021C: C9       [32]     	ret
021D:                   M8_C__c60__end:
                        
                        ; ***************************************************************************************
                        
021D:                   M8_C__c61_:
021D: 7C       [ 4]     	ld 		a,h 									; H = H ^ D
021E: AA       [ 8]     	xor 	d
021F: 67       [12]     	ld 		h,a
0220: 7D       [16]     	ld 		a,l 									; A = (L ^ E) | (H ^ D)
0221: AB       [20]     	xor 	e
0222: B4       [24]     	or 		h 										; if A == 0 they are the same.
0223: 210000   [34]     	ld 		hl,$0000 								; return 0 if different
0226: C0       [39|45]  	ret 	nz
0227: 2B       [45]     	dec 	hl 										; return -1
0228: C9       [55]     	ret
0229:                   M8_C__c61__end:
                        
                        ; ***************************************************************************************
                        
0229:                   M8_C__c45_:
0229: D5       [11]     	push 	de 										; save DE
022A: EB       [15]     	ex 		de,hl 									; HL = B, DE = A
022B: AF       [19]     	xor 	a  										; clear carry
022C: ED52     [34]     	sbc 	hl,de 									; calculate B-A
022E: D1       [44]     	pop 	de 										; restore DE
022F: C9       [54]     	ret
0230:                   M8_C__c45__end:
                        
                        ; ***************************************************************************************
                        
0230:                   M8_M__c43_:
0230: 19       [11]     	add 	hl,de
0231:                   M8_M__c43__end:
                        
                        ; ***************************************************************************************
                        
0231:                   M8_C_and:
0231: 7C       [ 4]     	ld 		a,h
0232: A2       [ 8]     	and 	d
0233: 67       [12]     	ld 		h,a
0234: 7D       [16]     	ld 		a,l
0235: A3       [20]     	and 	e
0236: 6F       [24]     	ld 		l,a
0237: C9       [34]     	ret
0238:                   M8_C_and_end:
                        
                        ; ***************************************************************************************
                        
0238:                   M8_C_or:
0238: 7C       [ 4]     	ld 		a,h
0239: B2       [ 8]     	or 		d
023A: 67       [12]     	ld 		h,a
023B: 7D       [16]     	ld 		a,l
023C: B3       [20]     	or 		e
023D: 6F       [24]     	ld 		l,a
023E: C9       [34]     	ret
023F:                   M8_C_or_end:
                        
                        ; ***************************************************************************************
                        
023F:                   M8_C_xor:
023F: 7C       [ 4]     	ld 		a,h
0240: AA       [ 8]     	xor 	d
0241: 67       [12]     	ld 		h,a
0242: 7D       [16]     	ld 		a,l
0243: AB       [20]     	xor 	e
0244: 6F       [24]     	ld 		l,a
0245: C9       [34]     	ret
0246:                   M8_C_xor_end:
                        
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		divide.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Division
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
                        ; ***************************************************************************************
                        
0246:                   M8_C__c47_:
0246: D5       [11]     	push 	de
0247: CD5302   [28]     	call 	DIVDivideMod16
024A: EB       [32]     	ex 		de,hl
024B: D1       [42]     	pop 	de
024C: C9       [52]     	ret
024D:                   M8_C__c47__end:
                        
                        ; ***************************************************************************************
                        
024D:                   M8_C_mod:
024D: D5       [11]     	push 	de
024E: CD5302   [28]     	call 	DIVDivideMod16
0251: D1       [38]     	pop 	de
0252: C9       [48]     	ret
0253:                   M8_C_mod_end:
                        
                        ; *********************************************************************************
                        ;
                        ;			Calculates DE / HL. On exit DE = result, HL = remainder
                        ;
                        ; *********************************************************************************
                        
0253:                   DIVDivideMod16:
0253: C5       [11]     	push 	bc
0254: 42       [15]     	ld 		b,d 				; DE
0255: 4B       [19]     	ld 		c,e
0256: EB       [23]     	ex 		de,hl
0257: 210000   [33]     	ld 		hl,0
025A: 78       [37]     	ld 		a,b
025B: 0608     [44]     	ld 		b,8
025D:                   Div16_Loop1:
025D: 17       [ 4]     	rla
025E: ED6A     [19]     	adc 	hl,hl
0260: ED52     [34]     	sbc 	hl,de
0262: 3001     [41|46]  	jr 		nc,Div16_NoAdd1
0264: 19       [52]     	add 	hl,de
0265:                   Div16_NoAdd1:
0265: 10F6     [ 8|13]  	djnz 	Div16_Loop1
0267: 17       [12]     	rla
0268: 2F       [16]     	cpl
0269: 47       [20]     	ld 		b,a
026A: 79       [24]     	ld 		a,c
026B: 48       [28]     	ld 		c,b
026C: 0608     [35]     	ld 		b,8
026E:                   Div16_Loop2:
026E: 17       [ 4]     	rla
026F: ED6A     [19]     	adc 	hl,hl
0271: ED52     [34]     	sbc 	hl,de
0273: 3001     [41|46]  	jr 		nc,Div16_NoAdd2
0275: 19       [52]     	add 	hl,de
0276:                   Div16_NoAdd2:
0276: 10F6     [ 8|13]  	djnz 	Div16_Loop2
0278: 17       [12]     	rla
0279: 2F       [16]     	cpl
027A: 51       [20]     	ld 		d,c
027B: 5F       [24]     	ld 		e,a
027C: C1       [34]     	pop 	bc
027D: C9       [44]     	ret
                        
                        
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		memory.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Memory operators
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
027E:                   M8_M__c33_:
027E: 73       [ 7]     		ld 		(hl),e
027F: 23       [13]     		inc 	hl
0280: 72       [20]     		ld 		(hl),d
0281: 2B       [26]     		dec 	hl
0282:                   M8_M__c33__end:
                        
                        ; ***************************************************************************************
                        
0282:                   M8_M__c64_:
0282: 7E       [ 7]     		ld 		a,(hl)
0283: 23       [13]     		inc 	hl
0284: 66       [20]     		ld		h,(hl)
0285: 6F       [24]     		ld		l,a
0286:                   M8_M__c64__end:
                        
                        ; ***************************************************************************************
                        
0286:                   M8_C__c43__c33_:
0286: 7E       [ 7]     		ld 		a,(hl)
0287: 83       [11]     		add 	a,e
0288: 77       [18]     		ld 		(hl),a
0289: 23       [24]     		inc 	hl
028A: 7E       [31]     		ld 		a,(hl)
028B: 8A       [35]     		adc 	a,d
028C: 77       [42]     		ld 		(hl),a
028D: 2B       [48]     		dec 	hl
028E: C9       [58]     		ret
028F:                   M8_C__c43__c33__end:
                        
                        ; ***************************************************************************************
                        
028F:                   M8_M_c_c33_:
028F: 73       [ 7]     		ld 		(hl),e
0290:                   M8_M_c_c33__end:
                        
                        ; ***************************************************************************************
                        
0290:                   M8_M_c_c64_:
0290: 6E       [ 7]     		ld 		l,(hl)
0291: 2600     [14]     		ld 		h,0
0293:                   M8_M_c_c64__end:
                        
                        ; ***************************************************************************************
                        
0293:                   M8_C_p_c64_:
0293: C5       [11]     		push 	bc
0294: 44       [15]     		ld		b,h
0295: 4D       [19]     		ld 		c,l
0296: ED68     [31]     		in 		l,(c)
0298: 2600     [38]     		ld 		h,0
029A: C1       [48]     		pop 	bc
029B: C9       [58]     		ret
029C:                   M8_C_p_c64__end:
                        
                        ; ***************************************************************************************
                        
029C:                   M8_C_p_c33_:
029C: C5       [11]     		push 	bc
029D: E5       [22]     		push 	hl
029E: 7B       [26]     		ld 		a,e
029F: 44       [30]     		ld		b,h
02A0: 4D       [34]     		ld 		c,l
02A1: ED79     [46]     		out 	(c),a
02A3: E1       [56]     		pop 	hl
02A4: C1       [66]     		pop 	bc
02A5: C9       [76]     		ret
02A6:                   M8_C_p_c33__end:
                        
                        
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		miscellany.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Miscellaneous words
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
02A6:                   M8_M__c59_:
02A6: C9       [10]     		ret
02A7:                   M8_M__c59__end:
                        
                        ; ***************************************************************************************
                        
02A7:                   M8_C_string_c46_inline:
02A7: EB       [ 4]     		ex 		de,hl 								; swap of DE & HL required by spec
02A8: E1       [14]     		pop 	hl 										; start of string -> HL
02A9: E5       [25]     		push 	hl 									; push start of string on stack.
02AA:                   _SILAdvance:
02AA: 7E       [ 7]     		ld 		a,(hl) 								; advance over string
02AB: 23       [13]     		inc 	hl
02AC: B7       [17]     		or 		a
02AD: 20FB     [24|29]  		jr 		nz,_SILAdvance
02AF: E3       [43]     		ex 		(sp),hl 							; correct return address
02B0: C9       [53]     		ret
                        ; [END]
                        
                        ; ***************************************************************************************
                        
02B1:                   M8_C_copy:
02B1: 78       [ 4]     		ld 		a,b 								; exit if C = 0
02B2: B1       [ 8]     		or 		c
02B3: C8       [13|19]  		ret 	z
                        
02B4: C5       [24]     		push 	bc 									; BC count
02B5: D5       [35]     		push 	de 									; DE target
02B6: E5       [46]     		push 	hl 									; HL source
                        
02B7: AF       [50]     		xor 	a 									; Clear C
02B8: ED52     [65]     		sbc 	hl,de 								; check overlap ?
02BA: 300B     [72|77]  		jr 		nc,__copy_gt_count 					; if source after target
02BC: 19       [83]     		add 	hl,de 								; undo subtract
                        
02BD: 09       [94]     		add 	hl,bc 								; add count to HL + DE
02BE: EB       [98]     		ex 		de,hl
02BF: 09       [109]    		add 	hl,bc
02C0: EB       [113]    		ex 		de,hl
02C1: 1B       [119]    		dec 	de 									; dec them, so now at the last byte to copy
02C2: 2B       [125]    		dec 	hl
02C3: EDB8     [141|21] 		lddr 										; do it backwards
02C5: 1803     [153]    		jr 		__copy_exit
                        
02C7:                   __copy_gt_count:
02C7: 19       [11]     		add 	hl,de 								; undo subtract
02C8: EDB0     [27|21]  		ldir										; do the copy
02CA:                   __copy_exit:
02CA: E1       [10]     		pop 	hl 									; restore registers
02CB: D1       [20]     		pop 	de
02CC: C1       [30]     		pop 	bc
02CD: C9       [40]     		ret
02CE:                   M8_C_copy_end:
                        
                        ; ***************************************************************************************
                        
02CE:                   M8_C_fill:
02CE: 78       [ 4]     		ld 		a,b 								; exit if C = 0
02CF: B1       [ 8]     		or 		c
02D0: C8       [13|19]  		ret 	z
                        
02D1: C5       [24]     		push 	bc 									; BC count
02D2: D5       [35]     		push 	de 									; DE target, L byte
02D3:                   __fill_loop:
02D3: 7D       [ 4]     		ld 		a,l 								; copy a byte
02D4: 12       [11]     		ld 		(de),a
02D5: 13       [17]     		inc 	de 									; bump pointer
02D6: 0B       [23]     		dec 	bc 									; dec counter and loop
02D7: 78       [27]     		ld 		a,b
02D8: B1       [31]     		or 		c
02D9: 20F8     [38|43]  		jr 		nz,__fill_loop
02DB: D1       [48]     		pop 	de 									; restore
02DC: C1       [58]     		pop 	bc
02DD: C9       [68]     		ret
02DE:                   M8_C_fill_end:
                        
                        ; ***************************************************************************************
                        
02DE:                   M8_C_halt:
02DE:                   __halt_loop:
02DE: 76       [ 4]     		halt
02DF: 18FD     [16]     		jr 		__halt_loop
02E1:                   M8_C_halt_end:
                        
                        ; ***************************************************************************************
                        
02E1:                   M8_M_break:
02E1: F3       [ 4]     		di
02E2:                   M8_M_break_end:
                        
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		multiply.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Multiplication
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
                        
02E2:                   M8_C__c42_:
02E2: C3E502   [10]     	jp  	MULTMultiply16
02E5:                   M8_C__c42__end:
                        
                        ; *********************************************************************************
                        ;
                        ;								Does HL = HL * DE
                        ;
                        ; *********************************************************************************
                        
02E5:                   MULTMultiply16:
02E5: C5       [11]     		push 	bc
02E6: D5       [22]     		push 	de
02E7: 44       [26]     		ld 		b,h 							; get multipliers in DE/BC
02E8: 4D       [30]     		ld 		c,l
02E9: 210000   [40]     		ld 		hl,0 							; zero total
02EC:                   __Core__Mult_Loop:
02EC: CB41     [ 8]     		bit 	0,c 							; lsb of shifter is non-zero
02EE: 2801     [15|20]  		jr 		z,__Core__Mult_Shift
02F0: 19       [26]     		add 	hl,de 							; add adder to total
02F1:                   __Core__Mult_Shift:
02F1: CB38     [ 8]     		srl 	b 								; shift BC right.
02F3: CB19     [16]     		rr 		c
02F5: EB       [20]     		ex 		de,hl 							; shift DE left
02F6: 29       [31]     		add 	hl,hl
02F7: EB       [35]     		ex 		de,hl
02F8: 78       [39]     		ld 		a,b 							; loop back if BC is nonzero
02F9: B1       [43]     		or 		c
02FA: 20F0     [50|55]  		jr 		nz,__Core__Mult_Loop
02FC: D1       [60]     		pop 	de
02FD: C1       [70]     		pop 	bc
02FE: C9       [80]     		ret
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		register.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Register manipulation
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
02FF:                   M8_M_swap:
02FF: EB       [ 4]     		ex 		de,hl
0300:                   M8_M_swap_end:
                        
                        ; ***************************************************************************************
                        
0300:                   M8_M_a_c62_b:
0300: 54       [ 4]     		ld 		d,h
0301: 5D       [ 8]     		ld 		e,l
0302:                   M8_M_a_c62_b_end:
                        
0302:                   M8_M_a_c62_c:
0302: 44       [ 4]     		ld 		b,h
0303: 4D       [ 8]     		ld 		c,l
0304:                   M8_M_a_c62_c_end:
                        
                        ; ***************************************************************************************
                        
0304:                   M8_M_b_c62_a:
0304: 62       [ 4]     		ld 		h,d
0305: 6B       [ 8]     		ld 		l,e
0306:                   M8_M_b_c62_a_end:
                        
0306:                   M8_M_b_c62_c:
0306: 42       [ 4]     		ld 		b,d
0307: 4B       [ 8]     		ld 		c,e
0308:                   M8_M_b_c62_c_end:
                        
                        ; ***************************************************************************************
                        
0308:                   M8_M_c_c62_a:
0308: 60       [ 4]     		ld 		h,b
0309: 69       [ 8]     		ld 		l,c
030A:                   M8_M_c_c62_a_end:
                        
030A:                   M8_M_c_c62_b:
030A: 50       [ 4]     		ld 		d,b
030B: 59       [ 8]     		ld 		e,c
030C:                   M8_M_c_c62_b_end:
                        
                        
                        ; ***************************************************************************************
                        
030C:                   M8_M_a_c62_x:
030C: E5       [11]     		push 	hl
030D: DDE1     [25]     		pop 	ix
030F:                   M8_M_a_c62_x_end:
                        
030F:                   M8_M_x_c62_a:
030F: DDE5     [15]     		push 	ix
0311: E1       [25]     		pop 	hl
0312:                   M8_M_x_c62_a_end:
                        
0312:                   M8_M_a_c62_y:
0312: E5       [11]     		push 	hl
0313: FDE1     [25]     		pop 	iy
0315:                   M8_M_a_c62_y_end:
                        
0315:                   M8_M_y_c62_a:
0315: FDE5     [15]     		push 	iy
0317: E1       [25]     		pop 	hl
0318:                   M8_M_y_c62_a_end:
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		stack.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Stack words
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
0318:                   M8_M_push:
0318: E5       [11]     	push 	hl
0319:                   M8_M_push_end:
                        
0319:                   M8_M_pop:
0319: EB       [ 4]     	ex 		de,hl
031A: E1       [14]     	pop 	hl
031B:                   M8_M_pop_end:
                        
                        ; ***************************************************************************************
                        
031B:                   M8_M_a_c62_r:
031B: E5       [11]     	push 	hl
031C:                   M8_M_a_c62_r_end:
                        
031C:                   M8_M_r_c62_a:
031C: E1       [10]     	pop 	hl
031D:                   M8_M_r_c62_a_end:
                        
                        ; ***************************************************************************************
                        
031D:                   M8_M_b_c62_r:
031D: D5       [11]     	push 	de
031E:                   M8_M_b_c62_r_end:
                        
031E:                   M8_M_r_c62_b:
031E: D1       [10]     	pop 	de
031F:                   M8_M_r_c62_b_end:
                        
                        ; ***************************************************************************************
                        
031F:                   M8_M_c_c62_r:
031F: C5       [11]     	push 	bc
0320:                   M8_M_c_c62_r_end:
                        
0320:                   M8_M_r_c62_c:
0320: C1       [10]     	pop 	bc
0321:                   M8_M_r_c62_c_end:
                        
                        
                        ; ***************************************************************************************
                        
0321:                   M8_M_ab_c62_r:
0321: D5       [11]     	push 	de
0322: E5       [22]     	push 	hl
0323:                   M8_M_ab_c62_r_end:
                        
0323:                   M8_M_r_c62_ab:
0323: E1       [10]     	pop 	hl
0324: D1       [20]     	pop 	de
0325:                   M8_M_r_c62_ab_end:
                        
                        ; ***************************************************************************************
                        
0325:                   M8_M_abc_c62_r:
0325: C5       [11]     	push 	bc
0326: D5       [22]     	push 	de
0327: E5       [33]     	push 	hl
0328:                   M8_M_abc_c62_r_end:
                        
0328:                   M8_M_r_c62_abc:
0328: E1       [10]     	pop 	hl
0329: D1       [20]     	pop 	de
032A: C1       [30]     	pop 	bc
032B:                   M8_M_r_c62_abc_end:
                        
                        
                        ; ***************************************************************************************
                        
032B:                   M8_M_bc_c62_r:
032B: C5       [11]     	push 	bc
032C: D5       [22]     	push 	de
032D:                   M8_M_bc_c62_r_end:
                        
032D:                   M8_M_r_c62_bc:
032D: D1       [10]     	pop 	de
032E: C1       [20]     	pop 	bc
032F:                   M8_M_r_c62_bc_end:
                        
                        ; ***************************************************************************************
                        
032F:                   M8_M_x_c62_r:
032F: DDE5     [15]     	push 	ix
0331:                   M8_M_x_c62_r_end:
                        
0331:                   M8_M_r_c62_x:
0331: DDE1     [14]     	pop 	ix
0333:                   M8_M_r_c62_x_end:
                        
                        ; ***************************************************************************************
                        
0333:                   M8_M_y_c62_r:
0333: FDE5     [15]     	push 	iy
0335:                   M8_M_y_c62_r_end:
                        
0335:                   M8_M_r_c62_y:
0335: FDE1     [14]     	pop 	iy
0337:                   M8_M_r_c62_y_end:
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		structure.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		7th November 2021
                        ;		Purpose :	Structure handler
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
                        ; ***************************************************************************************
                        ;
                        ;		Handles NEXT. The loop counter is on TOS below the return address of this call
                        ;
                        ; ***************************************************************************************
                        
0337:                   M8_C_next_c46_handler:
0337: D9       [ 4]     		exx 								; use alt registers
0338: E1       [14]     		pop 	hl 							; return/offset address.
0339: D1       [24]     		pop 	de 							; this is the count
033A: 7A       [28]     		ld 		a,d 						; check if it is zero.
033B: B3       [32]     		or 		e
033C: 2004     [39|44]  		jr 		nz,_tend_loop 				; if non zero, loop back
                        		;
033E: 23       [45]     		inc 	hl 							; exit loop, skip the count back.
033F: E5       [56]     		push 	hl 							; push return address back on stack
0340: D9       [60]     		exx 								; get original registers back and exit
0341: C9       [70]     		ret
                        
0342:                   _tend_loop:									; we are going round the loop, return HL count DE
0342: 4E       [ 7]     		ld 		c,(hl) 						; get the loop offset into BC
0343: 0600     [14]     		ld 		b,0
0345: AF       [18]     		xor 	a 							; subtract from HL
0346: ED42     [33]     		sbc 	hl,bc
0348: E5       [44]     		push 	hl 	 						; push loop address on stack
0349: 1B       [50]     		dec 	de 							; decrement counter
034A: D5       [61]     		push 	de  						; push new count on stack
034B: D9       [65]     		exx 								; original registers
034C: E1       [75]     		pop 	hl 							; count into HL
034D: C9       [85]     		ret 								; and exit
                        
034E:                   M8_C_next_c46_handler_end:
                        
                        ; ***************************************************************************************
                        ;
                        ;									Get index (TOS)
                        ;
                        ; ***************************************************************************************
                        
034E:                   M8_M_i:
034E: EB       [ 4]     		ex 		de,hl
034F: E1       [14]     		pop 	hl
0350: E5       [25]     		push 	hl
0351:                   M8_M_i_end:
                        
                        ; ***************************************************************************************
                        ;
                        ;			Branches Forwards/Backwards Zero/Positive tests and Always
                        ;
                        ; ***************************************************************************************
                        
                        
0351:                   M8_C_brzero_c46_fwd:
0351: AF       [ 4]     		xor 	a
0352: 1811     [16]     		jr 		_zeroBranch
0354:                   M8_C_brzero_c46_fwd_end:
                        
                        
0354:                   M8_C_brzero_c46_bwd:
0354: 37       [ 4]     		scf
0355: 180E     [16]     		jr 		_zeroBranch
0357:                   M8_C_brzero_c46_bwd_end:
                        
0357:                   M8_C_brpos_c46_fwd:
0357: AF       [ 4]     		xor 	a
0358: 1812     [16]     		jr 		_posBranch
035A:                   M8_C_brpos_c46_fwd_end:
                        
035A:                   M8_C_brpos_c46_bwd:
035A: 37       [ 4]     		scf
035B: 180F     [16]     		jr 		_posBranch
035D:                   M8_C_brpos_c46_bwd_end:
                        
035D:                   M8_C_br_c46_fwd:
035D: AF       [ 4]     		xor 	a
035E: 08       [ 8]     		ex 		af,af' 						; save the direction in AF' (CC FWD, CS BWD)
035F: 1814     [20]     		jr 		_Branch
0361:                   M8_C_br_c46_fwd_end:
                        
0361:                   M8_C_br_c46_bwd:
0361: 37       [ 4]     		scf
0362: 08       [ 8]     		ex 		af,af' 						; save the direction in AF' (CC FWD, CS BWD)
0363: 1810     [20]     		jr 		_Branch
0365:                   M8_C_br_c46_bwd_end:
                        
                        
0365:                   _zeroBranch:
0365: 08       [ 4]     		ex 		af,af' 						; save the direction in AF' (CC FWD, CS BWD)
0366: 7C       [ 8]     		ld 		a,h 						; check HL is zero
0367: B5       [12]     		or 		l
0368: 280B     [19|24]  		jr 		z,_Branch
036A: 1805     [31]     		jr 		_NoBranch
                        
036C:                   _posBranch:
036C: 08       [ 4]     		ex 		af,af' 						; save the direction in AF' (CC FWD, CS BWD)
036D: CB7C     [12]     		bit 	7,h 						; check HL is +ve or zero
036F: 2804     [19|24]  		jr 		z,_Branch
                        ;
                        ; 		Not Branching code
                        ;
0371:                   _NoBranch:
0371: E3       [19]     		ex 		(sp),hl 					; skip over the return address
0372: 23       [25]     		inc 	hl
0373: E3       [44]     		ex 		(sp),hl
0374: C9       [54]     		ret
                        ;
                        ; 		Branching code.
                        ;
0375:                   _Branch:
0375: D9       [ 4]     		exx 								; save registers.
0376: E3       [23]     		ex 		(sp),hl 					; get the branch offset into DE, position into HL
0377: 5E       [30]     		ld 		e,(hl)
0378: 1600     [37]     		ld 		d,0
037A: 08       [41]     		ex 		af,af' 						; get the direction flag back
037B: 3804     [48|53]  		jr 		c,_BranchBackwards
                        
037D:                   _BranchForwards:
037D: 19       [11]     		add 	hl,de  						; calculate the new address
037E: E3       [30]     		ex 		(sp),hl 					; fix up return address
037F: D9       [34]     		exx 								; restore registers and exit
0380: C9       [44]     		ret
                        
0381:                   _BranchBackwards:
0381: AF       [ 4]     		xor 	a 							; calculate new address
0382: ED52     [19]     		sbc 	hl,de
0384: E3       [38]     		ex 		(sp),hl 					; fix up return address
0385: D9       [42]     		exx 								; restore registers and exit
0386: C9       [52]     		ret
                        
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		unary.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Unary operators (A ? B -> A)
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
0387:                   M8_M__c45__c45__c45_:
0387: 2B       [ 6]     		dec 	hl
0388: 2B       [12]     		dec 	hl
0389:                   M8_M__c45__c45__c45__end:
                        
                        ; ***************************************************************************************
                        
0389:                   M8_M__c45__c45_:
0389: 2B       [ 6]     		dec 	hl
038A:                   M8_M__c45__c45__end:
                        
                        ; ***************************************************************************************
                        
038A:                   M8_M__c43__c43_:
038A: 23       [ 6]     		inc 	hl
038B:                   M8_M__c43__c43__end:
                        
                        ; ***************************************************************************************
                        
038B:                   M8_M__c43__c43__c43_:
038B: 23       [ 6]     		inc 	hl
038C: 23       [12]     		inc 	hl
038D:                   M8_M__c43__c43__c43__end:
                        
                        ; ***************************************************************************************
                        
038D:                   M8_C_0_c45_:
038D:                   __negate:
038D: 7C       [ 4]     		ld 		a,h
038E: 2F       [ 8]     		cpl
038F: 67       [12]     		ld 		h,a
0390: 7D       [16]     		ld 		a,l
0391: 2F       [20]     		cpl
0392: 6F       [24]     		ld 		l,a
0393: 23       [30]     		inc 	hl
0394: C9       [40]     		ret
0395:                   M8_C_0_c45__end:
                        
                        ; ***************************************************************************************
                        
0395:                   M8_C_0_c60_:
0395: CB7C     [ 8]     		bit 	7,h
0397: 210000   [18]     		ld 		hl,$0000
039A: C8       [23|29]  		ret 	z
039B: 2B       [29]     		dec 	hl
039C: C9       [39]     		ret
039D:                   M8_C_0_c60__end:
                        
                        ; ***************************************************************************************
                        
039D:                   M8_C_0_c61_:
039D: 7C       [ 4]     		ld 		a,h
039E: B5       [ 8]     		or 		l
039F: 210000   [18]     		ld 		hl,$0000
03A2: C0       [23|29]  		ret 	nz
03A3: 2B       [29]     		dec 	hl
03A4: C9       [39]     		ret
03A5:                   M8_C_0_c61__end:
                        
                        ; ***************************************************************************************
                        
03A5:                   M8_M_2_c42_:
03A5: 29       [11]     		add 	hl,hl
03A6:                   M8_M_2_c42__end:
                        
03A6:                   M8_M_4_c42_:
03A6: 29       [11]     		add 	hl,hl
03A7: 29       [22]     		add 	hl,hl
03A8:                   M8_M_4_c42__end:
                        
03A8:                   M8_M_8_c42_:
03A8: 29       [11]     		add 	hl,hl
03A9: 29       [22]     		add 	hl,hl
03AA: 29       [33]     		add 	hl,hl
03AB:                   M8_M_8_c42__end:
                        
03AB:                   M8_M_16_c42_:
03AB: 29       [11]     		add 	hl,hl
03AC: 29       [22]     		add 	hl,hl
03AD: 29       [33]     		add 	hl,hl
03AE: 29       [44]     		add 	hl,hl
03AF:                   M8_M_16_c42__end:
                        
03AF:                   M8_M_256_c42_:
03AF: 65       [ 4]     		ld 		h,l
03B0: 2E00     [11]     		ld		l,0
03B2:                   M8_M_256_c42__end:
                        
                        ; ***************************************************************************************
                        
03B2:                   M8_M_2_c47_:
03B2: CB2C     [ 8]     		sra 	h
03B4: CB1D     [16]     		rr 		l
03B6:                   M8_M_2_c47__end:
                        
03B6:                   M8_C_4_c47_:
03B6: CB2C     [ 8]     		sra 	h
03B8: CB1D     [16]     		rr 		l
03BA: CB2C     [24]     		sra 	h
03BC: CB1D     [32]     		rr 		l
03BE:                   M8_C_4_c47__end:
                        
03BE:                   M8_C_8_c47_:
03BE: CB2C     [ 8]     		sra 	h
03C0: CB1D     [16]     		rr 		l
03C2: CB2C     [24]     		sra 	h
03C4: CB1D     [32]     		rr 		l
03C6: CB2C     [40]     		sra 	h
03C8: CB1D     [48]     		rr 		l
03CA:                   M8_C_8_c47__end:
                        
03CA:                   M8_C_16_c47_:
03CA: CB2C     [ 8]     		sra 	h
03CC: CB1D     [16]     		rr 		l
03CE: CB2C     [24]     		sra 	h
03D0: CB1D     [32]     		rr 		l
03D2: CB2C     [40]     		sra 	h
03D4: CB1D     [48]     		rr 		l
03D6: CB2C     [56]     		sra 	h
03D8: CB1D     [64]     		rr 		l
03DA:                   M8_C_16_c47__end:
                        
03DA:                   M8_M_256_c47_:
03DA: 6C       [ 4]     		ld 		l,h
03DB: 2600     [11]     		ld 		h,0
03DD:                   M8_M_256_c47__end:
                        
                        ; ***************************************************************************************
                        
03DD:                   M8_C_abs:
03DD: CB7C     [ 8]     		bit 	7,h
03DF: C8       [13|19]  		ret		z
03E0: C38D03   [23]     		jp 		__negate
03E3:                   M8_C_abs_end:
                        
                        ; ***************************************************************************************
                        
03E3:                   M8_M_bswap:
03E3: 7D       [ 4]     		ld 		a,l
03E4: 6C       [ 8]     		ld 		l,h
03E5: 67       [12]     		ld 		h,a
03E6:                   M8_M_bswap_end:
                        
                        ; ***************************************************************************************
                        
03E6:                   M8_C_not:
03E6: 7C       [ 4]     		ld 		a,h
03E7: 2F       [ 8]     		cpl
03E8: 67       [12]     		ld 		h,a
03E9: 7D       [16]     		ld 		a,l
03EA: 2F       [20]     		cpl
03EB: 6F       [24]     		ld 		l,a
03EC: C9       [34]     		ret
03ED:                   M8_C_not_end:
                        
                        ; ***************************************************************************************
                        
03ED:                   M8_C_strlen:
03ED: D5       [11]     		push 	de
03EE: EB       [15]     		ex 		de,hl
03EF: 210000   [25]     		ld 		hl,0
03F2:                   _SLNLoop:
03F2: 1A       [ 7]     		ld 		a,(de)
03F3: B7       [11]     		or 		a
03F4: 2804     [18|23]  		jr 		z,_SLNExit
03F6: 13       [24]     		inc 	de
03F7: 23       [30]     		inc 	hl
03F8: 18F8     [42]     		jr 		_SLNLoop
03FA:                   _SLNExit:
03FA: D1       [10]     		pop 	de
03FB: C9       [20]     		ret
03FC:                   M8_C_strlen_end:
                        
                        ; ***************************************************************************************
                        
03FC:                   M8_C_random:
03FC: EB       [ 4]     	ex 		de,hl
03FD: C5       [15]     	push 	bc
03FE: 2A1904   [31]         ld 		hl,(_randomSeed1)
0401: 44       [35]         ld 		b,h
0402: 4D       [39]         ld 		c,l
0403: 29       [50]         add 	hl,hl
0404: 29       [61]         add 	hl,hl
0405: 2C       [65]         inc 	l
0406: 09       [76]         add 	hl,bc
0407: 221904   [92]         ld 		(_randomSeed1),hl
040A: 2A1B04   [108]        ld 		hl,(_randomSeed2)
040D: 29       [119]        add 	hl,hl
040E: 9F       [123]        sbc 	a,a
040F: E62D     [130]        and 	%00101101
0411: AD       [134]        xor 	l
0412: 6F       [138]        ld 		l,a
0413: 221B04   [154]        ld 		(_randomSeed2),hl
0416: 09       [165]        add 	hl,bc
0417: C1       [175]        pop 	bc
0418: C9       [185]        ret
                        
0419:                   _randomSeed1:
0419: CDAB              	.dw 	$ABCD
041B:                   _randomSeed2:
041B: B9FD              	.dw 	$FDB9
                        
                        ; *********************************************************************************************
                        ; *********************************************************************************************
                        ;
                        ;		Name:		spritemanager.asm
                        ;		Purpose:	Sprite Manager
                        ;		Created:	1st November 2021
                        ;		Author:		Paul Robson (paul@robsons.org.uk)
                        ;
                        ; *********************************************************************************************
                        ; *********************************************************************************************
                        ;
                        ;		Sprite Record:
                        ;
                        ; 			Current Data: (as per xsprite.asm)
                        ;				0..6 	X:2 	Y:2 	Graphics:2 	Control:1
                        ;				7 		Status byte
                        ;			To Copy data:
                        ;				8..14 	X:2 	Y:2 	Graphics:2 	Control:1
                        ;				15 		Change flag
                        ;
                        ;		When being updated, if the change flag is set, then the sprite is removed, then data
                        ;		(8-14) is copied to (0-6), then the sprite redrawn
                        ;
                        ;		The option also exists to erase all sprites ; the point of such being that one can update
                        ;		the background. This sets all the change flags so the sprites are redrawn on the next sync.
                        ;
                        ; *********************************************************************************************
                        ;
                        ;
                        ;			Reset Sprite Manager. HL points to data block, DE is number of sprites
                        ;
                        ;
                        ; *********************************************************************************************
                        
041D:                   M8_C_spr_c46_reset:
                        
041D:                   SPMReset:
041D: F5       [11]     		push 	af
041E: C5       [22]     		push 	bc
041F: D5       [33]     		push 	de
0420: E5       [44]     		push 	hl
0421: 222505   [60]     		ld 		(SPMData),hl 				; save count and address
0424: 7B       [64]     		ld 		a,e
0425: 322705   [77]     		ld 		(SPMCount),a
0428: 87       [81]     		add 	a,a 						; double, as we clear it twice (2 x 8 byte blocks)
0429: 47       [85]     		ld 		b,a
042A:                   _SPMClear:
042A: 0E06     [ 7]     		ld 		c,6 						; write out 6 $FFs to position and graphic
042C:                   _SPMClear2:
042C: 36FF     [10]     		ld 		(hl),$FF
042E: 23       [16]     		inc 	hl
042F: 0D       [20]     		dec 	c
0430: 20FA     [27|32]  		jr 		nz,_SPMClear2
0432: 71       [34]     		ld 		(hl),c 						; followed by 2 zeros (control and status/change byte)
0433: 23       [40]     		inc 	hl
0434: 71       [47]     		ld 		(hl),c
0435: 23       [53]     		inc 	hl
0436: 10F2     [61|66]  		djnz 	_SPMClear
0438: 212B05   [71]     		ld 		hl,SPMUnused 				; no current selection
043B: 222905   [87]     		ld 		(SPMCurrent),hl
043E: CD3B05   [104]    		call 	SPRInitialise 				; erase the sprite control records.
0441: E1       [114]    		pop 	hl
0442: D1       [124]    		pop 	de
0443: C1       [134]    		pop 	bc
0444: F1       [144]    		pop 	af
0445: C9       [154]    		ret
                        
0446:                   M8_C_spr_c46_reset_end:
                        
                        ; *********************************************************************************************
                        ;
                        ;		Sprite functions/words. A sprite is selected via SPMSelect and then moved, graphics
                        ; 		set etc. by other functions. SPMUpdate updates all sprites. Parameters at L/HL then DE.
                        ;
                        ; *********************************************************************************************
                        
0446:                   M8_C_spr_c46_select:
                        
0446:                   SPMSelect:
0446: F5       [11]     		push 	af
0447: C5       [22]     		push 	bc
0448: E5       [33]     		push 	hl
0449: 3A2705   [46]     		ld		a,(SPMCount)
044C: BD       [50]     		cp 		l 							; compare max vs selected.
044D: 280E     [57|62]  		jr 		z,_SPMSFail 				; must be >
044F: FA5D04   [67|67]  		jp 		m,_SPMSFail
                        
0452: 29       [78]     		add 	hl,hl 						; x 16
0453: 29       [89]     		add 	hl,hl
0454: 29       [100]    		add 	hl,hl
0455: 29       [111]    		add 	hl,hl
0456: ED5B2505 [131]    		ld 		de,(SPMData) 				; add base address
045A: 19       [142]    		add 	hl,de
045B: 1803     [154]    		jr 		_SPMSExit 					; write and exit
                        
045D:                   _SPMSFail:
045D: 212B05   [10]     		ld 		hl,SPMUnused
0460:                   _SPMSExit:
0460: 222905   [16]     		ld 		(SPMCurrent),hl
0463: E1       [26]     		pop 	hl
0464: D1       [36]     		pop 	de
0465: F1       [46]     		pop 	af
0466: C9       [56]     		ret
0467:                   M8_C_spr_c46_select_end:
                        
                        ; *********************************************************************************************
                        ;
                        ;										X Y SPR.MOVE
                        ;
                        ; *********************************************************************************************
                        
0467:                   M8_C_spr_c46_move:
0467:                   SPMMove:
0467: DDE5     [15]     		push 	ix
0469: DD2A2905 [35]     		ld 		ix,(SPMCurrent)
046D: DD7308   [54]     		ld 		(ix+8),e 					; write X
0470: DD7209   [73]     		ld 		(ix+9),d
0473: DD750A   [92]     		ld 		(ix+10),l 					; write Y
0476: DD740B   [111]    		ld 		(ix+11),h
0479:                   _SPMGeneralExit:
0479: DDCB0FFE [23]     		set 	7,(ix+15)
047D: DDE1     [37]     		pop 	ix
047F: C9       [47]     		ret
0480:                   M8_C_spr_c46_move_end:
                        
                        ; *********************************************************************************************
                        ;
                        ;									   GDATA SPR.IMAGE
                        ;
                        ; *********************************************************************************************
                        
0480:                   M8_C_spr_c46_image:
0480:                   SPRImage:
0480: DDE5     [15]     		push 	ix
0482: DD2A2905 [35]     		ld 		ix,(SPMCurrent)
0486: DD750C   [54]     		ld 		(ix+12),l
0489: DD740D   [73]     		ld 		(ix+13),h
048C: 18EB     [85]     		jr 		_SPMGeneralExit
048E:                   M8_C_spr_c46_image_end:
                        
                        ; *********************************************************************************************
                        ;
                        ;									   CBYTE SPR.CONTROL
                        ;
                        ; *********************************************************************************************
                        
048E:                   M8_C_spr_c46_control:
048E:                   SPMControl:
048E: DDE5     [15]     		push 	ix
0490: DD2A2905 [35]     		ld 		ix,(SPMCurrent)
0494: DD750E   [54]     		ld 		(ix+14),l
0497: 18E0     [66]     		jr 		_SPMGeneralExit
0499:                   M8_C_spr_c46_control_end:
                        
                        ; *********************************************************************************************
                        ;
                        ;							   <bool> SPR.VFLIP / HFLIP
                        ;
                        ; *********************************************************************************************
                        
0499:                   M8_C_spr_c46_hflip:
0499:                   SPMHFlip:
0499: F5       [11]     		push 	af
049A: DDE5     [26]     		push 	ix
049C: DD2A2905 [46]     		ld 		ix,(SPMCurrent)
04A0: DDCB0EAE [69]     		res 	5,(ix+14)
04A4: 7D       [73]     		ld 		a,l
04A5: B4       [77]     		or 		h
04A6: 2819     [84|89]  		jr 		z,_SPCTExit
04A8: DDCB0EEE [107]    		set 	5,(ix+14)
04AC: 1813     [119]    		jr 		_SPCTExit
04AE:                   M8_C_spr_c46_hflip_end:
                        
04AE:                   M8_C_spr_c46_vflip:
04AE:                   SPMVFlip:
04AE: F5       [11]     		push 	af
04AF: DDE5     [26]     		push 	ix
04B1: DD2A2905 [46]     		ld 		ix,(SPMCurrent)
04B5: DDCB0EB6 [69]     		res 	6,(ix+14)
04B9: 7D       [73]     		ld 		a,l
04BA: B4       [77]     		or 		h
04BB: 2804     [84|89]  		jr 		z,_SPCTExit
04BD: DDCB0EFE [107]    		set 	7,(ix+14)
04C1:                   _SPCTExit:
04C1: DDCB0FFE [23]     		set 	7,(ix+15)
04C5: DDE1     [37]     		pop 	ix
04C7: F1       [47]     		pop 	af
04C8: C9       [57]     		ret
04C9:                   M8_C_spr_c46_vflip_end:
                        
                        ; *********************************************************************************************
                        ;
                        ;										Update all sprites
                        ;
                        ; *********************************************************************************************
                        
04C9:                   M8_C_spr_c46_update:
                        
04C9:                   SPMUpdate:
04C9: F5       [11]     		push 	af
04CA: C5       [22]     		push 	bc
04CB: D5       [33]     		push 	de
04CC: E5       [44]     		push 	hl
04CD: DDE5     [59]     		push 	ix
                        
04CF: 3A2705   [72]     		ld 		a,(SPMCount)
04D2: 47       [76]     		ld 		b,a
04D3: DD2A2505 [96]     		ld 		ix,(SPMData)
04D7:                   _SPMUpdateLoop:
04D7: DD7E0F   [19]     		ld 		a,(ix+15) 					; check redraw flag
04DA: B7       [23]     		or 		a
04DB: C4EC04   [33|40]  		call 	nz,_SPMUpdateOne 			; if non zero update this one
04DE: 111000   [43]     		ld 		de,16
04E1: DD19     [58]     		add 	ix,de
04E3: 10F2     [66|71]  		djnz 	_SPMUpdateLoop
                        
04E5: DDE1     [80]     		pop 	ix
04E7: E1       [90]     		pop 	hl
04E8: C1       [100]    		pop 	bc
04E9: D1       [110]    		pop 	de
04EA: F1       [120]    		pop 	af
04EB: C9       [130]    		ret
                        ;
                        ;		Updates one sprite from new data if redraw flag found set.
                        ;
04EC:                   _SPMUpdateOne:
04EC: C5       [11]     		push 	bc
04ED: DD360F00 [30]     		ld 		(ix+15),0 					; clear the redraw flag.
04F1: CD6405   [47]     		call 	SpriteXErase 				; erase sprite
04F4: DDE5     [62]     		push 	ix 							; copy target address in DE
04F6: D1       [72]     		pop 	de
04F7: 210800   [82]     		ld 		hl,8
04FA: 19       [93]     		add 	hl,de 						; target DE, source HL
04FB: 010700   [103]    		ld 		bc,7 						; copy 7 bytes over
04FE: EDB0     [119|21] 		ldir
0500: CD5D05   [136]    		call 	SpriteXDraw 				; redraw sprite
0503: C1       [146]    		pop 	bc
0504: C9       [156]    		ret
0505:                   M8_C_spr_c46_update_end:
                        
                        ; *********************************************************************************************
                        ;
                        ;							Hide all sprites (to change background)
                        ;
                        ; *********************************************************************************************
                        
0505:                   M8_C_spr_c46_hide_c46_all:
                        
0505:                   SPMHideAll:
0505: F5       [11]     		push 	af
0506: C5       [22]     		push 	bc
0507: D5       [33]     		push 	de
0508: DDE5     [48]     		push 	ix
050A: 3A2705   [61]     		ld 	 	a,(SPMCount)
050D: 47       [65]     		ld 		b,a
050E: DD2A2505 [85]     		ld 		ix,(SPMData)
0512: 111000   [95]     		ld 		de,16
0515:                   _SPMHideLoop:
0515: CD6405   [17]     		call 	SpriteXErase 				; remove sprite
0518: DDCB0FFE [40]     		set 	7,(ix+15) 					; force redraw next update
051C: DD19     [55]     		add 	ix,de
051E: 10F5     [63|68]  		djnz 	_SPMHideLoop
0520: E1       [73]     		pop 	hl
0521: C1       [83]     		pop 	bc
0522: D1       [93]     		pop 	de
0523: F1       [103]    		pop 	af
0524: C9       [113]    		ret
0525:                   M8_C_spr_c46_hide_c46_all_end:
                        
0525:                   SPMData: 									; address of sprite
0525: 0000              		.dw 	0
0527:                   SPMCount: 									; number of sprites
0527: 0000              		.dw 	0
0529:                   SPMCurrent: 								; currently selected sprite (may point to unused junk space)
0529: 0000              		.dw 	0
052B:                   SPMUnused: 									; space for junk writes.
052B: 00000000          		.ds 	16,0
052F: 00...             
                        ; *********************************************************************************************
                        ; *********************************************************************************************
                        ;
                        ;		Name:		xsprite.asm
                        ;		Purpose:	XOR Sprite Drawer
                        ;		Created:	29th October 2021
                        ;		Author:		Paul Robson (paul@robsons.org.uk)
                        ;
                        ; *********************************************************************************************
                        ; *********************************************************************************************
                        
                        ; *********************************************************************************************
                        ;
                        ;		This is an XOR drawing sprite system. This is useful because the draw is self
                        ;		cancelling, and this means you don't have to repaint multiple sprites to restore
                        ; 		the display state. The downside is that it doesn't work well on collisions or
                        ; 		especially backgrounds.
                        ;
                        ;		The original design, which was a simpler draw all/erase all design, was binned
                        ;		because I thought on real hardware it would create too much flash on the display.
                        ;
                        ;		I don't yet have a real machine so can't evaluate this in practice, as the emulator
                        ; 		snapshots the display at 60Mhz, so the effects of endlessly messing with the
                        ;		CRAM and VRAM is largely hidden.
                        ;
                        ;		At 4Mhz it does about 330 draws/erases a second on a 16x16 sprites, twice as fast on
                        ;		8 pixel high sprites.
                        ;
                        ;		It eats UDGs - a single 16x16 sprite needs 9 UDGs if it doesn't overlap with another.
                        ;
                        ; *********************************************************************************************
                        ;
                        ;		How it works.
                        ;
                        ;			When drawing a sprite, it will try to allocate UDGs from its pool for the space
                        ; 			to draw the sprite. When drawing or erasing it then XORs the bit patterns into this
                        ; 			as far as it can. When erased, UDGs are returned to the pool if no longer required.
                        ;
                        ; *********************************************************************************************
                        ;
                        ;		Offsets from IX.
                        ;
                        ;			+0,+1 		Horizontal position (0..319)
                        ;			+2,+3 		Vertical position (0..239)
                        ;			+4,+5 		Pointer to graphic image data.
                        ;							Width : 8  	one byte per row
                        ;							Width : 16 	two bytes per row left-right order
                        ;			+6 			Control
                        ;							Bit 7: 		Set if sprite disabled
                        ;							Bit 6: 		Vertical flip
                        ;							Bit 5:		Horizontal flip
                        ;							Bit 4..2:	0
                        ;							Bit 1:		Double width
                        ;							Bit 0: 		Double height
                        ;			+7 			Status
                        ;							Bit 7:		Set when drawn on screen
                        ;							Bit 6..0:	0
                        ;
                        ;			Changes should only be made when the sprite is not drawn, otherwise chaos
                        ;			will ensue.
                        ;
                        ;			Draws will not fail, however, they may not visually work either. If there are more
                        ;			UDGs required than available graphics will not be drawn, or possibly drawn
                        ;			erratically. It is advised to minimise the number of sprites both for CPU time
                        ;			and UDG usage.
                        ;
                        ;			Use specific UDGs for static/slow objects. For (say) Pacman the only sprites should
                        ;			be the player character and chasing ghosts.
                        ;
                        ; *********************************************************************************************
                        ;
                        ;								  Sprite Record entries
                        ;
                        ; *********************************************************************************************
                        
0000:                   SPRx 	= 0 								; horizontal position, pixels
0002:                   SPRy 	= 2 								; vertical position, pixels
0004:                   SPRgraphics = 4 							; bitmap data
0006:                   SPRcontrol = 6 								; 0:width 1:height 5:HFlip 6:VFlip 7:hidden
                        											; (others are zero)
0007:                   SPRstatus = 7 								; 7:currently drawn
                        
                        ; *********************************************************************************************
                        ;
                        ; 								Initialise the sprite system.
                        ;
                        ; 	At this point sprite records should all have their "currently drawn" bit clear, it will
                        ; 	get very confused otherwise.
                        ;
                        ; *********************************************************************************************
                        
053B:                   SPRInitialise:
053B: F5       [11]     		push 	af
053C: E5       [22]     		push 	hl
                        		;
                        		; 		Clear the main data area.
                        		;
053D: 210008   [32]     		ld 		hl,SPRDataBlock
0540:                   _SPRZeroBlock:
0540: 3600     [10]     		ld 		(hl),$00
0542: 23       [16]     		inc 	hl
0543: 7C       [20]     		ld 		a,h
0544: FE0C     [27]     		cp 		SPRDataBlockEnd >> 8
0546: 20F8     [34|39]  		jr 		nz,_SPRZeroBlock
                        		;
                        		; 		Set all possible original characters to $FF, indicating they are available.
                        		;
0548: 3AC407   [47]     		ld 		a,(_SPRFirstUDGSprite)
054B: 6F       [51]     		ld 		l,a
054C: 2608     [58]     		ld 		h,SPROriginalChar >> 8
054E:                   _SPRUsageReset:
054E: 36FF     [10]     		ld 		(hl),$FF
0550: 2C       [14]     		inc 	l
0551: 20FB     [21|26]  		jr 		nz,_SPRUsageReset
0553: E1       [31]     		pop 	hl
0554: F1       [41]     		pop 	af
0555: C9       [51]     		ret
                        
                        ; *********************************************************************************************
                        ;
                        ; 									Allocate lowest UDG
                        ;
                        ; *********************************************************************************************
                        
0556:                   M8_C_sprite_c46_udg_c46_base_c33_:
0556:                   SpriteSetLowestUDG:
0556: F5       [11]     		push 	af
0557: 7D       [15]     		ld 		a,l
0558: 32C407   [28]     		ld 		(_SPRFirstUDGSprite),a
055B: F1       [38]     		pop 	af
055C: C9       [48]     		ret
055D:                   M8_C_sprite_c46_udg_c46_base_c33__end:
                        
                        ; *********************************************************************************************
                        ;
                        ;						Draw, or Erase, the sprite whose raw data is at IX
                        ;
                        ; *********************************************************************************************
                        
055D:                   SpriteXDraw: 								; draw only
055D: DDCB077E [20]     		bit 	7,(ix+SPRstatus)
0561: C0       [25|31]  		ret 	nz
0562: 1805     [37]     		jr 		SpriteXToggle
0564:                   SpriteXErase:								; erase only
0564: DDCB077E [20]     		bit 	7,(ix+SPRstatus)
0568: C8       [25|31]  		ret 	z
0569:                   SpriteXToggle:								; flip state
0569: F5       [11]     		push 	af 							; save registers
056A: C5       [22]     		push 	bc
056B: D5       [33]     		push 	de
056C: E5       [44]     		push 	hl
056D: FDE5     [59]     		push 	iy
                        		;
                        		; 		Check actually visible
                        		;
056F: DDCB067E [79]     		bit 	7,(ix+SPRcontrol)
0573: C2A406   [89|89]  		jp 		nz,_SPRExit
                        		;
                        		; 		Check range.
                        		;
0576: DD7E01   [108]    		ld 		a,(ix+SPRx+1) 				; MSB of X must be 0 or 1
0579: 47       [112]    		ld 		b,a 						; save in B
057A: E6FE     [119]    		and 	$FE
057C: DDB603   [138]    		or 		a,(ix+SPRy+1) 				; MSB of Y must be zero.
057F: 2011     [145|150]		jr 		nz,_SPRRangeFail
                        		;
0581: DD7E02   [164]    		ld 		a,(ix+SPRy) 				; check Y < 240
0584: FEF0     [171]    		cp 		8*30
0586: 300A     [178|183]		jr 		nc,_SPRRangeFail
                        		;
0588: 05       [182]    		dec 	b 							; if MSB X was 1, now zero
0589: 200A     [189|194]		jr 		nz,_SPRCalcPosition
                        		;
058B: DD7E00   [208]    		ld 		a,(ix+SPRx) 				; X.MSB was 1, so must be X.LSB < 64
058E: FE40     [215]    		cp 		64
0590: 3803     [222|227]		jr 		c,_SPRCalcPosition
0592:                   _SPRRangeFail:
0592: C3A406   [10]     		jp 		_SPRExit
                        		;
                        		;		Calculate position in IY
                        		;
0595:                   _SPRCalcPosition:
0595: 2600     [ 7]     		ld 		h,0							; Y position in HL, with lower 3 bits masked, so already x 8
0597: DD7E02   [26]     		ld 		a,(ix+SPRy)
059A: E6F8     [33]     		and 	$F8
059C: 6F       [37]     		ld 		l,a
059D: 54       [41]     		ld 		d,h 						; DE = Y x 8
059E: 5D       [45]     		ld 		e,l
059F: 29       [56]     		add 	hl,hl 						; HL = Y x 32
05A0: 29       [67]     		add 	hl,hl
05A1: 19       [78]     		add 	hl,de 						; HL = Y x 40
05A2: FD2100F8 [92]     		ld 		iy,$F800 					; IY = $F800 + Y x 40
05A6: EB       [96]     		ex 		de,hl
05A7: FD19     [111]    		add 	iy,de
                        
05A9: DD5E00   [130]    		ld 		e,(ix+SPRx)					; DE = X position
05AC: DD5601   [149]    		ld 		d,(ix+SPRx+1)
05AF: CB3A     [157]    		srl 	d 							; / 8 (after first in range 0-255 hence SRL E)
05B1: CB1B     [165]    		rr 		e
05B3: CB3B     [173]    		srl 	e
05B5: CB3B     [181]    		srl 	e
05B7: 1600     [188]    		ld 		d,0 						; add to screen position.
05B9: FD19     [203]    		add 	iy,de
                        		;
                        		; 		Calculate and patch the fine horizontal shift jump which adjusts the
                        		; 		number of 24 bit left shifts we do to the graphics data.
                        		;
05BB: DD7E00   [222]    		ld 		a,(ix+SPRx)
05BE: E607     [229]    		and 	7
05C0: 87       [233]    		add 	a,a
05C1: 324D06   [246]    		ld 		(_SPRFineHorizontalShift+1),a
                        		;
                        		; 		Calculate the horizontal offset which makes it start drawing part way through a UDG
                        		;
05C4: DD7E02   [265]    		ld 		a,(ix+SPRy)
05C7: E607     [272]    		and 	7
05C9: 32C107   [285]    		ld 		(_SPRInitialYOffset),a
                        		;
                        		; 		Calculate the row count from bit 1 of the control byte
                        		; 		(the number of vertical pixels down)
                        		;
05CC: 3E08     [292]    		ld 		a,8
05CE: DDCB064E [312]    		bit 	1,(ix+SPRcontrol)
05D2: 2801     [319|324]		jr 		z,_SPRSingleHeight
05D4: 87       [323]    		add 	a,a
05D5:                   _SPRSingleHeight:
05D5: 32C007   [13]     		ld 		(_SPRRowCount),a
                        		;
                        		;		Set the sprite graphic address and incrementer.
                        		;
05D8: DD6E04   [32]     		ld 		l,(ix+SPRgraphics) 			; data address
05DB: DD6605   [51]     		ld 		h,(ix+SPRgraphics+1)
05DE: 110100   [61]     		ld 		de,1 						; increment/decrement
05E1: DDCB0646 [81]     		bit 	0,(ix+SPRcontrol)
05E5: 2801     [88|93]  		jr 		z,_SPRSGANotDoubleWidth
05E7: 13       [94]     		inc 	de 							; 2 if double width
05E8:                   _SPRSGANotDoubleWidth:
05E8: DDCB0676 [20]     		bit 	6,(ix+SPRcontrol) 			; check for vertical flip.
05EC: 2818     [27|32]  		jr 		z,_SPRSGANotVFlip
                        		;
05EE: EB       [31]     		ex 		de,hl 						; DE = address, HL = increment x 8
05EF: E5       [42]     		push 	hl
05F0: 29       [53]     		add 	hl,hl
05F1: 29       [64]     		add 	hl,hl
05F2: 29       [75]     		add 	hl,hl
05F3: DDCB064E [95]     		bit 	1,(ix+SPRcontrol) 			; x 16 if double height
05F7: 2801     [102|107]		jr 		z,_SPRSGANotDoubleHeight
05F9: 29       [113]    		add 	hl,hl
05FA:                   _SPRSGANotDoubleHeight:
05FA: 19       [11]     		add 	hl,de 						; add 8/16 x increment to start
05FB: C1       [21]     		pop 	bc 							; original increment -> BC
05FC: E5       [32]     		push 	hl 							; save new start on stack.
05FD: 210000   [42]     		ld 		hl,0 						; HL = - increment
0600: AF       [46]     		xor 	a
0601: ED42     [61]     		sbc 	hl,bc
0603: D1       [71]     		pop 	de 							; DE = new start off stack
0604: EB       [75]     		ex 		de,hl 						; swap them back so HL = address, DE = -increment
0605: 19       [86]     		add 	hl,de 						; points HL to the last sprite entry.
0606:                   _SPRSGANotVFlip:
0606: 222B06   [16]     		ld 		(_SPRFetchGraphicPtr+1),hl 	; write out start address in HL and incrementer in DE.
0609: ED533B06 [36]     		ld 		(_SPRAdjustGraphicPtr+1),de
                        		;
                        		; 		Try to allocate UDGs for the current row at IY, 2 or 3 UDGs.
                        		;
060D:                   _SPRStartNextCharacterRow:
060D: CDB306   [17]     		call 	_SPRAllocateRow 			; try to allocate the whole row.
0610: DAA406   [27|27]  		jp 		c,_SPRExit					; it didn't work, so we abandon drawing here.
                        		;
                        		; 		Adjust the usage counters.
                        		;
0613: FDE5     [42]     		push 	iy
0615: CD6B07   [59]     		call 	SPRAdjustUsageCounter
0618: FD23     [69]     		inc 	iy
061A: CD6B07   [86]     		call 	SPRAdjustUsageCounter
061D: DDCB0646 [106]    		bit 	0,(ix+SPRcontrol)
0621: 2805     [113|118]		jr 		z,_SPRAuNotRight
0623: FD23     [123]    		inc 	iy
0625: CD6B07   [140]    		call 	SPRAdjustUsageCounter
0628:                   _SPRAuNotRight:
0628: FDE1     [14]     		pop 	iy
                        		;
                        		;		Get the graphics for the next *pixel* line. into ADE
                        		;
062A:                   _SPRNextRowUDG:
                        		;
062A:                   _SPRFetchGraphicPtr:
062A: 210000   [10]     		ld 		hl,$0000
062D: 1E00     [17]     		ld 		e,0							; DE = $00:(HL)
062F: 56       [24]     		ld 		d,(hl)
0630: DDCB0646 [44]     		bit 	0,(ix+SPRcontrol) 			; is the width 1 ?
0634: 2804     [51|56]  		jr 		z,_SPRHaveGraphicData
0636: 23       [57]     		inc 	hl
0637: 5A       [61]     		ld 		e,d  						; DE = (HL+1):(HL)
0638: 56       [68]     		ld 		d,(hl)
0639: 2B       [74]     		dec 	hl
063A:                   _SPRHaveGraphicData:
                        		;
063A:                   _SPRAdjustGraphicPtr:
063A: 010000   [10]     		ld 		bc,$0000 					; this is changed to account for size and
063D: 09       [21]     		add 	hl,bc 						; direction.
063E: 222B06   [37]     		ld 		(_SPRFetchGraphicPtr+1),hl
                        		;
                        		; 		Check for Horizontal Flip
                        		;
0641: DDCB066E [57]     		bit 	5,(ix+SPRcontrol)			; if HFlip bit set
0645: 2803     [64|69]  		jr 		z,_SPRNoHFlip
0647: CD8707   [81]     		call 	SPRFlipDE 					; Flip DE
064A:                   _SPRNoHFlip:
064A: AF       [ 4]     		xor 	a 							; ADE contains 24 bit graphic data.
064B: EB       [ 8]     		ex 		de,hl 						; we put it in AHL
064C:                   _SPRFineHorizontalShift:
064C: 1800     [12]     		jr 		$+2 						; this is altered to do the fine horizontal shift
064E: 29       [23]     		add 	hl,hl
064F: 8F       [27]     		adc 	a,a
0650: 29       [38]     		add 	hl,hl
0651: 8F       [42]     		adc 	a,a
0652: 29       [53]     		add 	hl,hl
0653: 8F       [57]     		adc 	a,a
0654: 29       [68]     		add 	hl,hl
0655: 8F       [72]     		adc 	a,a
0656: 29       [83]     		add 	hl,hl
0657: 8F       [87]     		adc 	a,a
0658: 29       [98]     		add 	hl,hl
0659: 8F       [102]    		adc 	a,a
065A: 29       [113]    		add 	hl,hl
065B: 8F       [117]    		adc 	a,a
065C: 29       [128]    		add 	hl,hl
065D: 8F       [132]    		adc 	a,a
065E: EB       [136]    		ex 		de,hl 						; put it back in ADE
                        		;
                        		;		Now XOR the data with the previously calculated addresses.
                        		;		If (ix+5)[0] is clear then don't do the third one, it's an 8x8 sprite
                        		;
                        		;		These addresses (the ld hl,xxxx ones) are modified in situ.
                        		;
065F:                   _SPRLeftUDGPosition:
065F: 2108F6   [10]     		ld 		hl,$F000+$C1*8
0662: AE       [17]     		xor 	(hl)
0663: 77       [24]     		ld 		(hl),a
0664:                   _SPRMiddleUDGPosition:
0664: 2110F6   [10]     		ld 		hl,$F000+$C2*8
0667: 7A       [14]     		ld 		a,d
0668: AE       [21]     		xor 	(hl)
0669: 77       [28]     		ld 		(hl),a
066A: DDCB0646 [48]     		bit 	0,(ix+SPRcontrol) 					; if width 1, skip the last draw
066E: 2806     [55|60]  		jr 		z,_SPRDrawEnd
0670:                   _SPRRightUDGPosition:
0670: 2118F6   [10]     		ld 		hl,$F000+$C3*8
0673: 7B       [14]     		ld 		a,e
0674: AE       [21]     		xor 	(hl)
0675: 77       [28]     		ld 		(hl),a
0676:                   _SPRDrawEnd:
                        		;
                        		; 		Check if we have done all the rows
                        		;
0676: 21C007   [10]     		ld 		hl,_SPRRowCount
0679: 35       [21]     		dec 	(hl)
067A: 2828     [28|33]  		jr 		z,_SPRExit
                        		;
                        		; 		Now go to the next line down. Initially this just advances the vertical offset
                        		;		in the UDG pointers
                        		;
067C: 216506   [38]     		ld 		hl,_SPRMiddleUDGPosition+1
067F: 34       [49]     		inc 	(hl)
0680: 217106   [59]     		ld 		hl,_SPRRightUDGPosition+1 	; not guaranteed initialised.
0683: 34       [70]     		inc 	(hl)
0684: 216006   [80]     		ld 		hl,_SPRLeftUDGPosition+1
0687: 34       [91]     		inc 	(hl)
                        		;
0688: 7E       [98]     		ld 		a,(hl) 						; check crossed 8 byte boundary
0689: E607     [105]    		and 	7
068B: 209D     [112|117]		jr 		nz,_SPRNextRowUDG 			; if not complete it.
                        
068D: AF       [116]    		xor 	a 							; clear the initial offset
068E: 32C107   [129]    		ld 		(_SPRInitialYOffset),a
                        
                        
0691: 112800   [139]    		ld 		de,40 						; advance down one row.
0694: FD19     [154]    		add 	iy,de
                        
0696: 11B0FC   [164]    		ld 		de,$F800+40*30 				; the end of the physical display
0699: FDE5     [179]    		push 	iy
069B: E1       [189]    		pop 	hl
069C: 37       [193]    		scf
069D: ED52     [208]    		sbc 	hl,de
069F: 3003     [215|220]		jr 		nc,_SPRExit 				; past the bottom,exit.
                        
06A1: C30D06   [225]    		jp 		_SPRStartNextCharacterRow 	; do the next character row.
                        
06A4:                   _SPRExit:
06A4: DD7E07   [19]     		ld 		a,(ix+SPRstatus) 			; toggle the drawn status bit
06A7: EE80     [26]     		xor 	$80
06A9: DD7707   [45]     		ld 		(ix+SPRstatus),a
                        
06AC: FDE1     [59]     		pop 	iy 							; restore registers
06AE: E1       [69]     		pop 	hl
06AF: D1       [79]     		pop 	de
06B0: C1       [89]     		pop 	bc
06B1: F1       [99]     		pop 	af
06B2: C9       [109]    		ret
                        
                        ; *********************************************************************************************
                        ;
                        ;		Allocate 0-3 UDGs to the character space according to need and availability.
                        ; 		Fail with CS if can't.
                        ;		If possible,
                        ;			all new UDGs should have the copied graphic from the background and the
                        ;			old background set up.
                        ;			the UDGs should replace the graphics in IY.
                        ;
                        ; *********************************************************************************************
                        
06B3:                   _SPRAllocateRow:
06B3: C5       [11]     		push 	bc 							; save BC.
06B4: FDE5     [26]     		push 	iy 							; save IY
06B6: ED73C207 [46]     		ld 		(_SPRAllocSPTemp),sp		; save SP as we are using it for temp.
                        
06BA: DDCB077E [66]     		bit 	7,(ix+SPRstatus) 			; are we erasing ?
06BE: 280A     [73|78]  		jr 		z,_SPRARNotErasing
                        
06C0: 3AC407   [86]     		ld 		a,(_SPRFirstUDGSprite)		; B = first sprite useable
06C3: 47       [90]     		ld 		b,a
06C4: FD7E00   [109]    		ld 		a,(iy+0) 					; if erasing, check if row is drawn on UDGs
06C7: B8       [113]    		cp 		b
06C8: 384C     [120|125]		jr 		c,_SPRAllocateExit 			; and if so don't allocate the row, exit.
                        
06CA:                   _SPRARNotErasing:
06CA: 210000   [10]     		ld 		hl,$0000 					; we save all the allocated so far on the stack
06CD: E5       [21]     		push 	hl 		 					; this is the end marker.
                        		;
                        		; 		Do 2 or 3. For each overwrite the XOR code addresses and save
                        		;		it on the stack. If it fails, then unwind everything.
                        		;
06CE: CD1E07   [38]     		call 	_SPRAllocateOne 			; do (IY)
06D1: 3821     [45|50]  		jr 		c,_SPRAllocateUndo 			; if done, then Undo.
06D3: 226006   [61]     		ld 		(_SPRLeftUDGPosition+1),hl 	; overwrite the code.
06D6: E5       [72]     		push 	hl
                        
06D7: FD23     [82]     		inc 	iy
06D9: CD1E07   [99]     		call 	_SPRAllocateOne 			; do (IY+1)
06DC: 3816     [106|111]		jr 		c,_SPRAllocateUndo 			; if done, then Undo.
06DE: 226506   [122]    		ld 		(_SPRMiddleUDGPosition+1),hl ; overwrite the code.
06E1: E5       [133]    		push 	hl
                        
06E2: DDCB0646 [153]    		bit 	0,(ix+SPRcontrol) 			; if 8 width then we are done.
06E6: 282D     [160|165]		jr 		z,_SPRAllocateOkay
                        
06E8: FD23     [170]    		inc 	iy
06EA: CD1E07   [187]    		call 	_SPRAllocateOne 			; do (IY+2)
06ED: 3805     [194|199]		jr 		c,_SPRAllocateUndo 			; if done, then Undo.
06EF: 227106   [210]    		ld 		(_SPRRightUDGPosition+1),hl ; overwrite the code.
06F2: 1821     [222]    		jr 		_SPRAllocateOkay
                        		;
                        		; 		Failed, so pop the saved UDG addresses on the stack and reset
                        		;	 	as if we hadn't allocated it. We haven't bumped the usage count yet.
                        		;
06F4:                   _SPRAllocateUndo:
06F4: D1       [10]     		pop 	de 							; address of UDG into DE
06F5: 7A       [14]     		ld 		a,d 						; have we done the whole lot ?
06F6: B3       [18]     		or 		e
06F7: 37       [22]     		scf
06F8: 281C     [29|34]  		jr 		z,_SPRAllocateExit 			; if so, e.g. popped $0000 with carry set.
                        
06FA: CB3A     [37]     		srl 	d 							; divide by 8 - will put the UDG number into E
06FC: CB1B     [45]     		rr 		e
06FE: CB3A     [53]     		srl 	d
0700: CB1B     [61]     		rr 		e
0702: CB3A     [69]     		srl 	d
0704: CB1B     [77]     		rr 		e
                        		;
0706: 6B       [81]     		ld 		l,e 						; HL is the address of the original character for this UDG.
0707: 2608     [88]     		ld 		h,SPROriginalChar >> 8
0709: 7E       [95]     		ld 		a,(hl) 						; character the UDG replaced
070A: 36FF     [105]    		ld 		(hl),$FF 					; mark that UDG as now available
                        
070C: 260A     [112]    		ld 		h,SPRLowAddress >> 8 		; get screen address into DE
070E: 5E       [119]    		ld 		e,(hl)
070F: 260B     [126]    		ld 		h,SPRHighAddress >> 8
0711: 56       [133]    		ld 		d,(hl)
                        
0712: 12       [140]    		ld 		(de),a 						; fix up screen
                        
0713: 18DF     [152]    		jr 		_SPRAllocateUndo 			; and see if there are any more to undo
                        		;
                        		; 		Worked, exit with carry clear.
                        		;
0715:                   _SPRAllocateOkay: 							; clear carry flag and exit.
0715: AF       [ 4]     		xor 	a
0716:                   _SPRAllocateExit:
0716: ED7BC207 [20]     		ld 		sp,(_SPRAllocSPTemp)		; get SP back
071A: FDE1     [34]     		pop 	iy 							; restore BC IY
071C: C1       [44]     		pop 	bc
071D: C9       [54]     		ret
                        
                        ; *********************************************************************************************
                        ;
                        ; 		Allocate a single UDG sprite, overwriting (IY), saving the original and copying
                        ; 		the definition. On exit HL points to its graphic definition.
                        ;
                        ; *********************************************************************************************
                        
071E:                   _SPRAllocateOne:
071E: 3AC407   [13]     		ld 		a,(_SPRFirstUDGSprite)		; L = first sprite UDG
0721: 6F       [17]     		ld 		l,a
0722: FD7E00   [36]     		ld 		a,(iy+0) 					; is it a UDG already
0725: BD       [40]     		cp 		l 							; if so, we don't need to do anything.
0726: 3032     [47|52]  		jr 		nc,_SPRAllocateOneExit
                        		;
                        		; 		Look for a free UDG, e.g. one where the stored character is $FF.
                        		;
0728: 2608     [54]     		ld 		h,SPROriginalChar >> 8
072A:                   _SPRAOFind: 								; look for an available UDG.
072A: 7E       [ 7]     		ld 		a,(hl)
072B: FEFF     [14]     		cp 		$FF
072D: 2805     [21|26]  		jr 		z,_SPRAOFound
072F: 2C       [25]     		inc 	l
0730: 20F8     [32|37]  		jr 		nz,_SPRAOFind
0732: 37       [36]     		scf 								; nope, we just can't do this one.
0733: C9       [46]     		ret
                        ;
                        ;  		Found a sprite we can allocate
                        ;
0734:                   _SPRAOFound:
                        		;
                        		; 		Store the character overwritten by the UDG
                        		;
0734: FD7E00   [19]     		ld 		a,(iy+0) 					; this is the original character e.g. what is underneath
0737: 77       [26]     		ld 		(hl),a 						; put in storage slot for original character
                        		;
0738: FDE5     [41]     		push 	iy 							; save the address of that character so we can restore it.
073A: C1       [51]     		pop 	bc 							; when it drops to zero.
073B: 260A     [58]     		ld 		h,SPRLowAddress >> 8
073D: 71       [65]     		ld 		(hl),c
073E: 260B     [72]     		ld 		h,SPRHighAddress >> 8
0740: 70       [79]     		ld 		(hl),b
                        		;
                        		; 		Copy the graphic definition of the original character into the UDG.
                        		;
                        
0741: FD7E00   [98]     		ld 		a,(iy+0) 					; get the original character , e.g. the non UDG
0744: FD7500   [117]    		ld 		(iy+0),l 					; override it.
                        		;
0747: CD6407   [134]    		call 	_SPRCalculateDefinitionAddr ; HL is the graphic of the original character
074A: EB       [138]    		ex 		de,hl
074B: FD7E00   [157]    		ld 		a,(iy+0) 					; HL is the graphic of the UDG
074E: CD6407   [174]    		call 	_SPRCalculateDefinitionAddr
0751: EB       [178]    		ex 		de,hl 						; we want it copied there
0752: 010800   [188]    		ld 		bc,8 						; copy 8 bytes
0755: EDB0     [204|21] 		ldir
                        
0757: FD7E00   [223]    		ld 		a,(iy+0) 					; get the address of the UDG and exit with CC
075A:                   _SPRAllocateOneExit;
075A: CD6407   [17]     		call 	_SPRCalculateDefinitionAddr ; get the definition address in HL
075D: 3AC107   [30]     		ld 		a,(_SPRInitialYOffset) 		; adjust for initial Y offset
0760: B5       [34]     		or 		l
0761: 6F       [38]     		ld 		l,a
0762: AF       [42]     		xor 	a 							; clear carry.
0763: C9       [52]     		ret
                        ;
                        ; 		A is a character #, point HL to CRAM Address
                        ;
0764:                   _SPRCalculateDefinitionAddr:
0764: 6F       [ 4]     		ld 		l,a
0765: 261E     [11]     		ld 		h,$F0/8
0767: 29       [22]     		add 	hl,hl
0768: 29       [33]     		add 	hl,hl
0769: 29       [44]     		add 	hl,hl
076A: C9       [54]     		ret
                        
                        ; *********************************************************************************************
                        ;
                        ;							Adjust usage counter for (IY)
                        ;
                        ; *********************************************************************************************
                        
076B:                   SPRAdjustUsageCounter:
076B: FD6E00   [19]     		ld 		l,(iy+0) 					; point HL to the usage counter
076E: 2609     [26]     		ld 		h,SPRUsageCount >> 8
0770: DDCB077E [46]     		bit 	7,(ix+SPRstatus)			; if drawn status is non-zero we are erasing
0774: 2002     [53|58]  		jr 		nz,_SPRDecrementUsage
0776: 34       [64]     		inc 	(hl)						; increment usage counter and exit
0777: C9       [74]     		ret
                        ;
0778:                   _SPRDecrementUsage:
0778: 35       [11]     		dec 	(hl) 						; one fewer usage
0779: C0       [16|22]  		ret 	nz 							; still in use.
                        		;
                        		; 		Count zero, free up. Could consider delaying this until actually needed?
                        		;
077A: 260A     [23]     		ld 		h,SPRLowAddress >> 8 		; display address in DE
077C: 5E       [30]     		ld 		e,(hl)
077D: 260B     [37]     		ld 		h,SPRHighAddress >> 8
077F: 56       [44]     		ld 		d,(hl)
0780: 2608     [51]     		ld 		h,SPROriginalChar >> 8 		; original character written to DE
0782: 7E       [58]     		ld 		a,(hl)
0783: 12       [65]     		ld 		(de),a
                        
0784: 36FF     [75]     		ld 		(hl),$FF 					; mark the UDG as free again.
0786: C9       [85]     		ret
                        
                        
                        ; *********************************************************************************************
                        ;
                        ;						Flip ADE - byteflip D or DE and swap.
                        ;
                        ; *********************************************************************************************
                        
0787:                   SPRFlipDE:
0787: 7A       [ 4]     		ld 	 	a,d 						; flip D
0788: CD9907   [21]     		call 	_SPRFlipA
078B: 57       [25]     		ld 		d,a
078C: DDCB0646 [45]     		bit 	0,(IX+SPRcontrol)  			; if width 1 exit.
0790: C8       [50|56]  		ret 	z
                        
0791: 6B       [54]     		ld 		l,e 						; save E
0792: 5F       [58]     		ld 		e,a 						; put flipped D into E
0793: 7D       [62]     		ld 		a,l 						; get old E, flip into D
0794: CD9907   [79]     		call 	_SPRFlipA
0797: 57       [83]     		ld 		d,a
0798: C9       [93]     		ret
                        ;
                        ; 		Flip A
                        ;
0799:                   _SPRFlipA:
0799: B7       [ 4]     		or 		a 							; shortcut, reverse zero.
079A: C8       [ 9|15]  		ret 	z
079B: CDA207   [26]     		call 	_SPRFlipLow 				; flip the low nibble
079E: 0F       [30]     		rrca 								; swap halves
079F: 0F       [34]     		rrca
07A0: 0F       [38]     		rrca
07A1: 0F       [42]     		rrca 								; then fall through to flip high nibble.
07A2:                   _SPRFlipLow:
07A2: F5       [11]     		push 	af 							; save original
07A3: E60F     [18]     		and 	$0F 						; access the flip value.
07A5: C6B0     [25]     		add 	_SPRFlipTable & $FF
07A7: 6F       [29]     		ld 		l,a
07A8: 2607     [36]     		ld 		h,_SPRFlipTable >> 8
07AA: F1       [46]     		pop 	af 							; restore original
07AB: E6F0     [53]     		and 	$F0 						; replace lower nibble
07AD: B6       [60]     		or 		(hl)
07AE: C9       [70]     		ret
                        ;
                        ;		One Nibble Reversed.
                        ;
07AF: 00                		.align 	16,0 						; all in one page.
                        
07B0:                   _SPRFlipTable:
07B0: 0008040C          		.db 	0,8,4,12,2,10,6,14
07B4: 020A060E          
07B8: 0109050D          		.db 	1,9,5,13,3,11,7,15
07BC: 030B070F          
                        
                        ; *********************************************************************************************
                        ;
                        ; 									General Data
                        ;
                        ; *********************************************************************************************
                        
07C0:                   _SPRRowCount: 								; down counter for completed rows.
07C0: 00                		.db 	0
                        
07C1:                   _SPRInitialYOffset: 						; the initial vertical offset.
07C1: 00                		.db 	0
                        
07C2:                   _SPRAllocSPTemp: 							; save SP when storing interim results on stack
07C2: 0000              		.dw 	0
                        
07C4:                   _SPRFirstUDGSprite: 						; first sprite available as UDG.
07C4: 80                		.db 	$80
                        
                        ; *********************************************************************************************
                        ;
                        ;		Sprite/UDG Specific Data. Each of these is a 256 byte array aligned
                        ; 		on a page. This is a bit wasteful if you don't have many sprites but quicker.
                        ;
                        ; *********************************************************************************************
                        
07C5: 00000000          		.align 	256,0
07C9: 00...             
                        
0800:                   SPRDataBlock:
                        
                        ;
                        ;		This is the original value stored the UDG replaced. When $FF it means
                        ; 		this UDG is not in use.
                        ;
0800:                   SPROriginalChar:
0800: 00000000          		.ds 	256,0
0804: 00...             
                        ;
                        ;
                        ; 		This is the number of sprites using the given UDG, indexed on zero.
                        ;
0900:                   SPRUsageCount:
0900: 00000000          		.ds 	256,0
0904: 00...             
                        ;
                        ; 		The address of that replaced UDG.
                        ;
0A00:                   SPRLowAddress:
0A00: 00000000          		.ds 	256,0
0A04: 00...             
0B00:                   SPRHighAddress:
0B00: 00000000          		.ds 	256,0
0B04: 00...             
                        
0C00:                   SPRDataBlockEnd:


; +++ segments +++

#CODE          = $0202 =   514,  size = $09FE =  2558

; +++ global symbols +++

DIVDivideMod16          = $0253 =   595          _runtime.asm:145
Div16_Loop1             = $025D =   605          _runtime.asm:153
Div16_Loop2             = $026E =   622          _runtime.asm:167
Div16_NoAdd1            = $0265 =   613          _runtime.asm:159
Div16_NoAdd2            = $0276 =   630          _runtime.asm:173
M8_C_0_c45_             = $038D =   909          _runtime.asm:768 (unused)
M8_C_0_c45__end         = $0395 =   917          _runtime.asm:778 (unused)
M8_C_0_c60_             = $0395 =   917          _runtime.asm:782 (unused)
M8_C_0_c60__end         = $039D =   925          _runtime.asm:788 (unused)
M8_C_0_c61_             = $039D =   925          _runtime.asm:792 (unused)
M8_C_0_c61__end         = $03A5 =   933          _runtime.asm:799 (unused)
M8_C_16_c47_            = $03CA =   970          _runtime.asm:853 (unused)
M8_C_16_c47__end        = $03DA =   986          _runtime.asm:862 (unused)
M8_C_4_c47_             = $03B6 =   950          _runtime.asm:837 (unused)
M8_C_4_c47__end         = $03BE =   958          _runtime.asm:842 (unused)
M8_C_8_c47_             = $03BE =   958          _runtime.asm:844 (unused)
M8_C_8_c47__end         = $03CA =   970          _runtime.asm:851 (unused)
M8_C__c42_              = $02E2 =   738          _runtime.asm:377 (unused)
M8_C__c42__end          = $02E5 =   741          _runtime.asm:379 (unused)
M8_C__c43__c33_         = $0286 =   646          _runtime.asm:212 (unused)
M8_C__c43__c33__end     = $028F =   655          _runtime.asm:222 (unused)
M8_C__c45_              = $0229 =   553          _runtime.asm:57 (unused)
M8_C__c45__end          = $0230 =   560          _runtime.asm:64 (unused)
M8_C__c47_              = $0246 =   582          _runtime.asm:122 (unused)
M8_C__c47__end          = $024D =   589          _runtime.asm:128 (unused)
M8_C__c60_              = $0208 =   520          _runtime.asm:19 (unused)
M8_C__c60__end          = $021D =   541          _runtime.asm:38 (unused)
M8_C__c61_              = $021D =   541          _runtime.asm:42 (unused)
M8_C__c61__end          = $0229 =   553          _runtime.asm:53 (unused)
M8_C_abs                = $03DD =   989          _runtime.asm:871 (unused)
M8_C_abs_end            = $03E3 =   995          _runtime.asm:875 (unused)
M8_C_and                = $0231 =   561          _runtime.asm:74 (unused)
M8_C_and_end            = $0238 =   568          _runtime.asm:82 (unused)
M8_C_boot               = $0202 =   514          _runtime.asm:2 (unused)
M8_C_br_c46_bwd         = $0361 =   865          _runtime.asm:681 (unused)
M8_C_br_c46_bwd_end     = $0365 =   869          _runtime.asm:685 (unused)
M8_C_br_c46_fwd         = $035D =   861          _runtime.asm:675 (unused)
M8_C_br_c46_fwd_end     = $0361 =   865          _runtime.asm:679 (unused)
M8_C_brpos_c46_bwd      = $035A =   858          _runtime.asm:670 (unused)
M8_C_brpos_c46_bwd_end  = $035D =   861          _runtime.asm:673 (unused)
M8_C_brpos_c46_fwd      = $0357 =   855          _runtime.asm:665 (unused)
M8_C_brpos_c46_fwd_end  = $035A =   858          _runtime.asm:668 (unused)
M8_C_brzero_c46_bwd     = $0354 =   852          _runtime.asm:660 (unused)
M8_C_brzero_c46_bwd_end = $0357 =   855          _runtime.asm:663 (unused)
M8_C_brzero_c46_fwd     = $0351 =   849          _runtime.asm:654 (unused)
M8_C_brzero_c46_fwd_end = $0354 =   852          _runtime.asm:657 (unused)
M8_C_copy               = $02B1 =   689          _runtime.asm:296 (unused)
M8_C_copy_end           = $02CE =   718          _runtime.asm:327 (unused)
M8_C_fill               = $02CE =   718          _runtime.asm:331 (unused)
M8_C_fill_end           = $02DE =   734          _runtime.asm:349 (unused)
M8_C_halt               = $02DE =   734          _runtime.asm:353 (unused)
M8_C_halt_end           = $02E1 =   737          _runtime.asm:357 (unused)
M8_C_mod                = $024D =   589          _runtime.asm:132 (unused)
M8_C_mod_end            = $0253 =   595          _runtime.asm:137 (unused)
M8_C_next_c46_handler   = $0337 =   823          _runtime.asm:608 (unused)
M8_C_next_c46_handler_end = $034E =   846          _runtime.asm:633 (unused)
M8_C_not                = $03E6 =   998          _runtime.asm:887 (unused)
M8_C_not_end            = $03ED =  1005          _runtime.asm:895 (unused)
M8_C_or                 = $0238 =   568          _runtime.asm:86 (unused)
M8_C_or_end             = $023F =   575          _runtime.asm:94 (unused)
M8_C_p_c33_             = $029C =   668          _runtime.asm:251 (unused)
M8_C_p_c33__end         = $02A6 =   678          _runtime.asm:261 (unused)
M8_C_p_c64_             = $0293 =   659          _runtime.asm:239 (unused)
M8_C_p_c64__end         = $029C =   668          _runtime.asm:247 (unused)
M8_C_random             = $03FC =  1020          _runtime.asm:917 (unused)
M8_C_spr_c46_control    = $048E =  1166          _runtime.asm:1090 (unused)
M8_C_spr_c46_control_end = $0499 =  1177          _runtime.asm:1096 (unused)
M8_C_spr_c46_hflip      = $0499 =  1177          _runtime.asm:1104 (unused)
M8_C_spr_c46_hflip_end  = $04AE =  1198          _runtime.asm:1115 (unused)
M8_C_spr_c46_hide_c46_all = $0505 =  1285          _runtime.asm:1190 (unused)
M8_C_spr_c46_hide_c46_all_end = $0525 =  1317          _runtime.asm:1211 (unused)
M8_C_spr_c46_image      = $0480 =  1152          _runtime.asm:1075 (unused)
M8_C_spr_c46_image_end  = $048E =  1166          _runtime.asm:1082 (unused)
M8_C_spr_c46_move       = $0467 =  1127          _runtime.asm:1055 (unused)
M8_C_spr_c46_move_end   = $0480 =  1152          _runtime.asm:1067 (unused)
M8_C_spr_c46_reset      = $041D =  1053          _runtime.asm:978 (unused)
M8_C_spr_c46_reset_end  = $0446 =  1094          _runtime.asm:1011 (unused)
M8_C_spr_c46_select     = $0446 =  1094          _runtime.asm:1020 (unused)
M8_C_spr_c46_select_end = $0467 =  1127          _runtime.asm:1047 (unused)
M8_C_spr_c46_update     = $04C9 =  1225          _runtime.asm:1140 (unused)
M8_C_spr_c46_update_end = $0505 =  1285          _runtime.asm:1182 (unused)
M8_C_spr_c46_vflip      = $04AE =  1198          _runtime.asm:1117 (unused)
M8_C_spr_c46_vflip_end  = $04C9 =  1225          _runtime.asm:1132 (unused)
M8_C_sprite_c46_udg_c46_base_c33_ = $0556 =  1366          _runtime.asm:1345 (unused)
M8_C_sprite_c46_udg_c46_base_c33__end = $055D =  1373          _runtime.asm:1352 (unused)
M8_C_string_c46_inline  = $02A7 =   679          _runtime.asm:281 (unused)
M8_C_strlen             = $03ED =  1005          _runtime.asm:899 (unused)
M8_C_strlen_end         = $03FC =  1020          _runtime.asm:913 (unused)
M8_C_xor                = $023F =   575          _runtime.asm:98 (unused)
M8_C_xor_end            = $0246 =   582          _runtime.asm:106 (unused)
M8_M_16_c42_            = $03AB =   939          _runtime.asm:818 (unused)
M8_M_16_c42__end        = $03AF =   943          _runtime.asm:823 (unused)
M8_M_256_c42_           = $03AF =   943          _runtime.asm:825 (unused)
M8_M_256_c42__end       = $03B2 =   946          _runtime.asm:828 (unused)
M8_M_256_c47_           = $03DA =   986          _runtime.asm:864 (unused)
M8_M_256_c47__end       = $03DD =   989          _runtime.asm:867 (unused)
M8_M_2_c42_             = $03A5 =   933          _runtime.asm:803 (unused)
M8_M_2_c42__end         = $03A6 =   934          _runtime.asm:805 (unused)
M8_M_2_c47_             = $03B2 =   946          _runtime.asm:832 (unused)
M8_M_2_c47__end         = $03B6 =   950          _runtime.asm:835 (unused)
M8_M_4_c42_             = $03A6 =   934          _runtime.asm:807 (unused)
M8_M_4_c42__end         = $03A8 =   936          _runtime.asm:810 (unused)
M8_M_8_c42_             = $03A8 =   936          _runtime.asm:812 (unused)
M8_M_8_c42__end         = $03AB =   939          _runtime.asm:816 (unused)
M8_M__c33_              = $027E =   638          _runtime.asm:194 (unused)
M8_M__c33__end          = $0282 =   642          _runtime.asm:199 (unused)
M8_M__c43_              = $0230 =   560          _runtime.asm:68 (unused)
M8_M__c43__c43_         = $038A =   906          _runtime.asm:755 (unused)
M8_M__c43__c43__c43_    = $038B =   907          _runtime.asm:761 (unused)
M8_M__c43__c43__c43__end = $038D =   909          _runtime.asm:764 (unused)
M8_M__c43__c43__end     = $038B =   907          _runtime.asm:757 (unused)
M8_M__c43__end          = $0231 =   561          _runtime.asm:70 (unused)
M8_M__c45__c45_         = $0389 =   905          _runtime.asm:749 (unused)
M8_M__c45__c45__c45_    = $0387 =   903          _runtime.asm:742 (unused)
M8_M__c45__c45__c45__end = $0389 =   905          _runtime.asm:745 (unused)
M8_M__c45__c45__end     = $038A =   906          _runtime.asm:751 (unused)
M8_M__c59_              = $02A6 =   678          _runtime.asm:275 (unused)
M8_M__c59__end          = $02A7 =   679          _runtime.asm:277 (unused)
M8_M__c64_              = $0282 =   642          _runtime.asm:203 (unused)
M8_M__c64__end          = $0286 =   646          _runtime.asm:208 (unused)
M8_M_a_c62_b            = $0300 =   768          _runtime.asm:426 (unused)
M8_M_a_c62_b_end        = $0302 =   770          _runtime.asm:429 (unused)
M8_M_a_c62_c            = $0302 =   770          _runtime.asm:431 (unused)
M8_M_a_c62_c_end        = $0304 =   772          _runtime.asm:434 (unused)
M8_M_a_c62_r            = $031B =   795          _runtime.asm:504 (unused)
M8_M_a_c62_r_end        = $031C =   796          _runtime.asm:506 (unused)
M8_M_a_c62_x            = $030C =   780          _runtime.asm:463 (unused)
M8_M_a_c62_x_end        = $030F =   783          _runtime.asm:466 (unused)
M8_M_a_c62_y            = $0312 =   786          _runtime.asm:473 (unused)
M8_M_a_c62_y_end        = $0315 =   789          _runtime.asm:476 (unused)
M8_M_ab_c62_r           = $0321 =   801          _runtime.asm:535 (unused)
M8_M_ab_c62_r_end       = $0323 =   803          _runtime.asm:538 (unused)
M8_M_abc_c62_r          = $0325 =   805          _runtime.asm:547 (unused)
M8_M_abc_c62_r_end      = $0328 =   808          _runtime.asm:551 (unused)
M8_M_b_c62_a            = $0304 =   772          _runtime.asm:438 (unused)
M8_M_b_c62_a_end        = $0306 =   774          _runtime.asm:441 (unused)
M8_M_b_c62_c            = $0306 =   774          _runtime.asm:443 (unused)
M8_M_b_c62_c_end        = $0308 =   776          _runtime.asm:446 (unused)
M8_M_b_c62_r            = $031D =   797          _runtime.asm:514 (unused)
M8_M_b_c62_r_end        = $031E =   798          _runtime.asm:516 (unused)
M8_M_bc_c62_r           = $032B =   811          _runtime.asm:562 (unused)
M8_M_bc_c62_r_end       = $032D =   813          _runtime.asm:565 (unused)
M8_M_break              = $02E1 =   737          _runtime.asm:361 (unused)
M8_M_break_end          = $02E2 =   738          _runtime.asm:363 (unused)
M8_M_bswap              = $03E3 =   995          _runtime.asm:879 (unused)
M8_M_bswap_end          = $03E6 =   998          _runtime.asm:883 (unused)
M8_M_c_c33_             = $028F =   655          _runtime.asm:226 (unused)
M8_M_c_c33__end         = $0290 =   656          _runtime.asm:228 (unused)
M8_M_c_c62_a            = $0308 =   776          _runtime.asm:450 (unused)
M8_M_c_c62_a_end        = $030A =   778          _runtime.asm:453 (unused)
M8_M_c_c62_b            = $030A =   778          _runtime.asm:455 (unused)
M8_M_c_c62_b_end        = $030C =   780          _runtime.asm:458 (unused)
M8_M_c_c62_r            = $031F =   799          _runtime.asm:524 (unused)
M8_M_c_c62_r_end        = $0320 =   800          _runtime.asm:526 (unused)
M8_M_c_c64_             = $0290 =   656          _runtime.asm:232 (unused)
M8_M_c_c64__end         = $0293 =   659          _runtime.asm:235 (unused)
M8_M_i                  = $034E =   846          _runtime.asm:641 (unused)
M8_M_i_end              = $0351 =   849          _runtime.asm:645 (unused)
M8_M_pop                = $0319 =   793          _runtime.asm:497 (unused)
M8_M_pop_end            = $031B =   795          _runtime.asm:500 (unused)
M8_M_push               = $0318 =   792          _runtime.asm:493 (unused)
M8_M_push_end           = $0319 =   793          _runtime.asm:495 (unused)
M8_M_r_c62_a            = $031C =   796          _runtime.asm:508 (unused)
M8_M_r_c62_a_end        = $031D =   797          _runtime.asm:510 (unused)
M8_M_r_c62_ab           = $0323 =   803          _runtime.asm:540 (unused)
M8_M_r_c62_ab_end       = $0325 =   805          _runtime.asm:543 (unused)
M8_M_r_c62_abc          = $0328 =   808          _runtime.asm:553 (unused)
M8_M_r_c62_abc_end      = $032B =   811          _runtime.asm:557 (unused)
M8_M_r_c62_b            = $031E =   798          _runtime.asm:518 (unused)
M8_M_r_c62_b_end        = $031F =   799          _runtime.asm:520 (unused)
M8_M_r_c62_bc           = $032D =   813          _runtime.asm:567 (unused)
M8_M_r_c62_bc_end       = $032F =   815          _runtime.asm:570 (unused)
M8_M_r_c62_c            = $0320 =   800          _runtime.asm:528 (unused)
M8_M_r_c62_c_end        = $0321 =   801          _runtime.asm:530 (unused)
M8_M_r_c62_x            = $0331 =   817          _runtime.asm:578 (unused)
M8_M_r_c62_x_end        = $0333 =   819          _runtime.asm:580 (unused)
M8_M_r_c62_y            = $0335 =   821          _runtime.asm:588 (unused)
M8_M_r_c62_y_end        = $0337 =   823          _runtime.asm:590 (unused)
M8_M_swap               = $02FF =   767          _runtime.asm:420 (unused)
M8_M_swap_end           = $0300 =   768          _runtime.asm:422 (unused)
M8_M_x_c62_a            = $030F =   783          _runtime.asm:468 (unused)
M8_M_x_c62_a_end        = $0312 =   786          _runtime.asm:471 (unused)
M8_M_x_c62_r            = $032F =   815          _runtime.asm:574 (unused)
M8_M_x_c62_r_end        = $0331 =   817          _runtime.asm:576 (unused)
M8_M_y_c62_a            = $0315 =   789          _runtime.asm:478 (unused)
M8_M_y_c62_a_end        = $0318 =   792          _runtime.asm:481 (unused)
M8_M_y_c62_r            = $0333 =   819          _runtime.asm:584 (unused)
M8_M_y_c62_r_end        = $0335 =   821          _runtime.asm:586 (unused)
MULTMultiply16          = $02E5 =   741          _runtime.asm:387
SPMControl              = $048E =  1166          _runtime.asm:1091 (unused)
SPMCount                = $0527 =  1319          _runtime.asm:1215
SPMCurrent              = $0529 =  1321          _runtime.asm:1217
SPMData                 = $0525 =  1317          _runtime.asm:1213
SPMHFlip                = $0499 =  1177          _runtime.asm:1105 (unused)
SPMHideAll              = $0505 =  1285          _runtime.asm:1192 (unused)
SPMMove                 = $0467 =  1127          _runtime.asm:1056 (unused)
SPMReset                = $041D =  1053          _runtime.asm:980 (unused)
SPMSelect               = $0446 =  1094          _runtime.asm:1022 (unused)
SPMUnused               = $052B =  1323          _runtime.asm:1219
SPMUpdate               = $04C9 =  1225          _runtime.asm:1142 (unused)
SPMVFlip                = $04AE =  1198          _runtime.asm:1118 (unused)
SPRAdjustUsageCounter   = $076B =  1899          _runtime.asm:1796
SPRDataBlock            = $0800 =  2048          _runtime.asm:1898
SPRDataBlockEnd         = $0C00 =  3072          _runtime.asm:1920
SPRFlipDE               = $0787 =  1927          _runtime.asm:1828
SPRHighAddress          = $0B00 =  2816          _runtime.asm:1917
SPRImage                = $0480 =  1152          _runtime.asm:1076 (unused)
SPRInitialise           = $053B =  1339          _runtime.asm:1312
SPRLowAddress           = $0A00 =  2560          _runtime.asm:1915
SPROriginalChar         = $0800 =  2048          _runtime.asm:1904
SPRUsageCount           = $0900 =  2304          _runtime.asm:1910
SPRcontrol              = $0006 =     6          _runtime.asm:1299
SPRgraphics             = $0004 =     4          _runtime.asm:1298
SPRstatus               = $0007 =     7          _runtime.asm:1301
SPRx                    = $0000 =     0          _runtime.asm:1296
SPRy                    = $0002 =     2          _runtime.asm:1297
SpriteSetLowestUDG      = $0556 =  1366          _runtime.asm:1346 (unused)
SpriteXDraw             = $055D =  1373          _runtime.asm:1360
SpriteXErase            = $0564 =  1380          _runtime.asm:1364
SpriteXToggle           = $0569 =  1385          _runtime.asm:1367
_Branch                 = $0375 =   885          _runtime.asm:710
_BranchBackwards        = $0381 =   897          _runtime.asm:724
_BranchForwards         = $037D =   893          _runtime.asm:718 (unused)
_NoBranch               = $0371 =   881          _runtime.asm:702
_SILAdvance             = $02AA =   682          _runtime.asm:285
_SLNExit                = $03FA =  1018          _runtime.asm:910
_SLNLoop                = $03F2 =  1010          _runtime.asm:903
_SPCTExit               = $04C1 =  1217          _runtime.asm:1127
_SPMClear               = $042A =  1066          _runtime.asm:990
_SPMClear2              = $042C =  1068          _runtime.asm:992
_SPMGeneralExit         = $0479 =  1145          _runtime.asm:1063
_SPMHideLoop            = $0515 =  1301          _runtime.asm:1201
_SPMSExit               = $0460 =  1120          _runtime.asm:1041
_SPMSFail               = $045D =  1117          _runtime.asm:1039
_SPMUpdateLoop          = $04D7 =  1239          _runtime.asm:1152
_SPMUpdateOne           = $04EC =  1260          _runtime.asm:1169
_SPRAOFind              = $072A =  1834          _runtime.asm:1732
_SPRAOFound             = $0734 =  1844          _runtime.asm:1743
_SPRARNotErasing        = $06CA =  1738          _runtime.asm:1647
_SPRAdjustGraphicPtr    = $063A =  1594          _runtime.asm:1518
_SPRAllocSPTemp         = $07C2 =  1986          _runtime.asm:1883
_SPRAllocateExit        = $0716 =  1814          _runtime.asm:1709
_SPRAllocateOkay        = $0715 =  1813          _runtime.asm:1707
_SPRAllocateOne         = $071E =  1822          _runtime.asm:1722
_SPRAllocateOneExit     = $075A =  1882          _runtime.asm:1772
_SPRAllocateRow         = $06B3 =  1715          _runtime.asm:1633
_SPRAllocateUndo        = $06F4 =  1780          _runtime.asm:1677
_SPRAuNotRight          = $0628 =  1576          _runtime.asm:1499
_SPRCalcPosition        = $0595 =  1429          _runtime.asm:1402
_SPRCalculateDefinitionAddr = $0764 =  1892          _runtime.asm:1782
_SPRDecrementUsage      = $0778 =  1912          _runtime.asm:1804
_SPRDrawEnd             = $0676 =  1654          _runtime.asm:1572
_SPRExit                = $06A4 =  1700          _runtime.asm:1610
_SPRFetchGraphicPtr     = $062A =  1578          _runtime.asm:1506
_SPRFineHorizontalShift = $064C =  1612          _runtime.asm:1531
_SPRFirstUDGSprite      = $07C4 =  1988          _runtime.asm:1886
_SPRFlipA               = $0799 =  1945          _runtime.asm:1844
_SPRFlipLow             = $07A2 =  1954          _runtime.asm:1852
_SPRFlipTable           = $07B0 =  1968          _runtime.asm:1867
_SPRHaveGraphicData     = $063A =  1594          _runtime.asm:1516
_SPRInitialYOffset      = $07C1 =  1985          _runtime.asm:1880
_SPRLeftUDGPosition     = $065F =  1631          _runtime.asm:1556
_SPRMiddleUDGPosition   = $0664 =  1636          _runtime.asm:1560
_SPRNextRowUDG          = $062A =  1578          _runtime.asm:1504
_SPRNoHFlip             = $064A =  1610          _runtime.asm:1528
_SPRRangeFail           = $0592 =  1426          _runtime.asm:1397
_SPRRightUDGPosition    = $0670 =  1648          _runtime.asm:1567
_SPRRowCount            = $07C0 =  1984          _runtime.asm:1877
_SPRSGANotDoubleHeight  = $05FA =  1530          _runtime.asm:1469
_SPRSGANotDoubleWidth   = $05E8 =  1512          _runtime.asm:1457
_SPRSGANotVFlip         = $0606 =  1542          _runtime.asm:1479
_SPRSingleHeight        = $05D5 =  1493          _runtime.asm:1446
_SPRStartNextCharacterRow = $060D =  1549          _runtime.asm:1485
_SPRUsageReset          = $054E =  1358          _runtime.asm:1331
_SPRZeroBlock           = $0540 =  1344          _runtime.asm:1319
__Core__Mult_Loop       = $02EC =   748          _runtime.asm:393
__Core__Mult_Shift      = $02F1 =   753          _runtime.asm:397
__copy_exit             = $02CA =   714          _runtime.asm:322
__copy_gt_count         = $02C7 =   711          _runtime.asm:319
__fill_loop             = $02D3 =   723          _runtime.asm:338
__halt_loop             = $02DE =   734          _runtime.asm:354
__less_returnc          = $0216 =   534          _runtime.asm:32
__less_samesign         = $0211 =   529          _runtime.asm:27
__negate                = $038D =   909          _runtime.asm:769
_end                    = $0C00 =  3072          :1 (unused)
_posBranch              = $036C =   876          _runtime.asm:695
_randomSeed1            = $0419 =  1049          _runtime.asm:939
_randomSeed2            = $041B =  1051          _runtime.asm:941
_size                   = $09FE =  2558          :1 (unused)
_tend_loop              = $0342 =   834          _runtime.asm:621
_zeroBranch             = $0365 =   869          _runtime.asm:688


total time: 0.0101 sec.
no errors
