              	; --------------------------------------
              	; zasm: assemble "_mgr.asm"
              	; date: 2021-11-02 16:15:21
              	; --------------------------------------


              	
0202:         			org 	$202
              	
              	;
              	;	 	Defining SPRLowSprite sets the lowest UDG used by sprites. This is a constant
              	; 		so if this is $A0, then $00-$9F are background, and $A0-$FF are used for sprites.
              	;
0080:         	SPRLowSprite = $80 								
0008:         	SpriteCount = 8
              	
0202: C3000A  			jp 		start
              			.include 	"spritemanager.asm"
              	; *********************************************************************************************
              	; *********************************************************************************************
              	;
              	;		Name:		spritemanager.asm
              	;		Purpose:	Sprite Manager
              	;		Created:	1st November 2021
              	;		Author:		Paul Robson (paul@robsons.org.uk)
              	;
              	; *********************************************************************************************
              	; *********************************************************************************************
              	;
              	;		Sprite Record:
              	;
              	; 			Current Data: (as per xsprite.asm)
              	;				0..6 	X:2 	Y:2 	Graphics:2 	Control:1
              	;				7 		Status byte
              	;			To Copy data:
              	;				8..14 	X:2 	Y:2 	Graphics:2 	Control:1
              	;				15 		Change flag
              	;
              	;		When being updated, if the change flag is set, then the sprite is removed, then data 
              	;		(8-14) is copied to (0-6), then the sprite redrawn
              	;
              	;		The option also exists to erase all sprites ; the point of such being that one can update
              	;		the background. This sets all the change flags so the sprites are redrawn on the next sync.
              	;
              	; *********************************************************************************************
              	;
              	;
              	;			Reset Sprite Manager. HL points to data block, DE is number of sprites
              	;
              	;
              	; *********************************************************************************************
              	
              	;; [CALL] 	SPR.RESET
              	
0205:         	SPMReset:
0205: F5      			push 	af
0206: C5      			push 	bc
0207: D5      			push 	de
0208: E5      			push 	hl
0209: 220D03  			ld 		(SPMData),hl 				; save count and address
020C: 7B      			ld 		a,e
020D: 320F03  			ld 		(SPMCount),a
0210: 87      			add 	a,a 						; double, as we clear it twice (2 x 8 byte blocks)
0211: 47      			ld 		b,a
0212:         	_SPMClear:
0212: 0E06    			ld 		c,6 						; write out 6 $FFs to position and graphic
0214:         	_SPMClear2:		
0214: 36FF    			ld 		(hl),$FF
0216: 23      			inc 	hl
0217: 0D      			dec 	c
0218: 20FA    			jr 		nz,_SPMClear2
021A: 71      			ld 		(hl),c 						; followed by 2 zeros (control and status/change byte)		
021B: 23      			inc 	hl
021C: 71      			ld 		(hl),c
021D: 23      			inc 	hl
021E: 10F2    			djnz 	_SPMClear
0220: 211303  			ld 		hl,SPMUnused 				; no current selection
0223: 221103  			ld 		(SPMCurrent),hl
0226: CD2303  			call 	SPRInitialise 				; erase the sprite control records.
0229: E1      			pop 	hl
022A: D1      			pop 	de
022B: C1      			pop 	bc
022C: F1      			pop 	af
022D: C9      			ret
              	
              	;; [END]
              	
              	; *********************************************************************************************
              	;
              	;		Sprite functions/words. A sprite is selected via SPMSelect and then moved, graphics 
              	; 		set etc. by other functions. SPMUpdate updates all sprites. Parameters at L/HL then DE.
              	;
              	; *********************************************************************************************
              	
              	;; [CALL] 	SPR.SELECT
              	
022E:         	SPMSelect:
022E: F5      			push 	af
022F: C5      			push 	bc
0230: E5      			push 	hl
0231: 3A0F03  			ld		a,(SPMCount)
0234: BD      			cp 		l 							; compare max vs selected.
0235: 280E    			jr 		z,_SPMSFail 				; must be >
0237: FA4502  			jp 		m,_SPMSFail
              	
023A: 29      			add 	hl,hl 						; x 16
023B: 29      			add 	hl,hl
023C: 29      			add 	hl,hl
023D: 29      			add 	hl,hl
023E: ED5B0D03			ld 		de,(SPMData) 				; add base address
0242: 19      			add 	hl,de
0243: 1803    			jr 		_SPMSExit 					; write and exit
              	
0245:         	_SPMSFail:
0245: 211303  			ld 		hl,SPMUnused
0248:         	_SPMSExit:
0248: 221103  			ld 		(SPMCurrent),hl
024B: E1      			pop 	hl
024C: D1      			pop 	de
024D: F1      			pop 	af
024E: C9      			ret
              	;; [END]
              	
              	; *********************************************************************************************
              	;
              	;										X Y SPR.MOVE
              	;
              	; *********************************************************************************************
              	
              	;; [CALL] SPR.MOVE
024F:         	SPMMove:
024F: DDE5    			push 	ix
0251: DD2A1103			ld 		ix,(SPMCurrent)
0255: DD7308  			ld 		(ix+8),e 					; write X
0258: DD7209  			ld 		(ix+9),d
025B: DD750A  			ld 		(ix+10),l 					; write Y
025E: DD740B  			ld 		(ix+11),h
0261:         	_SPMGeneralExit:
0261: DDCB0FFE			set 	7,(ix+15)
0265: DDE1    			pop 	ix
0267: C9      			ret
              	;;[END]
              	
              	; *********************************************************************************************
              	;
              	;									   GDATA SPR.IMAGE
              	;
              	; *********************************************************************************************
              	
              	;; [CALL] SPR.IMAGE
0268:         	SPRImage:
0268: DDE5    			push 	ix
026A: DD2A1103			ld 		ix,(SPMCurrent)
026E: DD750C  			ld 		(ix+12),l
0271: DD740D  			ld 		(ix+13),h
0274: 18EB    			jr 		_SPMGeneralExit
              	;; [END]
              	
              	; *********************************************************************************************
              	;
              	;									   CBYTE SPR.CONTROL
              	;
              	; *********************************************************************************************
              	
              	;; [CALL] SPR.CONTROL
0276:         	SPMControl:
0276: DDE5    			push 	ix
0278: DD2A1103			ld 		ix,(SPMCurrent)
027C: DD750E  			ld 		(ix+14),l
027F: 18E0    			jr 		_SPMGeneralExit
              	;; [END]
              	
              	; *********************************************************************************************
              	;
              	;							   <bool> SPR.VFLIP / HFLIP
              	;
              	; *********************************************************************************************
              	
              	;; [CALL] SPR.HFLIP
0281:         	SPMHFlip:
0281: F5      			push 	af
0282: DDE5    			push 	ix
0284: DD2A1103			ld 		ix,(SPMCurrent)
0288: DDCB0EAE			res 	5,(ix+14)
028C: 7D      			ld 		a,l
028D: B4      			or 		h
028E: 2819    			jr 		z,_SPCTExit
0290: DDCB0EEE			set 	5,(ix+14)
0294: 1813    			jr 		_SPCTExit
              	;; [END]
              	
              	;; [CALL] SPR.VFLIP
0296:         	SPMVFlip:
0296: F5      			push 	af
0297: DDE5    			push 	ix
0299: DD2A1103			ld 		ix,(SPMCurrent)
029D: DDCB0EB6			res 	6,(ix+14)
02A1: 7D      			ld 		a,l
02A2: B4      			or 		h
02A3: 2804    			jr 		z,_SPCTExit
02A5: DDCB0EFE			set 	7,(ix+14)
02A9:         	_SPCTExit:
02A9: DDCB0FFE			set 	7,(ix+15)
02AD: DDE1    			pop 	ix
02AF: F1      			pop 	af
02B0: C9      			ret
              	;; [END]
              	
              	; *********************************************************************************************
              	;
              	;										Update all sprites
              	;
              	; *********************************************************************************************
              	
              	;; [CALL] 	SPR.UPDATE
              	
02B1:         	SPMUpdate:
02B1: F5      			push 	af
02B2: C5      			push 	bc
02B3: D5      			push 	de
02B4: E5      			push 	hl
02B5: DDE5    			push 	ix
              	
02B7: 3A0F03  			ld 		a,(SPMCount)
02BA: 47      			ld 		b,a
02BB: DD2A0D03			ld 		ix,(SPMData)
02BF:         	_SPMUpdateLoop:
02BF: DD7E0F  			ld 		a,(ix+15) 					; check redraw flag
02C2: B7      			or 		a
02C3: C4D402  			call 	nz,_SPMUpdateOne 			; if non zero update this one
02C6: 111000  			ld 		de,16
02C9: DD19    			add 	ix,de
02CB: 10F2    			djnz 	_SPMUpdateLoop
              	
02CD: DDE1    			pop 	ix
02CF: E1      			pop 	hl
02D0: C1      			pop 	bc
02D1: D1      			pop 	de
02D2: F1      			pop 	af
02D3: C9      			ret		
              	;
              	;		Updates one sprite from new data if redraw flag found set.
              	;
02D4:         	_SPMUpdateOne:
02D4: C5      			push 	bc
02D5: DD360F00			ld 		(ix+15),0 					; clear the redraw flag.
02D9: CD4C03  			call 	SpriteXErase 				; erase sprite
02DC: DDE5    			push 	ix 							; copy target address in DE
02DE: D1      			pop 	de
02DF: 210800  			ld 		hl,8
02E2: 19      			add 	hl,de 						; target DE, source HL
02E3: 010700  			ld 		bc,7 						; copy 7 bytes over
02E6: EDB0    			ldir 
02E8: CD4503  			call 	SpriteXDraw 				; redraw sprite
02EB: C1      			pop 	bc
02EC: C9      			ret
              	;; [END]
              	
              	; *********************************************************************************************
              	;
              	;							Hide all sprites (to change background)
              	;
              	; *********************************************************************************************
              	
              	;; [CALL] 	SPR.HIDE.ALL
              	
02ED:         	SPMHideAll:
02ED: F5      			push 	af
02EE: C5      			push 	bc
02EF: D5      			push 	de
02F0: DDE5    			push 	ix
02F2: 3A0F03  			ld 	 	a,(SPMCount)
02F5: 47      			ld 		b,a
02F6: DD2A0D03			ld 		ix,(SPMData)
02FA: 111000  			ld 		de,16
02FD:         	_SPMHideLoop:
02FD: CD4C03  			call 	SpriteXErase 				; remove sprite
0300: DDCB0FFE			set 	7,(ix+15) 					; force redraw next update
0304: DD19    			add 	ix,de
0306: 10F5    			djnz 	_SPMHideLoop
0308: E1      			pop 	hl
0309: C1      			pop 	bc
030A: D1      			pop 	de
030B: F1      			pop 	af
030C: C9      			ret		
              	;; [END]
              	
030D:         	SPMData: 									; address of sprite
030D: 0000    			.dw 	0
030F:         	SPMCount: 									; number of sprites
030F: 0000    			.dw 	0
0311:         	SPMCurrent: 								; currently selected sprite (may point to unused junk space)
0311: 0000    			.dw 	0		
0313:         	SPMUnused: 									; space for junk writes.
0313: 00000000			.ds 	16,0
0317: 00...   	
              			.include 	"xsprite.asm"
              	; *********************************************************************************************
              	; *********************************************************************************************
              	;
              	;		Name:		xsprite.asm
              	;		Purpose:	XOR Sprite Drawer
              	;		Created:	29th October 2021
              	;		Author:		Paul Robson (paul@robsons.org.uk)
              	;
              	; *********************************************************************************************
              	; *********************************************************************************************
              	
              	; *********************************************************************************************
              	;
              	;		This is an XOR drawing sprite system. This is useful because the draw is self
              	;		cancelling, and this means you don't have to repaint multiple sprites to restore
              	; 		the display state. The downside is that it doesn't work well on collisions or 
              	; 		especially backgrounds.
              	;
              	;		The original design, which was a simpler draw all/erase all design, was binned 
              	;		because I thought on real hardware it would create too much flash on the display.
              	;
              	;		I don't yet have a real machine so can't evaluate this in practice, as the emulator
              	; 		snapshots the display at 60Mhz, so the effects of endlessly messing with the 
              	;		CRAM and VRAM is largely hidden.
              	;
              	;		At 4Mhz it does about 330 draws/erases a second on a 16x16 sprites, twice as fast on
              	;		8 pixel high sprites.
              	;
              	;		It eats UDGs - a single 16x16 sprite needs 9 UDGs if it doesn't overlap with another.
              	;
              	; *********************************************************************************************
              	;
              	;		How it works. 
              	;
              	;			When drawing a sprite, it will try to allocate UDGs from its pool for the space
              	; 			to draw the sprite. When drawing or erasing it then XORs the bit patterns into this
              	; 			as far as it can. When erased, UDGs are returned to the pool if no longer required.
              	;
              	; *********************************************************************************************
              	;
              	;		Offsets from IX.
              	;
              	;			+0,+1 		Horizontal position (0..319)
              	;			+2,+3 		Vertical position (0..239)
              	;			+4,+5 		Pointer to graphic image data.
              	;							Width : 8  	one byte per row
              	;							Width : 16 	two bytes per row left-right order
              	;			+6 			Control
              	;							Bit 7: 		Set if sprite disabled
              	;							Bit 6: 		Vertical flip
              	;							Bit 5:		Horizontal flip
              	;							Bit 4..2:	0
              	;							Bit 1:		Double width
              	;							Bit 0: 		Double height
              	;			+7 			Status
              	;							Bit 7:		Set when drawn on screen
              	;							Bit 6..0:	0
              	;
              	;			Changes should only be made when the sprite is not drawn, otherwise chaos
              	;			will ensue.
              	;
              	;			Draws will not fail, however, they may not visually work either. If there are more
              	;			UDGs required than available graphics will not be drawn, or possibly drawn
              	;			erratically. It is advised to minimise the number of sprites both for CPU time
              	;			and UDG usage. 
              	;
              	;			Use specific UDGs for static/slow objects. For (say) Pacman the only sprites should
              	;			be the player character and chasing ghosts.
              	;
              	; *********************************************************************************************
              	;
              	;								  Sprite Record entries
              	;
              	; *********************************************************************************************
              	
0000:         	SPRx 	= 0 								; horizontal position, pixels
0002:         	SPRy 	= 2 								; vertical position, pixels
0004:         	SPRgraphics = 4 							; bitmap data
0006:         	SPRcontrol = 6 								; 0:width 1:height 5:HFlip 6:VFlip 7:hidden
              												; (others are zero)
0007:         	SPRstatus = 7 								; 7:currently drawn
              	
              	; *********************************************************************************************
              	;
              	; 								Initialise the sprite system.
              	;
              	; 	At this point sprite records should all have their "currently drawn" bit clear, it will
              	; 	get very confused otherwise.
              	;
              	; *********************************************************************************************
              	
0323:         	SPRInitialise:
0323: F5      			push 	af
0324: E5      			push 	hl
              			;
              			; 		Clear the main data area.
              			;
0325: 210006  			ld 		hl,SPRDataBlock 			
0328:         	_SPRZeroBlock:
0328: 3600    			ld 		(hl),$00
032A: 23      			inc 	hl
032B: 7C      			ld 		a,h
032C: FE0A    			cp 		SPRDataBlockEnd >> 8
032E: 20F8    			jr 		nz,_SPRZeroBlock
              			;
              			; 		Set all possible original characters to $FF, indicating they are available.
              			;		
0330: 3AB405  			ld 		a,(_SPRFirstUDGSprite)
0333: 6F      			ld 		l,a
0334: 2606    			ld 		h,SPROriginalChar >> 8
0336:         	_SPRUsageReset:			 					
0336: 36FF    			ld 		(hl),$FF
0338: 2C      			inc 	l
0339: 20FB    			jr 		nz,_SPRUsageReset
033B: E1      			pop 	hl
033C: F1      			pop 	af
033D: C9      			ret
              	
              	; *********************************************************************************************
              	;
              	; 									Allocate lowest UDG
              	;
              	; *********************************************************************************************
              	
              	;; [CALL] SPRITE.UDG.BASE!
033E:         	SpriteSetLowestUDG:
033E: F5      			push 	af
033F: 7D      			ld 		a,l
0340: 32B405  			ld 		(_SPRFirstUDGSprite),a
0343: F1      			pop 	af
0344: C9      			ret
              	;; [END]
              	
              	; *********************************************************************************************
              	;
              	;						Draw, or Erase, the sprite whose raw data is at IX
              	;
              	; *********************************************************************************************
              	
0345:         	SpriteXDraw: 								; draw only
0345: DDCB077E			bit 	7,(ix+SPRstatus)
0349: C0      			ret 	nz
034A: 1805    			jr 		SpriteXToggle
034C:         	SpriteXErase:								; erase only
034C: DDCB077E			bit 	7,(ix+SPRstatus)
0350: C8      			ret 	z
0351:         	SpriteXToggle:								; flip state
0351: F5      			push 	af 							; save registers 							
0352: C5      			push 	bc
0353: D5      			push 	de
0354: E5      			push 	hl
0355: FDE5    			push 	iy
              			;
              			; 		Check actually visible
              			;
0357: DDCB067E			bit 	7,(ix+SPRcontrol)
035B: C28C04  			jp 		nz,_SPRExit
              			;
              			; 		Check range.
              			;
035E: DD7E01  			ld 		a,(ix+SPRx+1) 				; MSB of X must be 0 or 1
0361: 47      			ld 		b,a 						; save in B
0362: E6FE    			and 	$FE
0364: DDB603  			or 		a,(ix+SPRy+1) 				; MSB of Y must be zero.
0367: 2011    			jr 		nz,_SPRRangeFail
              			;
0369: DD7E02  			ld 		a,(ix+SPRy) 				; check Y < 240
036C: FEF0    			cp 		8*30
036E: 300A    			jr 		nc,_SPRRangeFail
              			;
0370: 05      			dec 	b 							; if MSB X was 1, now zero
0371: 200A    			jr 		nz,_SPRCalcPosition 
              			;
0373: DD7E00  			ld 		a,(ix+SPRx) 				; X.MSB was 1, so must be X.LSB < 64
0376: FE40    			cp 		64
0378: 3803    			jr 		c,_SPRCalcPosition
037A:         	_SPRRangeFail:
037A: C38C04  			jp 		_SPRExit 	
              			;
              			;		Calculate position in IY
              			;
037D:         	_SPRCalcPosition:		
037D: 2600    			ld 		h,0							; Y position in HL, with lower 3 bits masked, so already x 8
037F: DD7E02  			ld 		a,(ix+SPRy)
0382: E6F8    			and 	$F8
0384: 6F      			ld 		l,a
0385: 54      			ld 		d,h 						; DE = Y x 8
0386: 5D      			ld 		e,l
0387: 29      			add 	hl,hl 						; HL = Y x 32
0388: 29      			add 	hl,hl
0389: 19      			add 	hl,de 						; HL = Y x 40
038A: FD2100F8			ld 		iy,$F800 					; IY = $F800 + Y x 40
038E: EB      			ex 		de,hl
038F: FD19    			add 	iy,de
              	
0391: DD5E00  			ld 		e,(ix+SPRx)					; DE = X position
0394: DD5601  			ld 		d,(ix+SPRx+1)
0397: CB3A    			srl 	d 							; / 8 (after first in range 0-255 hence SRL E)
0399: CB1B    			rr 		e
039B: CB3B    			srl 	e
039D: CB3B    			srl 	e
039F: 1600    			ld 		d,0 						; add to screen position.
03A1: FD19    			add 	iy,de
              			;
              			; 		Calculate and patch the fine horizontal shift jump which adjusts the 
              			; 		number of 24 bit left shifts we do to the graphics data.
              			;
03A3: DD7E00  			ld 		a,(ix+SPRx)
03A6: E607    			and 	7
03A8: 87      			add 	a,a
03A9: 323504  			ld 		(_SPRFineHorizontalShift+1),a 
              			;
              			; 		Calculate the horizontal offset which makes it start drawing part way through a UDG
              			;
03AC: DD7E02  			ld 		a,(ix+SPRy)
03AF: E607    			and 	7
03B1: 32B105  			ld 		(_SPRInitialYOffset),a
              			;
              			; 		Calculate the row count from bit 1 of the control byte
              			; 		(the number of vertical pixels down)
              			;
03B4: 3E08    			ld 		a,8
03B6: DDCB064E			bit 	1,(ix+SPRcontrol)
03BA: 2801    			jr 		z,_SPRSingleHeight
03BC: 87      			add 	a,a
03BD:         	_SPRSingleHeight:		
03BD: 32B005  			ld 		(_SPRRowCount),a
              			;
              			;		Set the sprite graphic address and incrementer.
              			;
03C0: DD6E04  			ld 		l,(ix+SPRgraphics) 			; data address
03C3: DD6605  			ld 		h,(ix+SPRgraphics+1) 		
03C6: 110100  			ld 		de,1 						; increment/decrement
03C9: DDCB0646			bit 	0,(ix+SPRcontrol)
03CD: 2801    			jr 		z,_SPRSGANotDoubleWidth
03CF: 13      			inc 	de 							; 2 if double width
03D0:         	_SPRSGANotDoubleWidth:
03D0: DDCB0676			bit 	6,(ix+SPRcontrol) 			; check for vertical flip.
03D4: 2818    			jr 		z,_SPRSGANotVFlip
              			;
03D6: EB      			ex 		de,hl 						; DE = address, HL = increment x 8
03D7: E5      			push 	hl
03D8: 29      			add 	hl,hl
03D9: 29      			add 	hl,hl
03DA: 29      			add 	hl,hl
03DB: DDCB064E			bit 	1,(ix+SPRcontrol) 			; x 16 if double height
03DF: 2801    			jr 		z,_SPRSGANotDoubleHeight
03E1: 29      			add 	hl,hl		
03E2:         	_SPRSGANotDoubleHeight:
03E2: 19      			add 	hl,de 						; add 8/16 x increment to start
03E3: C1      			pop 	bc 							; original increment -> BC
03E4: E5      			push 	hl 							; save new start on stack.
03E5: 210000  			ld 		hl,0 						; HL = - increment
03E8: AF      			xor 	a
03E9: ED42    			sbc 	hl,bc
03EB: D1      			pop 	de 							; DE = new start off stack
03EC: EB      			ex 		de,hl 						; swap them back so HL = address, DE = -increment
03ED: 19      			add 	hl,de 						; points HL to the last sprite entry.
03EE:         	_SPRSGANotVFlip:
03EE: 221304  			ld 		(_SPRFetchGraphicPtr+1),hl 	; write out start address in HL and incrementer in DE.		
03F1: ED532304			ld 		(_SPRAdjustGraphicPtr+1),de
              			;
              			; 		Try to allocate UDGs for the current row at IY, 2 or 3 UDGs.
              			;
03F5:         	_SPRStartNextCharacterRow:
03F5: CD9B04  			call 	_SPRAllocateRow 			; try to allocate the whole row.
03F8: DA8C04  			jp 		c,_SPRExit					; it didn't work, so we abandon drawing here.
              			;
              			; 		Adjust the usage counters.
              			;
03FB: FDE5    			push 	iy
03FD: CD5305  			call 	SPRAdjustUsageCounter
0400: FD23    			inc 	iy
0402: CD5305  			call 	SPRAdjustUsageCounter
0405: DDCB0646			bit 	0,(ix+SPRcontrol)
0409: 2805    			jr 		z,_SPRAuNotRight
040B: FD23    			inc 	iy
040D: CD5305  			call 	SPRAdjustUsageCounter
0410:         	_SPRAuNotRight:
0410: FDE1    			pop 	iy		
              			;
              			;		Get the graphics for the next *pixel* line. into ADE
              			;
0412:         	_SPRNextRowUDG:		
              			;
0412:         	_SPRFetchGraphicPtr:
0412: 210000  			ld 		hl,$0000
0415: 1E00    			ld 		e,0							; DE = $00:(HL)
0417: 56      			ld 		d,(hl)
0418: DDCB0646			bit 	0,(ix+SPRcontrol) 			; is the width 1 ?
041C: 2804    			jr 		z,_SPRHaveGraphicData
041E: 23      			inc 	hl
041F: 5A      			ld 		e,d  						; DE = (HL+1):(HL)		
0420: 56      			ld 		d,(hl)
0421: 2B      			dec 	hl		
0422:         	_SPRHaveGraphicData:		
              			;
0422:         	_SPRAdjustGraphicPtr:
0422: 010000  			ld 		bc,$0000 					; this is changed to account for size and
0425: 09      			add 	hl,bc 						; direction.
0426: 221304  			ld 		(_SPRFetchGraphicPtr+1),hl		
              			;
              			; 		Check for Horizontal Flip
              			;
0429: DDCB066E			bit 	5,(ix+SPRcontrol)			; if HFlip bit set
042D: 2803    			jr 		z,_SPRNoHFlip
042F: CD6F05  			call 	SPRFlipDE 					; Flip DE
0432:         	_SPRNoHFlip:		
0432: AF      			xor 	a 							; ADE contains 24 bit graphic data.
0433: EB      			ex 		de,hl 						; we put it in AHL
0434:         	_SPRFineHorizontalShift:		
0434: 1800    			jr 		$+2 						; this is altered to do the fine horizontal shift
0436: 29      			add 	hl,hl
0437: 8F      			adc 	a,a
0438: 29      			add 	hl,hl
0439: 8F      			adc 	a,a
043A: 29      			add 	hl,hl
043B: 8F      			adc 	a,a
043C: 29      			add 	hl,hl
043D: 8F      			adc 	a,a
043E: 29      			add 	hl,hl
043F: 8F      			adc 	a,a
0440: 29      			add 	hl,hl
0441: 8F      			adc 	a,a
0442: 29      			add 	hl,hl
0443: 8F      			adc 	a,a
0444: 29      			add 	hl,hl
0445: 8F      			adc 	a,a
0446: EB      			ex 		de,hl 						; put it back in ADE
              			;
              			;		Now XOR the data with the previously calculated addresses. 
              			;		If (ix+5)[0] is clear then don't do the third one, it's an 8x8 sprite
              			;
              			;		These addresses (the ld hl,xxxx ones) are modified in situ.
              			;
0447:         	_SPRLeftUDGPosition:		
0447: 2108F6  			ld 		hl,$F000+$C1*8
044A: AE      			xor 	(hl)
044B: 77      			ld 		(hl),a
044C:         	_SPRMiddleUDGPosition:		
044C: 2110F6  			ld 		hl,$F000+$C2*8
044F: 7A      			ld 		a,d
0450: AE      			xor 	(hl)
0451: 77      			ld 		(hl),a
0452: DDCB0646			bit 	0,(ix+SPRcontrol) 					; if width 1, skip the last draw
0456: 2806    			jr 		z,_SPRDrawEnd
0458:         	_SPRRightUDGPosition:		
0458: 2118F6  			ld 		hl,$F000+$C3*8
045B: 7B      			ld 		a,e
045C: AE      			xor 	(hl)
045D: 77      			ld 		(hl),a
045E:         	_SPRDrawEnd:
              			;
              			; 		Check if we have done all the rows
              			;
045E: 21B005  			ld 		hl,_SPRRowCount 
0461: 35      			dec 	(hl)
0462: 2828    			jr 		z,_SPRExit
              			;
              			; 		Now go to the next line down. Initially this just advances the vertical offset
              			;		in the UDG pointers
              			;
0464: 214D04  			ld 		hl,_SPRMiddleUDGPosition+1
0467: 34      			inc 	(hl)
0468: 215904  			ld 		hl,_SPRRightUDGPosition+1 	; not guaranteed initialised.
046B: 34      			inc 	(hl)
046C: 214804  			ld 		hl,_SPRLeftUDGPosition+1
046F: 34      			inc 	(hl)
              			;
0470: 7E      			ld 		a,(hl) 						; check crossed 8 byte boundary
0471: E607    			and 	7
0473: 209D    			jr 		nz,_SPRNextRowUDG 			; if not complete it.
              	
0475: AF      			xor 	a 							; clear the initial offset
0476: 32B105  			ld 		(_SPRInitialYOffset),a
              	
              	
0479: 112800  			ld 		de,40 						; advance down one row.
047C: FD19    			add 	iy,de 
              	
047E: 11B0FC  			ld 		de,$F800+40*30 				; the end of the physical display
0481: FDE5    			push 	iy
0483: E1      			pop 	hl
0484: 37      			scf
0485: ED52    			sbc 	hl,de
0487: 3003    			jr 		nc,_SPRExit 				; past the bottom,exit.
              	
0489: C3F503  			jp 		_SPRStartNextCharacterRow 	; do the next character row.
              	
048C:         	_SPRExit:
048C: DD7E07  			ld 		a,(ix+SPRstatus) 			; toggle the drawn status bit
048F: EE80    			xor 	$80
0491: DD7707  			ld 		(ix+SPRstatus),a 		
              	
0494: FDE1    			pop 	iy 							; restore registers
0496: E1      			pop 	hl
0497: D1      			pop 	de
0498: C1      			pop 	bc
0499: F1      			pop 	af
049A: C9      			ret
              	
              	; *********************************************************************************************
              	;
              	;		Allocate 0-3 UDGs to the character space according to need and availability.
              	; 		Fail with CS if can't.
              	;		If possible,
              	;			all new UDGs should have the copied graphic from the background and the
              	;			old background set up.
              	;			the UDGs should replace the graphics in IY.
              	;
              	; *********************************************************************************************
              	
049B:         	_SPRAllocateRow:
049B: C5      			push 	bc 							; save BC.
049C: FDE5    			push 	iy 							; save IY
049E: ED73B205			ld 		(_SPRAllocSPTemp),sp		; save SP as we are using it for temp.
              	
04A2: DDCB077E			bit 	7,(ix+SPRstatus) 			; are we erasing ?
04A6: 280A    			jr 		z,_SPRARNotErasing
              	
04A8: 3AB405  			ld 		a,(_SPRFirstUDGSprite)		; B = first sprite useable
04AB: 47      			ld 		b,a
04AC: FD7E00  			ld 		a,(iy+0) 					; if erasing, check if row is drawn on UDGs
04AF: B8      			cp 		b
04B0: 384C    			jr 		c,_SPRAllocateExit 			; and if so don't allocate the row, exit.
              	
04B2:         	_SPRARNotErasing:		
04B2: 210000  			ld 		hl,$0000 					; we save all the allocated so far on the stack
04B5: E5      			push 	hl 		 					; this is the end marker.					
              			;
              			; 		Do 2 or 3. For each overwrite the XOR code addresses and save
              			;		it on the stack. If it fails, then unwind everything.
              			;
04B6: CD0605  			call 	_SPRAllocateOne 			; do (IY)
04B9: 3821    			jr 		c,_SPRAllocateUndo 			; if done, then Undo.
04BB: 224804  			ld 		(_SPRLeftUDGPosition+1),hl 	; overwrite the code.
04BE: E5      			push 	hl
              	
04BF: FD23    			inc 	iy		
04C1: CD0605  			call 	_SPRAllocateOne 			; do (IY+1)
04C4: 3816    			jr 		c,_SPRAllocateUndo 			; if done, then Undo.
04C6: 224D04  			ld 		(_SPRMiddleUDGPosition+1),hl ; overwrite the code.
04C9: E5      			push 	hl
              	
04CA: DDCB0646			bit 	0,(ix+SPRcontrol) 			; if 8 width then we are done.
04CE: 282D    			jr 		z,_SPRAllocateOkay 
              	
04D0: FD23    			inc 	iy		
04D2: CD0605  			call 	_SPRAllocateOne 			; do (IY+2)
04D5: 3805    			jr 		c,_SPRAllocateUndo 			; if done, then Undo.
04D7: 225904  			ld 		(_SPRRightUDGPosition+1),hl ; overwrite the code.
04DA: 1821    			jr 		_SPRAllocateOkay 
              			;
              			; 		Failed, so pop the saved UDG addresses on the stack and reset
              			;	 	as if we hadn't allocated it. We haven't bumped the usage count yet.
              			;
04DC:         	_SPRAllocateUndo:
04DC: D1      			pop 	de 							; address of UDG into DE
04DD: 7A      			ld 		a,d 						; have we done the whole lot ?
04DE: B3      			or 		e
04DF: 37      			scf
04E0: 281C    			jr 		z,_SPRAllocateExit 			; if so, e.g. popped $0000 with carry set.
              	
04E2: CB3A    			srl 	d 							; divide by 8 - will put the UDG number into E
04E4: CB1B    			rr 		e
04E6: CB3A    			srl 	d
04E8: CB1B    			rr 		e
04EA: CB3A    			srl 	d
04EC: CB1B    			rr 		e
              			;
04EE: 6B      			ld 		l,e 						; HL is the address of the original character for this UDG.
04EF: 2606    			ld 		h,SPROriginalChar >> 8 		
04F1: 7E      			ld 		a,(hl) 						; character the UDG replaced
04F2: 36FF    			ld 		(hl),$FF 					; mark that UDG as now available
              	
04F4: 2608    			ld 		h,SPRLowAddress >> 8 		; get screen address into DE
04F6: 5E      			ld 		e,(hl)
04F7: 2609    			ld 		h,SPRHighAddress >> 8 
04F9: 56      			ld 		d,(hl)
              	
04FA: 12      			ld 		(de),a 						; fix up screen
              	
04FB: 18DF    			jr 		_SPRAllocateUndo 			; and see if there are any more to undo
              			;
              			; 		Worked, exit with carry clear.
              			;
04FD:         	_SPRAllocateOkay: 							; clear carry flag and exit.
04FD: AF      			xor 	a		
04FE:         	_SPRAllocateExit:
04FE: ED7BB205			ld 		sp,(_SPRAllocSPTemp)		; get SP back
0502: FDE1    			pop 	iy 							; restore BC IY
0504: C1      			pop 	bc				
0505: C9      			ret
              	
              	; *********************************************************************************************
              	;
              	; 		Allocate a single UDG sprite, overwriting (IY), saving the original and copying
              	; 		the definition. On exit HL points to its graphic definition.
              	;
              	; *********************************************************************************************
              	
0506:         	_SPRAllocateOne:
0506: 3AB405  			ld 		a,(_SPRFirstUDGSprite)		; L = first sprite UDG
0509: 6F      			ld 		l,a
050A: FD7E00  			ld 		a,(iy+0) 					; is it a UDG already
050D: BD      			cp 		l 							; if so, we don't need to do anything.
050E: 3032    			jr 		nc,_SPRAllocateOneExit
              			;
              			; 		Look for a free UDG, e.g. one where the stored character is $FF.
              			;
0510: 2606    			ld 		h,SPROriginalChar >> 8
0512:         	_SPRAOFind: 								; look for an available UDG.
0512: 7E      			ld 		a,(hl)
0513: FEFF    			cp 		$FF
0515: 2805    			jr 		z,_SPRAOFound
0517: 2C      			inc 	l
0518: 20F8    			jr 		nz,_SPRAOFind		
051A: 37      			scf 								; nope, we just can't do this one.
051B: C9      			ret
              	;
              	;  		Found a sprite we can allocate
              	;
051C:         	_SPRAOFound:
              			;
              			; 		Store the character overwritten by the UDG
              			;
051C: FD7E00  			ld 		a,(iy+0) 					; this is the original character e.g. what is underneath
051F: 77      			ld 		(hl),a 						; put in storage slot for original character
              			;
0520: FDE5    			push 	iy 							; save the address of that character so we can restore it.
0522: C1      			pop 	bc 							; when it drops to zero.
0523: 2608    			ld 		h,SPRLowAddress >> 8
0525: 71      			ld 		(hl),c
0526: 2609    			ld 		h,SPRHighAddress >> 8
0528: 70      			ld 		(hl),b
              			;
              			; 		Copy the graphic definition of the original character into the UDG.
              			;
              	
0529: FD7E00  			ld 		a,(iy+0) 					; get the original character , e.g. the non UDG
052C: FD7500  			ld 		(iy+0),l 					; override it.
              			;
052F: CD4C05  			call 	_SPRCalculateDefinitionAddr ; HL is the graphic of the original character
0532: EB      			ex 		de,hl
0533: FD7E00  			ld 		a,(iy+0) 					; HL is the graphic of the UDG
0536: CD4C05  			call 	_SPRCalculateDefinitionAddr
0539: EB      			ex 		de,hl 						; we want it copied there
053A: 010800  			ld 		bc,8 						; copy 8 bytes
053D: EDB0    			ldir
              	
053F: FD7E00  			ld 		a,(iy+0) 					; get the address of the UDG and exit with CC
0542:         	_SPRAllocateOneExit;
0542: CD4C05  			call 	_SPRCalculateDefinitionAddr ; get the definition address in HL
0545: 3AB105  			ld 		a,(_SPRInitialYOffset) 		; adjust for initial Y offset
0548: B5      			or 		l
0549: 6F      			ld 		l,a
054A: AF      			xor 	a 							; clear carry.
054B: C9      			ret 			
              	;
              	; 		A is a character #, point HL to CRAM Address
              	;
054C:         	_SPRCalculateDefinitionAddr:
054C: 6F      			ld 		l,a
054D: 261E    			ld 		h,$F0/8
054F: 29      			add 	hl,hl
0550: 29      			add 	hl,hl
0551: 29      			add 	hl,hl
0552: C9      			ret
              	
              	; *********************************************************************************************
              	;
              	;							Adjust usage counter for (IY)
              	;
              	; *********************************************************************************************
              	
0553:         	SPRAdjustUsageCounter:
0553: FD6E00  			ld 		l,(iy+0) 					; point HL to the usage counter
0556: 2607    			ld 		h,SPRUsageCount >> 8
0558: DDCB077E			bit 	7,(ix+SPRstatus)			; if drawn status is non-zero we are erasing
055C: 2002    			jr 		nz,_SPRDecrementUsage
055E: 34      			inc 	(hl)						; increment usage counter and exit
055F: C9      			ret
              	;
0560:         	_SPRDecrementUsage:
0560: 35      			dec 	(hl) 						; one fewer usage
0561: C0      			ret 	nz 							; still in use.
              			;
              			; 		Count zero, free up. Could consider delaying this until actually needed?
              			;
0562: 2608    			ld 		h,SPRLowAddress >> 8 		; display address in DE
0564: 5E      			ld 		e,(hl)
0565: 2609    			ld 		h,SPRHighAddress >> 8
0567: 56      			ld 		d,(hl)
0568: 2606    			ld 		h,SPROriginalChar >> 8 		; original character written to DE
056A: 7E      			ld 		a,(hl)
056B: 12      			ld 		(de),a 					
              	
056C: 36FF    			ld 		(hl),$FF 					; mark the UDG as free again.
056E: C9      			ret
              	
              	
              	; *********************************************************************************************
              	;
              	;						Flip ADE - byteflip D or DE and swap.
              	;
              	; *********************************************************************************************
              	
056F:         	SPRFlipDE:
056F: 7A      			ld 	 	a,d 						; flip D
0570: CD8105  			call 	_SPRFlipA
0573: 57      			ld 		d,a
0574: DDCB0646			bit 	0,(IX+SPRcontrol)  			; if width 1 exit.
0578: C8      			ret 	z
              	
0579: 6B      			ld 		l,e 						; save E
057A: 5F      			ld 		e,a 						; put flipped D into E
057B: 7D      			ld 		a,l 						; get old E, flip into D
057C: CD8105  			call 	_SPRFlipA
057F: 57      			ld 		d,a
0580: C9      			ret
              	;
              	; 		Flip A
              	;		
0581:         	_SPRFlipA:
0581: B7      			or 		a 							; shortcut, reverse zero.
0582: C8      			ret 	z
0583: CD8A05  			call 	_SPRFlipLow 				; flip the low nibble
0586: 0F      			rrca 								; swap halves
0587: 0F      			rrca
0588: 0F      			rrca
0589: 0F      			rrca 								; then fall through to flip high nibble.
058A:         	_SPRFlipLow:			
058A: F5      			push 	af 							; save original
058B: E60F    			and 	$0F 						; access the flip value.
058D: C6A0    			add 	_SPRFlipTable & $FF
058F: 6F      			ld 		l,a
0590: 2605    			ld 		h,_SPRFlipTable >> 8 
0592: F1      			pop 	af 							; restore original
0593: E6F0    			and 	$F0 						; replace lower nibble
0595: B6      			or 		(hl)
0596: C9      			ret
              	;
              	;		One Nibble Reversed.
              	;
0597: 00000000			.align 	16,0 						; all in one page.
059B: 00...   	
              	
05A0:         	_SPRFlipTable:
05A0: 0008040C			.db 	0,8,4,12,2,10,6,14
05A4: 020A060E	
05A8: 0109050D			.db 	1,9,5,13,3,11,7,15
05AC: 030B070F	
              	
              	; *********************************************************************************************
              	;
              	; 									General Data
              	;
              	; *********************************************************************************************
              	
05B0:         	_SPRRowCount: 								; down counter for completed rows.
05B0: 00      			.db 	0
              	
05B1:         	_SPRInitialYOffset: 						; the initial vertical offset.
05B1: 00      			.db 	0
              	
05B2:         	_SPRAllocSPTemp: 							; save SP when storing interim results on stack
05B2: 0000    			.dw 	0
              	
05B4:         	_SPRFirstUDGSprite: 						; first sprite available as UDG.
05B4: 80      			.db 	$80
              	
              	; *********************************************************************************************
              	;
              	;		Sprite/UDG Specific Data. Each of these is a 256 byte array aligned
              	; 		on a page. This is a bit wasteful if you don't have many sprites but quicker.
              	;
              	; *********************************************************************************************
              	
05B5: 00000000			.align 	256,0
05B9: 00...   	
              	
0600:         	SPRDataBlock:
              	
              	;
              	;		This is the original value stored the UDG replaced. When $FF it means
              	; 		this UDG is not in use.
              	;
0600:         	SPROriginalChar:
0600: 00000000			.ds 	256,0
0604: 00...   	
              	;
              	;
              	; 		This is the number of sprites using the given UDG, indexed on zero.
              	;
0700:         	SPRUsageCount:
0700: 00000000			.ds 	256,0
0704: 00...   	
              	;
              	; 		The address of that replaced UDG. 
              	;
0800:         	SPRLowAddress:
0800: 00000000			.ds 	256,0
0804: 00...   	
0900:         	SPRHighAddress:
0900: 00000000			.ds 	256,0
0904: 00...   	
              	
0A00:         	SPRDataBlockEnd:
              	
0A00:         	start:
0A00: 21410A  			ld 		hl,SpriteData
0A03: 110800  			ld 		de,SpriteCount
0A06: CD0502  			call 	SPMReset
              	
0A09: 0603    			ld 		b,3
0A0B: 68      	setup:	ld 		l,b
0A0C: 2600    			ld 		h,0
0A0E: CD2E02  			call 	SPMSelect
0A11: 29      			add 	hl,hl
0A12: 29      			add		hl,hl
0A13: 29      			add 	hl,hl
0A14: 29      			add		hl,hl
0A15: 29      			add		hl,hl
0A16: EB      			ex 		de,hl
0A17: 210E00  			ld 		hl,14
0A1A: CD4F02  			call 	SPMMove
0A1D: 21493B  			ld 		hl,SpriteGraphic2
0A20: CD6802  			call 	SPRImage
0A23: 210300  			ld 		hl,3
0A26: CD7602  			call 	SPMControl
0A29: 10E0    			djnz 	setup
              	
0A2B: 210300  			ld 		hl,3
0A2E: CD2E02  			call 	SPMSelect
0A31: 13      	draw1:	inc 	de
0A32: 1600    			ld 		d,0
0A34: 62      			ld 		h,d
0A35: 6B      			ld 		l,e
0A36: CD4F02  			call 	SPMMove
0A39: CDB102  			call 	SPMUpdate
0A3C: 18F3    			jr 		draw1
              	
0A3E: C33E0A  	w1:		jp 		w1
              	
              	; *********************************************************************************************
              	;										Test data
              	; *********************************************************************************************
              	
0A41:         	SpriteData:
0A41: FFFFFFFF			.ds 	16*SPMCount
0A45: FF...   	
              	
3B31:         	SpriteDemo:		
3B31: 0400    			.dw 	4 							; X
3B33: 0A00    			.dw 	10 							; Y
3B35: 893B    			.dw 	SpriteGraphic4 				; Graphics
3B37: 0000    			.dw 	$00 						; Control
              	
3B39:         	SpriteGraphic:
3B39: FF818181			.db 	$FF,$81,$81,$81,$81,$81,$81,$FF
3B3D: 818181FF	
              	
3B41:         	SpriteDemo2:		
3B41: 1300    			.dw 	19 							; X
3B43: 1C00    			.dw 	28 							; Y
3B45: 693B    			.dw 	SpriteGraphic3	 			; Graphics
3B47: 0300    			.dw 	$03							; Control
              	
3B49:         	SpriteGraphic2:
3B49: FFFF0180			.dw 	$FFFF,$8001,$F001,$8001,$8001,$8001,$8001,$AAAA
3B4D: 01F00180	
3B51: 01800180	
3B55: 0180AAAA	
3B59: 555503C0			.dw 	$5555,$C003,$C003,$E007,$F00F,$F81F,$FC3F,$03C0
3B5D: 03C007E0	
3B61: 0FF01FF8	
3B65: 3FFCC003	
              	
3B69:         	SpriteGraphic3:
3B69: 00800040			.dw 	$8000,$4000,$2000,$1000,$0800,$0400,$0200,$0100
3B6D: 00200010	
3B71: 00080004	
3B75: 00020001	
3B79: 80004000			.dw 	$0080,$0040,$0020,$0010,$0008,$000C,$000E,$000F
3B7D: 20001000	
3B81: 08000C00	
3B85: 0E000F00	
              	
3B89:         	SpriteGraphic4:
3B89: 80402010			.db 	$80,$40,$20,$10,8,12,14,15
3B8D: 080C0E0F	
              	


total time: 0.0048 sec.
no errors
