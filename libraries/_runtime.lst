                        ; --------------------------------------
                        ; zasm: assemble "_runtime.asm"
                        ; date: 2021-11-02 12:17:46
                        ; --------------------------------------


0202:                   	.org $202
0202:                   M8_C_boot:
0202: 3100F0   [10]     	ld sp,$F000
0205: C30202   [20]     	jp $202
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		binary.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Binary operators (A ? B -> A)
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
                        ; ***************************************************************************************
                        
0208:                   M8_C__c60_:
0208: 7C       [ 4]     	ld 		a,h 								 	; check if signs different.
0209: AA       [ 8]     	xor 	d
020A: 87       [12]     	add 	a,a 									; CS if different
020B: 3004     [19|24]  	jr 		nc,__less_samesign
020D: 7A       [23]     	ld 		a,d 									; different. set CS to sign of B
020E: 87       [27]     	add 	a,a 									; if set (negative) B must be < A as A is +ve
020F: 1805     [39]     	jr 		__less_returnc
0211:                   __less_samesign:
0211: D5       [11]     	push 	de 										; save DE
0212: EB       [15]     	ex 		de,hl 									; -1 if B < A
0213: ED52     [30]     	sbc 	hl,de 									; calculate B - A , hencs CS if < (Carry clear by add a,a)
0215: D1       [40]     	pop 	de 										; restore DE
0216:                   __less_returnc:
0216: 3E00     [ 7]     	ld 		a,0 									; A 0
0218: DE00     [14]     	sbc 	a,0 									; A $FF if CS.
021A: 6F       [18]     	ld 		l,a 									; put in HL
021B: 67       [22]     	ld 		h,a
021C: C9       [32]     	ret
021D:                   M8_C__c60__end:
                        
                        ; ***************************************************************************************
                        
021D:                   M8_C__c61_:
021D: 7C       [ 4]     	ld 		a,h 									; H = H ^ D
021E: AA       [ 8]     	xor 	d
021F: 67       [12]     	ld 		h,a
0220: 7D       [16]     	ld 		a,l 									; A = (L ^ E) | (H ^ D)
0221: AB       [20]     	xor 	e
0222: B4       [24]     	or 		h 										; if A == 0 they are the same.
0223: 210000   [34]     	ld 		hl,$0000 								; return 0 if different
0226: C0       [39|45]  	ret 	nz
0227: 2B       [45]     	dec 	hl 										; return -1
0228: C9       [55]     	ret
0229:                   M8_C__c61__end:
                        
                        ; ***************************************************************************************
                        
0229:                   M8_C__c45_:
0229: D5       [11]     	push 	de 										; save DE
022A: EB       [15]     	ex 		de,hl 									; HL = B, DE = A
022B: AF       [19]     	xor 	a  										; clear carry
022C: ED52     [34]     	sbc 	hl,de 									; calculate B-A
022E: D1       [44]     	pop 	de 										; restore DE
022F: C9       [54]     	ret
0230:                   M8_C__c45__end:
                        
                        ; ***************************************************************************************
                        
0230:                   M8_M__c43_:
0230: 19       [11]     	add 	hl,de
0231:                   M8_M__c43__end:
                        
                        ; ***************************************************************************************
                        
0231:                   M8_C_and:
0231: 7C       [ 4]     	ld 		a,h
0232: A2       [ 8]     	and 	d
0233: 67       [12]     	ld 		h,a
0234: 7D       [16]     	ld 		a,l
0235: A3       [20]     	and 	e
0236: 6F       [24]     	ld 		l,a
0237: C9       [34]     	ret
0238:                   M8_C_and_end:
                        
                        ; ***************************************************************************************
                        
0238:                   M8_C_or:
0238: 7C       [ 4]     	ld 		a,h
0239: B2       [ 8]     	or 		d
023A: 67       [12]     	ld 		h,a
023B: 7D       [16]     	ld 		a,l
023C: B3       [20]     	or 		e
023D: 6F       [24]     	ld 		l,a
023E: C9       [34]     	ret
023F:                   M8_C_or_end:
                        
                        ; ***************************************************************************************
                        
023F:                   M8_C_xor:
023F: 7C       [ 4]     	ld 		a,h
0240: AA       [ 8]     	xor 	d
0241: 67       [12]     	ld 		h,a
0242: 7D       [16]     	ld 		a,l
0243: AB       [20]     	xor 	e
0244: 6F       [24]     	ld 		l,a
0245: C9       [34]     	ret
0246:                   M8_C_xor_end:
                        
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		divide.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Division
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
                        ; ***************************************************************************************
                        
0246:                   M8_C__c47_:
0246: D5       [11]     	push 	de
0247: CD5302   [28]     	call 	DIVDivideMod16
024A: EB       [32]     	ex 		de,hl
024B: D1       [42]     	pop 	de
024C: C9       [52]     	ret
024D:                   M8_C__c47__end:
                        
                        ; ***************************************************************************************
                        
024D:                   M8_C_mod:
024D: D5       [11]     	push 	de
024E: CD5302   [28]     	call 	DIVDivideMod16
0251: D1       [38]     	pop 	de
0252: C9       [48]     	ret
0253:                   M8_C_mod_end:
                        
                        ; *********************************************************************************
                        ;
                        ;			Calculates DE / HL. On exit DE = result, HL = remainder
                        ;
                        ; *********************************************************************************
                        
0253:                   DIVDivideMod16:
0253: C5       [11]     	push 	bc
0254: 42       [15]     	ld 		b,d 				; DE
0255: 4B       [19]     	ld 		c,e
0256: EB       [23]     	ex 		de,hl
0257: 210000   [33]     	ld 		hl,0
025A: 78       [37]     	ld 		a,b
025B: 0608     [44]     	ld 		b,8
025D:                   Div16_Loop1:
025D: 17       [ 4]     	rla
025E: ED6A     [19]     	adc 	hl,hl
0260: ED52     [34]     	sbc 	hl,de
0262: 3001     [41|46]  	jr 		nc,Div16_NoAdd1
0264: 19       [52]     	add 	hl,de
0265:                   Div16_NoAdd1:
0265: 10F6     [ 8|13]  	djnz 	Div16_Loop1
0267: 17       [12]     	rla
0268: 2F       [16]     	cpl
0269: 47       [20]     	ld 		b,a
026A: 79       [24]     	ld 		a,c
026B: 48       [28]     	ld 		c,b
026C: 0608     [35]     	ld 		b,8
026E:                   Div16_Loop2:
026E: 17       [ 4]     	rla
026F: ED6A     [19]     	adc 	hl,hl
0271: ED52     [34]     	sbc 	hl,de
0273: 3001     [41|46]  	jr 		nc,Div16_NoAdd2
0275: 19       [52]     	add 	hl,de
0276:                   Div16_NoAdd2:
0276: 10F6     [ 8|13]  	djnz 	Div16_Loop2
0278: 17       [12]     	rla
0279: 2F       [16]     	cpl
027A: 51       [20]     	ld 		d,c
027B: 5F       [24]     	ld 		e,a
027C: C1       [34]     	pop 	bc
027D: C9       [44]     	ret
                        
                        
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		memory.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Memory operators
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
027E:                   M8_M__c33_:
027E: 73       [ 7]     		ld 		(hl),e
027F: 23       [13]     		inc 	hl
0280: 72       [20]     		ld 		(hl),d
0281: 2B       [26]     		dec 	hl
0282:                   M8_M__c33__end:
                        
                        ; ***************************************************************************************
                        
0282:                   M8_M__c64_:
0282: 7E       [ 7]     		ld 		a,(hl)
0283: 23       [13]     		inc 	hl
0284: 66       [20]     		ld		h,(hl)
0285: 6F       [24]     		ld		l,a
0286:                   M8_M__c64__end:
                        
                        ; ***************************************************************************************
                        
0286:                   M8_C__c43__c33_:
0286: 7E       [ 7]     		ld 		a,(hl)
0287: 83       [11]     		add 	a,e
0288: 77       [18]     		ld 		(hl),a
0289: 23       [24]     		inc 	hl
028A: 7E       [31]     		ld 		a,(hl)
028B: 8A       [35]     		adc 	a,d
028C: 77       [42]     		ld 		(hl),a
028D: 2B       [48]     		dec 	hl
028E: C9       [58]     		ret
028F:                   M8_C__c43__c33__end:
                        
                        ; ***************************************************************************************
                        
028F:                   M8_M_c_c33_:
028F: 73       [ 7]     		ld 		(hl),e
0290:                   M8_M_c_c33__end:
                        
                        ; ***************************************************************************************
                        
0290:                   M8_M_c_c64_:
0290: 6E       [ 7]     		ld 		l,(hl)
0291: 2600     [14]     		ld 		h,0
0293:                   M8_M_c_c64__end:
                        
                        ; ***************************************************************************************
                        
0293:                   M8_C_p_c64_:
0293: C5       [11]     		push 	bc
0294: 44       [15]     		ld		b,h
0295: 4D       [19]     		ld 		c,l
0296: ED68     [31]     		in 		l,(c)
0298: 2600     [38]     		ld 		h,0
029A: C1       [48]     		pop 	bc
029B: C9       [58]     		ret
029C:                   M8_C_p_c64__end:
                        
                        ; ***************************************************************************************
                        
029C:                   M8_C_p_c33_:
029C: C5       [11]     		push 	bc
029D: E5       [22]     		push 	hl
029E: 7B       [26]     		ld 		a,e
029F: 44       [30]     		ld		b,h
02A0: 4D       [34]     		ld 		c,l
02A1: ED79     [46]     		out 	(c),a
02A3: E1       [56]     		pop 	hl
02A4: C1       [66]     		pop 	bc
02A5: C9       [76]     		ret
02A6:                   M8_C_p_c33__end:
                        
                        
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		miscellany.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Miscellaneous words
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
02A6:                   M8_C_copy:
02A6: 78       [ 4]     		ld 		a,b 								; exit if C = 0
02A7: B1       [ 8]     		or 		c
02A8: C8       [13|19]  		ret 	z
                        
02A9: C5       [24]     		push 	bc 									; BC count
02AA: D5       [35]     		push 	de 									; DE target
02AB: E5       [46]     		push 	hl 									; HL source
                        
02AC: AF       [50]     		xor 	a 									; Clear C
02AD: ED52     [65]     		sbc 	hl,de 								; check overlap ?
02AF: 300B     [72|77]  		jr 		nc,__copy_gt_count 					; if source after target
02B1: 19       [83]     		add 	hl,de 								; undo subtract
                        
02B2: 09       [94]     		add 	hl,bc 								; add count to HL + DE
02B3: EB       [98]     		ex 		de,hl
02B4: 09       [109]    		add 	hl,bc
02B5: EB       [113]    		ex 		de,hl
02B6: 1B       [119]    		dec 	de 									; dec them, so now at the last byte to copy
02B7: 2B       [125]    		dec 	hl
02B8: EDB8     [141|21] 		lddr 										; do it backwards
02BA: 1803     [153]    		jr 		__copy_exit
                        
02BC:                   __copy_gt_count:
02BC: 19       [11]     		add 	hl,de 								; undo subtract
02BD: EDB0     [27|21]  		ldir										; do the copy
02BF:                   __copy_exit:
02BF: E1       [10]     		pop 	hl 									; restore registers
02C0: D1       [20]     		pop 	de
02C1: C1       [30]     		pop 	bc
02C2: C9       [40]     		ret
02C3:                   M8_C_copy_end:
                        
                        ; ***************************************************************************************
                        
02C3:                   M8_C_fill:
02C3: 78       [ 4]     		ld 		a,b 								; exit if C = 0
02C4: B1       [ 8]     		or 		c
02C5: C8       [13|19]  		ret 	z
                        
02C6: C5       [24]     		push 	bc 									; BC count
02C7: D5       [35]     		push 	de 									; DE target, L byte
02C8:                   __fill_loop:
02C8: 7D       [ 4]     		ld 		a,l 								; copy a byte
02C9: 12       [11]     		ld 		(de),a
02CA: 13       [17]     		inc 	de 									; bump pointer
02CB: 0B       [23]     		dec 	bc 									; dec counter and loop
02CC: 78       [27]     		ld 		a,b
02CD: B1       [31]     		or 		c
02CE: 20F8     [38|43]  		jr 		nz,__fill_loop
02D0: D1       [48]     		pop 	de 									; restore
02D1: C1       [58]     		pop 	bc
02D2: C9       [68]     		ret
02D3:                   M8_C_fill_end:
                        
                        ; ***************************************************************************************
                        
02D3:                   M8_C_halt:
02D3:                   __halt_loop:
02D3: F3       [ 4]     		di
02D4: 76       [ 8]     		halt
02D5: 18FC     [20]     		jr 		__halt_loop
02D7:                   M8_C_halt_end:
                        
                        ; ***************************************************************************************
                        
02D7:                   M8_M_break:
02D7: 76                		db 		$76
02D8:                   M8_M_break_end:
                        
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		multiply.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Multiplication
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
                        
02D8:                   M8_C__c42_:
02D8: C3DB02   [10]     	jp  	MULTMultiply16
02DB:                   M8_C__c42__end:
                        
                        ; *********************************************************************************
                        ;
                        ;								Does HL = HL * DE
                        ;
                        ; *********************************************************************************
                        
02DB:                   MULTMultiply16:
02DB: C5       [11]     		push 	bc
02DC: D5       [22]     		push 	de
02DD: 44       [26]     		ld 		b,h 							; get multipliers in DE/BC
02DE: 4D       [30]     		ld 		c,l
02DF: 210000   [40]     		ld 		hl,0 							; zero total
02E2:                   __Core__Mult_Loop:
02E2: CB41     [ 8]     		bit 	0,c 							; lsb of shifter is non-zero
02E4: 2801     [15|20]  		jr 		z,__Core__Mult_Shift
02E6: 19       [26]     		add 	hl,de 							; add adder to total
02E7:                   __Core__Mult_Shift:
02E7: CB38     [ 8]     		srl 	b 								; shift BC right.
02E9: CB19     [16]     		rr 		c
02EB: EB       [20]     		ex 		de,hl 							; shift DE left
02EC: 29       [31]     		add 	hl,hl
02ED: EB       [35]     		ex 		de,hl
02EE: 78       [39]     		ld 		a,b 							; loop back if BC is nonzero
02EF: B1       [43]     		or 		c
02F0: 20F0     [50|55]  		jr 		nz,__Core__Mult_Loop
02F2: D1       [60]     		pop 	de
02F3: C1       [70]     		pop 	bc
02F4: C9       [80]     		ret
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		register.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Register manipulation
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
02F5:                   M8_M_swap:
02F5: EB       [ 4]     		ex 		de,hl
02F6:                   M8_M_swap_end:
                        
                        ; ***************************************************************************************
                        
02F6:                   M8_M_a_c62_b:
02F6: 54       [ 4]     		ld 		d,h
02F7: 5D       [ 8]     		ld 		e,l
02F8:                   M8_M_a_c62_b_end:
                        
02F8:                   M8_M_a_c62_c:
02F8: 44       [ 4]     		ld 		b,h
02F9: 4D       [ 8]     		ld 		c,l
02FA:                   M8_M_a_c62_c_end:
                        
                        ; ***************************************************************************************
                        
02FA:                   M8_M_b_c62_a:
02FA: 62       [ 4]     		ld 		h,d
02FB: 6B       [ 8]     		ld 		l,e
02FC:                   M8_M_b_c62_a_end:
                        
02FC:                   M8_M_b_c62_c:
02FC: 42       [ 4]     		ld 		b,d
02FD: 4B       [ 8]     		ld 		c,e
02FE:                   M8_M_b_c62_c_end:
                        
                        ; ***************************************************************************************
                        
02FE:                   M8_M_c_c62_a:
02FE: 60       [ 4]     		ld 		h,b
02FF: 69       [ 8]     		ld 		l,c
0300:                   M8_M_c_c62_a_end:
                        
0300:                   M8_M_c_c62_b:
0300: 50       [ 4]     		ld 		d,b
0301: 59       [ 8]     		ld 		e,c
0302:                   M8_M_c_c62_b_end:
                        
                        
                        ; ***************************************************************************************
                        
0302:                   M8_M_a_c62_x:
0302: E5       [11]     		push 	hl
0303: DDE1     [25]     		pop 	ix
0305:                   M8_M_a_c62_x_end:
                        
0305:                   M8_M_x_c62_a:
0305: DDE5     [15]     		push 	ix
0307: E1       [25]     		pop 	hl
0308:                   M8_M_x_c62_a_end:
                        
0308:                   M8_M_a_c62_y:
0308: E5       [11]     		push 	hl
0309: FDE1     [25]     		pop 	iy
030B:                   M8_M_a_c62_y_end:
                        
030B:                   M8_M_y_c62_a:
030B: FDE5     [15]     		push 	iy
030D: E1       [25]     		pop 	hl
030E:                   M8_M_y_c62_a_end:
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		stack.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Stack words
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
030E:                   M8_M_push:
030E: E5       [11]     	push 	hl
030F:                   M8_M_push_end:
                        
030F:                   M8_M_pop:
030F: EB       [ 4]     	ex 		de,hl
0310: E1       [14]     	pop 	hl
0311:                   M8_M_pop_end:
                        
                        ; ***************************************************************************************
                        
0311:                   M8_M_a_c62_r:
0311: E5       [11]     	push 	hl
0312:                   M8_M_a_c62_r_end:
                        
0312:                   M8_M_r_c62_a:
0312: E1       [10]     	pop 	hl
0313:                   M8_M_r_c62_a_end:
                        
                        ; ***************************************************************************************
                        
0313:                   M8_M_b_c62_r:
0313: D5       [11]     	push 	de
0314:                   M8_M_b_c62_r_end:
                        
0314:                   M8_M_r_c62_b:
0314: D1       [10]     	pop 	de
0315:                   M8_M_r_c62_b_end:
                        
                        ; ***************************************************************************************
                        
0315:                   M8_M_c_c62_r:
0315: C5       [11]     	push 	bc
0316:                   M8_M_c_c62_r_end:
                        
0316:                   M8_M_r_c62_c:
0316: C1       [10]     	pop 	bc
0317:                   M8_M_r_c62_c_end:
                        
                        
                        ; ***************************************************************************************
                        
0317:                   M8_M_ab_c62_r:
0317: D5       [11]     	push 	de
0318: E5       [22]     	push 	hl
0319:                   M8_M_ab_c62_r_end:
                        
0319:                   M8_M_r_c62_ab:
0319: E1       [10]     	pop 	hl
031A: D1       [20]     	pop 	de
031B:                   M8_M_r_c62_ab_end:
                        
                        ; ***************************************************************************************
                        
031B:                   M8_M_abc_c62_r:
031B: C5       [11]     	push 	bc
031C: D5       [22]     	push 	de
031D: E5       [33]     	push 	hl
031E:                   M8_M_abc_c62_r_end:
                        
031E:                   M8_M_r_c62_abc:
031E: E1       [10]     	pop 	hl
031F: D1       [20]     	pop 	de
0320: C1       [30]     	pop 	bc
0321:                   M8_M_r_c62_abc_end:
                        
                        
                        ; ***************************************************************************************
                        
0321:                   M8_M_bc_c62_r:
0321: C5       [11]     	push 	bc
0322: D5       [22]     	push 	de
0323:                   M8_M_bc_c62_r_end:
                        
0323:                   M8_M_r_c62_bc:
0323: D1       [10]     	pop 	de
0324: C1       [20]     	pop 	bc
0325:                   M8_M_r_c62_bc_end:
                        
                        ; ***************************************************************************************
                        
0325:                   M8_M_x_c62_r:
0325: DDE5     [15]     	push 	ix
0327:                   M8_M_x_c62_r_end:
                        
0327:                   M8_M_r_c62_x:
0327: DDE1     [14]     	pop 	ix
0329:                   M8_M_r_c62_x_end:
                        
                        ; ***************************************************************************************
                        
0329:                   M8_M_y_c62_r:
0329: FDE5     [15]     	push 	iy
032B:                   M8_M_y_c62_r_end:
                        
032B:                   M8_M_r_c62_y:
032B: FDE1     [14]     	pop 	iy
032D:                   M8_M_r_c62_y_end:
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        ;
                        ;		Name : 		unary.asm
                        ;		Author :	Paul Robson (paul@robsons.org.uk)
                        ;		Date : 		31st October 2021
                        ;		Purpose :	Unary operators (A ? B -> A)
                        ;
                        ; ***************************************************************************************
                        ; ***************************************************************************************
                        
032D:                   M8_M__c45__c45__c45_:
032D: 2B       [ 6]     		dec 	hl
032E: 2B       [12]     		dec 	hl
032F:                   M8_M__c45__c45__c45__end:
                        
                        ; ***************************************************************************************
                        
032F:                   M8_M__c45__c45_:
032F: 2B       [ 6]     		dec 	hl
0330:                   M8_M__c45__c45__end:
                        
                        ; ***************************************************************************************
                        
0330:                   M8_M__c43__c43_:
0330: 23       [ 6]     		inc 	hl
0331:                   M8_M__c43__c43__end:
                        
                        ; ***************************************************************************************
                        
0331:                   M8_M__c43__c43__c43_:
0331: 23       [ 6]     		inc 	hl
0332: 23       [12]     		inc 	hl
0333:                   M8_M__c43__c43__c43__end:
                        
                        ; ***************************************************************************************
                        
0333:                   M8_C_0_c45_:
0333:                   __negate:
0333: 7C       [ 4]     		ld 		a,h
0334: 2F       [ 8]     		cpl
0335: 67       [12]     		ld 		h,a
0336: 7D       [16]     		ld 		a,l
0337: 2F       [20]     		cpl
0338: 6F       [24]     		ld 		l,a
0339: 23       [30]     		inc 	hl
033A: C9       [40]     		ret
033B:                   M8_C_0_c45__end:
                        
                        ; ***************************************************************************************
                        
033B:                   M8_C_0_c60_:
033B: CB7C     [ 8]     		bit 	7,h
033D: 210000   [18]     		ld 		hl,$0000
0340: C8       [23|29]  		ret 	z
0341: 2B       [29]     		dec 	hl
0342: C9       [39]     		ret
0343:                   M8_C_0_c60__end:
                        
                        ; ***************************************************************************************
                        
0343:                   M8_C_0_c61_:
0343: 7C       [ 4]     		ld 		a,h
0344: B5       [ 8]     		or 		l
0345: 210000   [18]     		ld 		hl,$0000
0348: C0       [23|29]  		ret 	nz
0349: 2B       [29]     		dec 	hl
034A: C9       [39]     		ret
034B:                   M8_C_0_c61__end:
                        
                        ; ***************************************************************************************
                        
034B:                   M8_M_2_c42_:
034B: 29       [11]     		add 	hl,hl
034C:                   M8_M_2_c42__end:
                        
034C:                   M8_M_4_c42_:
034C: 29       [11]     		add 	hl,hl
034D: 29       [22]     		add 	hl,hl
034E:                   M8_M_4_c42__end:
                        
034E:                   M8_M_8_c42_:
034E: 29       [11]     		add 	hl,hl
034F: 29       [22]     		add 	hl,hl
0350: 29       [33]     		add 	hl,hl
0351:                   M8_M_8_c42__end:
                        
0351:                   M8_M_16_c42_:
0351: 29       [11]     		add 	hl,hl
0352: 29       [22]     		add 	hl,hl
0353: 29       [33]     		add 	hl,hl
0354: 29       [44]     		add 	hl,hl
0355:                   M8_M_16_c42__end:
                        
0355:                   M8_M_256_c42_:
0355: 65       [ 4]     		ld 		h,l
0356: 2E00     [11]     		ld		l,0
0358:                   M8_M_256_c42__end:
                        
                        ; ***************************************************************************************
                        
0358:                   M8_M_2_c47_:
0358: CB2C     [ 8]     		sra 	h
035A: CB1D     [16]     		rr 		l
035C:                   M8_M_2_c47__end:
                        
035C:                   M8_M_4_c47_:
035C: CB2C     [ 8]     		sra 	h
035E: CB1D     [16]     		rr 		l
0360: CB2C     [24]     		sra 	h
0362: CB1D     [32]     		rr 		l
0364:                   M8_M_4_c47__end:
                        
0364:                   M8_C_8_c47_:
0364: CB2C     [ 8]     		sra 	h
0366: CB1D     [16]     		rr 		l
0368: CB2C     [24]     		sra 	h
036A: CB1D     [32]     		rr 		l
036C: CB2C     [40]     		sra 	h
036E: CB1D     [48]     		rr 		l
0370:                   M8_C_8_c47__end:
                        
0370:                   M8_C_16_c47_:
0370: CB2C     [ 8]     		sra 	h
0372: CB1D     [16]     		rr 		l
0374: CB2C     [24]     		sra 	h
0376: CB1D     [32]     		rr 		l
0378: CB2C     [40]     		sra 	h
037A: CB1D     [48]     		rr 		l
037C: CB2C     [56]     		sra 	h
037E: CB1D     [64]     		rr 		l
0380:                   M8_C_16_c47__end:
                        
0380:                   M8_M_256_c47_:
0380: 6C       [ 4]     		ld 		l,h
0381: 2600     [11]     		ld 		h,0
0383:                   M8_M_256_c47__end:
                        
                        ; ***************************************************************************************
                        
0383:                   M8_C_abs:
0383: CB7C     [ 8]     		bit 	7,h
0385: C8       [13|19]  		ret		z
0386: C33303   [23]     		jp 		__negate
0389:                   M8_C_abs_end:
                        
                        ; ***************************************************************************************
                        
0389:                   M8_M_bswap:
0389: 7D       [ 4]     		ld 		a,l
038A: 6C       [ 8]     		ld 		l,h
038B: 67       [12]     		ld 		h,a
038C:                   M8_M_bswap_end:
                        
                        ; ***************************************************************************************
                        
038C:                   M8_C_not:
038C: 7C       [ 4]     		ld 		a,h
038D: 2F       [ 8]     		cpl
038E: 67       [12]     		ld 		h,a
038F: 7D       [16]     		ld 		a,l
0390: 2F       [20]     		cpl
0391: 6F       [24]     		ld 		l,a
0392: C9       [34]     		ret
0393:                   M8_C_not_end:
                        
                        ; ***************************************************************************************
                        
0393:                   M8_C_strlen:
0393: D5       [11]     		push 	de
0394: EB       [15]     		ex 		de,hl
0395: 210000   [25]     		ld 		hl,0
0398:                   _SLNLoop:
0398: 1A       [ 7]     		ld 		a,(de)
0399: B7       [11]     		or 		a
039A: 2804     [18|23]  		jr 		z,_SLNExit
039C: 13       [24]     		inc 	de
039D: 23       [30]     		inc 	hl
039E: 18F8     [42]     		jr 		_SLNLoop
03A0:                   _SLNExit:
03A0: D1       [10]     		pop 	de
03A1: C9       [20]     		ret
03A2:                   M8_C_strlen_end:
                        
                        ; ***************************************************************************************
                        
03A2:                   M8_C_random:
03A2: EB       [ 4]     	ex 		de,hl
03A3: C5       [15]     	push 	bc
03A4: 2ABF03   [31]         ld 		hl,(_randomSeed1)
03A7: 44       [35]         ld 		b,h
03A8: 4D       [39]         ld 		c,l
03A9: 29       [50]         add 	hl,hl
03AA: 29       [61]         add 	hl,hl
03AB: 2C       [65]         inc 	l
03AC: 09       [76]         add 	hl,bc
03AD: 22BF03   [92]         ld 		(_randomSeed1),hl
03B0: 2AC103   [108]        ld 		hl,(_randomSeed2)
03B3: 29       [119]        add 	hl,hl
03B4: 9F       [123]        sbc 	a,a
03B5: E62D     [130]        and 	%00101101
03B7: AD       [134]        xor 	l
03B8: 6F       [138]        ld 		l,a
03B9: 22C103   [154]        ld 		(_randomSeed2),hl
03BC: 09       [165]        add 	hl,bc
03BD: C1       [175]        pop 	bc
03BE: C9       [185]        ret
                        
03BF:                   _randomSeed1:
03BF: CDAB              	.dw 	$ABCD
03C1:                   _randomSeed2:
03C1: B9FD              	.dw 	$FDB9
                        
                        ; *********************************************************************************************
                        ; *********************************************************************************************
                        ;
                        ;		Name:		spritemanager.asm
                        ;		Purpose:	Sprite Manager
                        ;		Created:	1st November 2021
                        ;		Author:		Paul Robson (paul@robsons.org.uk)
                        ;
                        ; *********************************************************************************************
                        ; *********************************************************************************************
                        ;
                        ;		Sprite Record:
                        ;
                        ;			Copy data:
                        ;				0..6 	X:2 	Y:2 	Graphics:2 	Control:1
                        ;				7 		Change flag
                        ; 			Current Data: (as per xsprite.asm)
                        ;				8..14 	X:2 	Y:2 	Graphics:2 	Control:1
                        ;				15 		Status byte
                        ;
                        ;		When being updated, if the change flag is set, then the sprite is removed, then data
                        ;		(0-6) is copied to (8-14), then the sprite redrawn
                        ;
                        ;		The option also exists to erase all sprites ; the point of such being that one can update
                        ;		the background. This sets all the change flags so the sprites are redrawn on the next sync.
                        ;
                        ; *********************************************************************************************
                        ;
                        ;
                        ;			Reset Sprite Manager. HL points to data block, DE is number of sprites
                        ;
                        ;
                        ; *********************************************************************************************
                        
03C3:                   M8_C_spr_c46_reset:
                        
03C3:                   SPMReset:
03C3: F5       [11]     		push 	af
03C4: C5       [22]     		push 	bc
03C5: D5       [33]     		push 	de
03C6: E5       [44]     		push 	hl
03C7: 220D04   [60]     		ld 		(SPMData),hl 				; save count and address
03CA: 7B       [64]     		ld 		a,e
03CB: 320F04   [77]     		ld 		(SPMCount),a
03CE: 87       [81]     		add 	a,a 						; double, as we clear it twice (2 x 8 byte blocks)
03CF: 47       [85]     		ld 		b,a
03D0:                   _SPMClear:
03D0: 0E06     [ 7]     		ld 		c,6 						; write out 6 $FFs to position and graphic
03D2:                   _SPMClear2:
03D2: 36FF     [10]     		ld 		(hl),$FF
03D4: 23       [16]     		inc 	hl
03D5: 0D       [20]     		dec 	c
03D6: 20FA     [27|32]  		jr 		nz,_SPMClear2
03D8: 71       [34]     		ld 		(hl),c 						; followed by 2 zeros (control and status/change byte)
03D9: 23       [40]     		inc 	hl
03DA: 71       [47]     		ld 		(hl),c
03DB: 23       [53]     		inc 	hl
03DC: 10F2     [61|66]  		djnz 	_SPMClear
03DE: 210000   [71]     		ld 		hl,0 						; no current selection
03E1: 221104   [87]     		ld 		(SPMCurrent),hl
03E4: CD1304   [104]    		call 	SPRInitialise 				; erase the sprite control records.
03E7: E1       [114]    		pop 	hl
03E8: D1       [124]    		pop 	de
03E9: C1       [134]    		pop 	bc
03EA: F1       [144]    		pop 	af
03EB: C9       [154]    		ret
                        
03EC:                   M8_C_spr_c46_reset_end:
                        
                        ; *********************************************************************************************
                        ;
                        ;		Sprite functions/words. A sprite is selected via SPMSelect and then moved, graphics
                        ; 		set etc. by other functions. SPMUpdate updates all sprites. Parameters at L/HL then DE.
                        ;
                        ; *********************************************************************************************
                        
03EC:                   M8_C_spr_c46_select:
                        
03EC:                   SPMSelect:
03EC: F5       [11]     		push 	af
03ED: C5       [22]     		push 	bc
03EE: E5       [33]     		push 	hl
03EF: 3A0F04   [46]     		ld		a,(SPMCount)
03F2: BD       [50]     		cp 		l 							; compare max vs selected.
03F3: 280E     [57|62]  		jr 		z,_SPMSFail 				; must be >
03F5: FA0304   [67|67]  		jp 		m,_SPMSFail
                        
03F8: 29       [78]     		add 	hl,hl 						; x 16
03F9: 29       [89]     		add 	hl,hl
03FA: 29       [100]    		add 	hl,hl
03FB: 29       [111]    		add 	hl,hl
03FC: ED5B0D04 [131]    		ld 		de,(SPMData) 				; add base address
0400: 19       [142]    		add 	hl,de
0401: 1803     [154]    		jr 		_SPMSExit 					; write and exit
                        
0403:                   _SPMSFail:
0403: 210000   [10]     		ld 		hl,$0000
0406:                   _SPMSExit:
0406: 221104   [16]     		ld 		(SPMCurrent),hl
0409: E1       [26]     		pop 	hl
040A: D1       [36]     		pop 	de
040B: F1       [46]     		pop 	af
040C: C9       [56]     		ret
040D:                   M8_C_spr_c46_select_end:
                        
                        ; *********************************************************************************************
                        ;
                        ;										Update all sprites
                        ;
                        ; *********************************************************************************************
                        
040D:                   M8_C_spr_c46_update:
                        
040D:                   SPMUpdate:
                        
                        
040D:                   M8_C_spr_c46_update_end:
                        
040D:                   SPMData: 									; address of sprite
040D: 0000              		.dw 	0
040F:                   SPMCount: 									; number of sprites
040F: 0000              		.dw 	0
0411:                   SPMCurrent: 								; currently selected sprite (0 = None.)
0411: 0000              		.dw 	0
                        ; *********************************************************************************************
                        ; *********************************************************************************************
                        ;
                        ;		Name:		xsprite.asm
                        ;		Purpose:	XOR Sprite Drawer
                        ;		Created:	29th October 2021
                        ;		Author:		Paul Robson (paul@robsons.org.uk)
                        ;
                        ; *********************************************************************************************
                        ; *********************************************************************************************
                        
                        ; *********************************************************************************************
                        ;
                        ;		This is an XOR drawing sprite system. This is useful because the draw is self
                        ;		cancelling, and this means you don't have to repaint multiple sprites to restore
                        ; 		the display state. The downside is that it doesn't work well on collisions or
                        ; 		especially backgrounds.
                        ;
                        ;		The original design, which was a simpler draw all/erase all design, was binned
                        ;		because I thought on real hardware it would create too much flash on the display.
                        ;
                        ;		I don't yet have a real machine so can't evaluate this in practice, as the emulator
                        ; 		snapshots the display at 60Mhz, so the effects of endlessly messing with the
                        ;		CRAM and VRAM is largely hidden.
                        ;
                        ;		At 4Mhz it does about 330 draws/erases a second on a 16x16 sprites, twice as fast on
                        ;		8 pixel high sprites.
                        ;
                        ;		It eats UDGs - a single 16x16 sprite needs 9 UDGs if it doesn't overlap with another.
                        ;
                        ; *********************************************************************************************
                        ;
                        ;		How it works.
                        ;
                        ;			When drawing a sprite, it will try to allocate UDGs from its pool for the space
                        ; 			to draw the sprite. When drawing or erasing it then XORs the bit patterns into this
                        ; 			as far as it can. When erased, UDGs are returned to the pool if no longer required.
                        ;
                        ; *********************************************************************************************
                        ;
                        ;		Offsets from IX.
                        ;
                        ;			+0,+1 		Horizontal position (0..319)
                        ;			+2,+3 		Vertical position (0..239)
                        ;			+4,+5 		Pointer to graphic image data.
                        ;							Width : 8  	one byte per row
                        ;							Width : 16 	two bytes per row left-right order
                        ;			+6 			Control
                        ;							Bit 7: 		Set if sprite disabled
                        ;							Bit 6: 		Vertical flip
                        ;							Bit 5:		Horizontal flip
                        ;							Bit 4..2:	0
                        ;							Bit 1:		Double width
                        ;							Bit 0: 		Double height
                        ;			+7 			Status
                        ;							Bit 7:		Set when drawn on screen
                        ;							Bit 6..0:	0
                        ;
                        ;			Changes should only be made when the sprite is not drawn, otherwise chaos
                        ;			will ensue.
                        ;
                        ;			Draws will not fail, however, they may not visually work either. If there are more
                        ;			UDGs required than available graphics will not be drawn, or possibly drawn
                        ;			erratically. It is advised to minimise the number of sprites both for CPU time
                        ;			and UDG usage.
                        ;
                        ;			Use specific UDGs for static/slow objects. For (say) Pacman the only sprites should
                        ;			be the player character and chasing ghosts.
                        ;
                        ; *********************************************************************************************
                        ;
                        ;								  Sprite Record entries
                        ;
                        ; *********************************************************************************************
                        
0000:                   SPRx 	= 0 								; horizontal position, pixels
0002:                   SPRy 	= 2 								; vertical position, pixels
0004:                   SPRgraphics = 4 							; bitmap data
0006:                   SPRcontrol = 6 								; 0:width 1:height 5:HFlip 6:VFlip 7:hidden
                        											; (others are zero)
0007:                   SPRstatus = 7 								; 7:currently drawn
                        
                        ; *********************************************************************************************
                        ;
                        ; 								Initialise the sprite system.
                        ;
                        ; 	At this point sprite records should all have their "currently drawn" bit clear, it will
                        ; 	get very confused otherwise.
                        ;
                        ; *********************************************************************************************
                        
0413:                   SPRInitialise:
0413: F5       [11]     		push 	af
0414: E5       [22]     		push 	hl
                        		;
                        		; 		Clear the main data area.
                        		;
0415: 210007   [32]     		ld 		hl,SPRDataBlock
0418:                   _SPRZeroBlock:
0418: 3600     [10]     		ld 		(hl),$00
041A: 23       [16]     		inc 	hl
041B: 7C       [20]     		ld 		a,h
041C: FE0B     [27]     		cp 		SPRDataBlockEnd >> 8
041E: 20F8     [34|39]  		jr 		nz,_SPRZeroBlock
                        		;
                        		; 		Set all possible original characters to $FF, indicating they are available.
                        		;
0420: 3A9406   [47]     		ld 		a,(_SPRFirstUDGSprite)
0423: 6F       [51]     		ld 		l,a
0424: 2607     [58]     		ld 		h,SPROriginalChar >> 8
0426:                   _SPRUsageReset:
0426: 36FF     [10]     		ld 		(hl),$FF
0428: 2C       [14]     		inc 	l
0429: 20FB     [21|26]  		jr 		nz,_SPRUsageReset
042B: E1       [31]     		pop 	hl
042C: F1       [41]     		pop 	af
042D: C9       [51]     		ret
                        
                        ; *********************************************************************************************
                        ;
                        ;						Draw, or Erase, the sprite whose raw data is at IX
                        ;
                        ; *********************************************************************************************
                        
042E:                   SpriteXDraw: 								; draw only
042E: DDCB077E [20]     		bit 	7,(ix+SPRstatus)
0432: C0       [25|31]  		ret 	nz
0433: 1805     [37]     		jr 		SpriteXToggle
0435:                   SpriteXErase:								; erase only
0435: DDCB077E [20]     		bit 	7,(ix+SPRstatus)
0439: C8       [25|31]  		ret 	z
043A:                   SpriteXToggle:								; flip state
043A: F5       [11]     		push 	af 							; save registers
043B: C5       [22]     		push 	bc
043C: D5       [33]     		push 	de
043D: E5       [44]     		push 	hl
043E: FDE5     [59]     		push 	iy
                        		;
                        		; 		Check actually visible
                        		;
0440: DDCB067E [79]     		bit 	7,(ix+SPRcontrol)
0444: C27505   [89|89]  		jp 		nz,_SPRExit
                        		;
                        		; 		Check range.
                        		;
0447: DD7E01   [108]    		ld 		a,(ix+SPRx+1) 				; MSB of X must be 0 or 1
044A: 47       [112]    		ld 		b,a 						; save in B
044B: E6FE     [119]    		and 	$FE
044D: DDB603   [138]    		or 		a,(ix+SPRy+1) 				; MSB of Y must be zero.
0450: 2011     [145|150]		jr 		nz,_SPRRangeFail
                        		;
0452: DD7E02   [164]    		ld 		a,(ix+SPRy) 				; check Y < 240
0455: FEF0     [171]    		cp 		8*30
0457: 300A     [178|183]		jr 		nc,_SPRRangeFail
                        		;
0459: 05       [182]    		dec 	b 							; if MSB X was 1, now zero
045A: 200A     [189|194]		jr 		nz,_SPRCalcPosition
                        		;
045C: DD7E00   [208]    		ld 		a,(ix+SPRx) 				; X.MSB was 1, so must be X.LSB < 64
045F: FE40     [215]    		cp 		64
0461: 3803     [222|227]		jr 		c,_SPRCalcPosition
0463:                   _SPRRangeFail:
0463: C37505   [10]     		jp 		_SPRExit
                        		;
                        		;		Calculate position in IY
                        		;
0466:                   _SPRCalcPosition:
0466: 2600     [ 7]     		ld 		h,0							; Y position in HL, with lower 3 bits masked, so already x 8
0468: DD7E02   [26]     		ld 		a,(ix+SPRy)
046B: E6F8     [33]     		and 	$F8
046D: 6F       [37]     		ld 		l,a
046E: 54       [41]     		ld 		d,h 						; DE = Y x 8
046F: 5D       [45]     		ld 		e,l
0470: 29       [56]     		add 	hl,hl 						; HL = Y x 32
0471: 29       [67]     		add 	hl,hl
0472: 19       [78]     		add 	hl,de 						; HL = Y x 40
0473: FD2100F8 [92]     		ld 		iy,$F800 					; IY = $F800 + Y x 40
0477: EB       [96]     		ex 		de,hl
0478: FD19     [111]    		add 	iy,de
                        
047A: DD5E00   [130]    		ld 		e,(ix+SPRx)					; DE = X position
047D: DD5601   [149]    		ld 		d,(ix+SPRx+1)
0480: CB3A     [157]    		srl 	d 							; / 8 (after first in range 0-255 hence SRL E)
0482: CB1B     [165]    		rr 		e
0484: CB3B     [173]    		srl 	e
0486: CB3B     [181]    		srl 	e
0488: 1600     [188]    		ld 		d,0 						; add to screen position.
048A: FD19     [203]    		add 	iy,de
                        		;
                        		; 		Calculate and patch the fine horizontal shift jump which adjusts the
                        		; 		number of 24 bit left shifts we do to the graphics data.
                        		;
048C: DD7E00   [222]    		ld 		a,(ix+SPRx)
048F: E607     [229]    		and 	7
0491: 87       [233]    		add 	a,a
0492: 321E05   [246]    		ld 		(_SPRFineHorizontalShift+1),a
                        		;
                        		; 		Calculate the horizontal offset which makes it start drawing part way through a UDG
                        		;
0495: DD7E02   [265]    		ld 		a,(ix+SPRy)
0498: E607     [272]    		and 	7
049A: 329106   [285]    		ld 		(_SPRInitialYOffset),a
                        		;
                        		; 		Calculate the row count from bit 1 of the control byte
                        		; 		(the number of vertical pixels down)
                        		;
049D: 3E08     [292]    		ld 		a,8
049F: DDCB064E [312]    		bit 	1,(ix+SPRcontrol)
04A3: 2801     [319|324]		jr 		z,_SPRSingleHeight
04A5: 87       [323]    		add 	a,a
04A6:                   _SPRSingleHeight:
04A6: 329006   [13]     		ld 		(_SPRRowCount),a
                        		;
                        		;		Set the sprite graphic address and incrementer.
                        		;
04A9: DD6E04   [32]     		ld 		l,(ix+SPRgraphics) 			; data address
04AC: DD6605   [51]     		ld 		h,(ix+SPRgraphics+1)
04AF: 110100   [61]     		ld 		de,1 						; increment/decrement
04B2: DDCB0646 [81]     		bit 	0,(ix+SPRcontrol)
04B6: 2801     [88|93]  		jr 		z,_SPRSGANotDoubleWidth
04B8: 13       [94]     		inc 	de 							; 2 if double width
04B9:                   _SPRSGANotDoubleWidth:
04B9: DDCB0676 [20]     		bit 	6,(ix+SPRcontrol) 			; check for vertical flip.
04BD: 2818     [27|32]  		jr 		z,_SPRSGANotVFlip
                        		;
04BF: EB       [31]     		ex 		de,hl 						; DE = address, HL = increment x 8
04C0: E5       [42]     		push 	hl
04C1: 29       [53]     		add 	hl,hl
04C2: 29       [64]     		add 	hl,hl
04C3: 29       [75]     		add 	hl,hl
04C4: DDCB064E [95]     		bit 	1,(ix+SPRcontrol) 			; x 16 if double height
04C8: 2801     [102|107]		jr 		z,_SPRSGANotDoubleHeight
04CA: 29       [113]    		add 	hl,hl
04CB:                   _SPRSGANotDoubleHeight:
04CB: 19       [11]     		add 	hl,de 						; add 8/16 x increment to start
04CC: C1       [21]     		pop 	bc 							; original increment -> BC
04CD: E5       [32]     		push 	hl 							; save new start on stack.
04CE: 210000   [42]     		ld 		hl,0 						; HL = - increment
04D1: AF       [46]     		xor 	a
04D2: ED42     [61]     		sbc 	hl,bc
04D4: D1       [71]     		pop 	de 							; DE = new start off stack
04D5: EB       [75]     		ex 		de,hl 						; swap them back so HL = address, DE = -increment
04D6: 19       [86]     		add 	hl,de 						; points HL to the last sprite entry.
04D7:                   _SPRSGANotVFlip:
04D7: 22FC04   [16]     		ld 		(_SPRFetchGraphicPtr+1),hl 	; write out start address in HL and incrementer in DE.
04DA: ED530C05 [36]     		ld 		(_SPRAdjustGraphicPtr+1),de
                        		;
                        		; 		Try to allocate UDGs for the current row at IY, 2 or 3 UDGs.
                        		;
04DE:                   _SPRStartNextCharacterRow:
04DE: CD8405   [17]     		call 	_SPRAllocateRow 			; try to allocate the whole row.
04E1: DA7505   [27|27]  		jp 		c,_SPRExit					; it didn't work, so we abandon drawing here.
                        		;
                        		; 		Adjust the usage counters.
                        		;
04E4: FDE5     [42]     		push 	iy
04E6: CD3C06   [59]     		call 	SPRAdjustUsageCounter
04E9: FD23     [69]     		inc 	iy
04EB: CD3C06   [86]     		call 	SPRAdjustUsageCounter
04EE: DDCB0646 [106]    		bit 	0,(ix+SPRcontrol)
04F2: 2805     [113|118]		jr 		z,_SPRAuNotRight
04F4: FD23     [123]    		inc 	iy
04F6: CD3C06   [140]    		call 	SPRAdjustUsageCounter
04F9:                   _SPRAuNotRight:
04F9: FDE1     [14]     		pop 	iy
                        		;
                        		;		Get the graphics for the next *pixel* line. into ADE
                        		;
04FB:                   _SPRNextRowUDG:
                        		;
04FB:                   _SPRFetchGraphicPtr:
04FB: 210000   [10]     		ld 		hl,$0000
04FE: 1E00     [17]     		ld 		e,0							; DE = $00:(HL)
0500: 56       [24]     		ld 		d,(hl)
0501: DDCB0646 [44]     		bit 	0,(ix+SPRcontrol) 			; is the width 1 ?
0505: 2804     [51|56]  		jr 		z,_SPRHaveGraphicData
0507: 23       [57]     		inc 	hl
0508: 5A       [61]     		ld 		e,d  						; DE = (HL+1):(HL)
0509: 56       [68]     		ld 		d,(hl)
050A: 2B       [74]     		dec 	hl
050B:                   _SPRHaveGraphicData:
                        		;
050B:                   _SPRAdjustGraphicPtr:
050B: 010000   [10]     		ld 		bc,$0000 					; this is changed to account for size and
050E: 09       [21]     		add 	hl,bc 						; direction.
050F: 22FC04   [37]     		ld 		(_SPRFetchGraphicPtr+1),hl
                        		;
                        		; 		Check for Horizontal Flip
                        		;
0512: DDCB066E [57]     		bit 	5,(ix+SPRcontrol)			; if HFlip bit set
0516: 2803     [64|69]  		jr 		z,_SPRNoHFlip
0518: CD5806   [81]     		call 	SPRFlipDE 					; Flip DE
051B:                   _SPRNoHFlip:
051B: AF       [ 4]     		xor 	a 							; ADE contains 24 bit graphic data.
051C: EB       [ 8]     		ex 		de,hl 						; we put it in AHL
051D:                   _SPRFineHorizontalShift:
051D: 1800     [12]     		jr 		$+2 						; this is altered to do the fine horizontal shift
051F: 29       [23]     		add 	hl,hl
0520: 8F       [27]     		adc 	a,a
0521: 29       [38]     		add 	hl,hl
0522: 8F       [42]     		adc 	a,a
0523: 29       [53]     		add 	hl,hl
0524: 8F       [57]     		adc 	a,a
0525: 29       [68]     		add 	hl,hl
0526: 8F       [72]     		adc 	a,a
0527: 29       [83]     		add 	hl,hl
0528: 8F       [87]     		adc 	a,a
0529: 29       [98]     		add 	hl,hl
052A: 8F       [102]    		adc 	a,a
052B: 29       [113]    		add 	hl,hl
052C: 8F       [117]    		adc 	a,a
052D: 29       [128]    		add 	hl,hl
052E: 8F       [132]    		adc 	a,a
052F: EB       [136]    		ex 		de,hl 						; put it back in ADE
                        		;
                        		;		Now XOR the data with the previously calculated addresses.
                        		;		If (ix+5)[0] is clear then don't do the third one, it's an 8x8 sprite
                        		;
                        		;		These addresses (the ld hl,xxxx ones) are modified in situ.
                        		;
0530:                   _SPRLeftUDGPosition:
0530: 2108F6   [10]     		ld 		hl,$F000+$C1*8
0533: AE       [17]     		xor 	(hl)
0534: 77       [24]     		ld 		(hl),a
0535:                   _SPRMiddleUDGPosition:
0535: 2110F6   [10]     		ld 		hl,$F000+$C2*8
0538: 7A       [14]     		ld 		a,d
0539: AE       [21]     		xor 	(hl)
053A: 77       [28]     		ld 		(hl),a
053B: DDCB0646 [48]     		bit 	0,(ix+SPRcontrol) 					; if width 1, skip the last draw
053F: 2806     [55|60]  		jr 		z,_SPRDrawEnd
0541:                   _SPRRightUDGPosition:
0541: 2118F6   [10]     		ld 		hl,$F000+$C3*8
0544: 7B       [14]     		ld 		a,e
0545: AE       [21]     		xor 	(hl)
0546: 77       [28]     		ld 		(hl),a
0547:                   _SPRDrawEnd:
                        		;
                        		; 		Check if we have done all the rows
                        		;
0547: 219006   [10]     		ld 		hl,_SPRRowCount
054A: 35       [21]     		dec 	(hl)
054B: 2828     [28|33]  		jr 		z,_SPRExit
                        		;
                        		; 		Now go to the next line down. Initially this just advances the vertical offset
                        		;		in the UDG pointers
                        		;
054D: 213605   [38]     		ld 		hl,_SPRMiddleUDGPosition+1
0550: 34       [49]     		inc 	(hl)
0551: 214205   [59]     		ld 		hl,_SPRRightUDGPosition+1 	; not guaranteed initialised.
0554: 34       [70]     		inc 	(hl)
0555: 213105   [80]     		ld 		hl,_SPRLeftUDGPosition+1
0558: 34       [91]     		inc 	(hl)
                        		;
0559: 7E       [98]     		ld 		a,(hl) 						; check crossed 8 byte boundary
055A: E607     [105]    		and 	7
055C: 209D     [112|117]		jr 		nz,_SPRNextRowUDG 			; if not complete it.
                        
055E: AF       [116]    		xor 	a 							; clear the initial offset
055F: 329106   [129]    		ld 		(_SPRInitialYOffset),a
                        
                        
0562: 112800   [139]    		ld 		de,40 						; advance down one row.
0565: FD19     [154]    		add 	iy,de
                        
0567: 11B0FC   [164]    		ld 		de,$F800+40*30 				; the end of the physical display
056A: FDE5     [179]    		push 	iy
056C: E1       [189]    		pop 	hl
056D: 37       [193]    		scf
056E: ED52     [208]    		sbc 	hl,de
0570: 3003     [215|220]		jr 		nc,_SPRExit 				; past the bottom,exit.
                        
0572: C3DE04   [225]    		jp 		_SPRStartNextCharacterRow 	; do the next character row.
                        
0575:                   _SPRExit:
0575: DD7E07   [19]     		ld 		a,(ix+SPRstatus) 			; toggle the drawn status bit
0578: EE80     [26]     		xor 	$80
057A: DD7707   [45]     		ld 		(ix+SPRstatus),a
                        
057D: FDE1     [59]     		pop 	iy 							; restore registers
057F: E1       [69]     		pop 	hl
0580: D1       [79]     		pop 	de
0581: C1       [89]     		pop 	bc
0582: F1       [99]     		pop 	af
0583: C9       [109]    		ret
                        
                        ; *********************************************************************************************
                        ;
                        ;		Allocate 0-3 UDGs to the character space according to need and availability.
                        ; 		Fail with CS if can't.
                        ;		If possible,
                        ;			all new UDGs should have the copied graphic from the background and the
                        ;			old background set up.
                        ;			the UDGs should replace the graphics in IY.
                        ;
                        ; *********************************************************************************************
                        
0584:                   _SPRAllocateRow:
0584: C5       [11]     		push 	bc 							; save BC.
0585: FDE5     [26]     		push 	iy 							; save IY
0587: ED739206 [46]     		ld 		(_SPRAllocSPTemp),sp		; save SP as we are using it for temp.
                        
058B: DDCB077E [66]     		bit 	7,(ix+SPRstatus) 			; are we erasing ?
058F: 280A     [73|78]  		jr 		z,_SPRARNotErasing
                        
0591: 3A9406   [86]     		ld 		a,(_SPRFirstUDGSprite)		; B = first sprite useable
0594: 47       [90]     		ld 		b,a
0595: FD7E00   [109]    		ld 		a,(iy+0) 					; if erasing, check if row is drawn on UDGs
0598: B8       [113]    		cp 		b
0599: 384C     [120|125]		jr 		c,_SPRAllocateExit 			; and if so don't allocate the row, exit.
                        
059B:                   _SPRARNotErasing:
059B: 210000   [10]     		ld 		hl,$0000 					; we save all the allocated so far on the stack
059E: E5       [21]     		push 	hl 		 					; this is the end marker.
                        		;
                        		; 		Do 2 or 3. For each overwrite the XOR code addresses and save
                        		;		it on the stack. If it fails, then unwind everything.
                        		;
059F: CDEF05   [38]     		call 	_SPRAllocateOne 			; do (IY)
05A2: 3821     [45|50]  		jr 		c,_SPRAllocateUndo 			; if done, then Undo.
05A4: 223105   [61]     		ld 		(_SPRLeftUDGPosition+1),hl 	; overwrite the code.
05A7: E5       [72]     		push 	hl
                        
05A8: FD23     [82]     		inc 	iy
05AA: CDEF05   [99]     		call 	_SPRAllocateOne 			; do (IY+1)
05AD: 3816     [106|111]		jr 		c,_SPRAllocateUndo 			; if done, then Undo.
05AF: 223605   [122]    		ld 		(_SPRMiddleUDGPosition+1),hl ; overwrite the code.
05B2: E5       [133]    		push 	hl
                        
05B3: DDCB0646 [153]    		bit 	0,(ix+SPRcontrol) 			; if 8 width then we are done.
05B7: 282D     [160|165]		jr 		z,_SPRAllocateOkay
                        
05B9: FD23     [170]    		inc 	iy
05BB: CDEF05   [187]    		call 	_SPRAllocateOne 			; do (IY+2)
05BE: 3805     [194|199]		jr 		c,_SPRAllocateUndo 			; if done, then Undo.
05C0: 224205   [210]    		ld 		(_SPRRightUDGPosition+1),hl ; overwrite the code.
05C3: 1821     [222]    		jr 		_SPRAllocateOkay
                        		;
                        		; 		Failed, so pop the saved UDG addresses on the stack and reset
                        		;	 	as if we hadn't allocated it. We haven't bumped the usage count yet.
                        		;
05C5:                   _SPRAllocateUndo:
05C5: D1       [10]     		pop 	de 							; address of UDG into DE
05C6: 7A       [14]     		ld 		a,d 						; have we done the whole lot ?
05C7: B3       [18]     		or 		e
05C8: 37       [22]     		scf
05C9: 281C     [29|34]  		jr 		z,_SPRAllocateExit 			; if so, e.g. popped $0000 with carry set.
                        
05CB: CB3A     [37]     		srl 	d 							; divide by 8 - will put the UDG number into E
05CD: CB1B     [45]     		rr 		e
05CF: CB3A     [53]     		srl 	d
05D1: CB1B     [61]     		rr 		e
05D3: CB3A     [69]     		srl 	d
05D5: CB1B     [77]     		rr 		e
                        		;
05D7: 6B       [81]     		ld 		l,e 						; HL is the address of the original character for this UDG.
05D8: 2607     [88]     		ld 		h,SPROriginalChar >> 8
05DA: 7E       [95]     		ld 		a,(hl) 						; character the UDG replaced
05DB: 36FF     [105]    		ld 		(hl),$FF 					; mark that UDG as now available
                        
05DD: 2609     [112]    		ld 		h,SPRLowAddress >> 8 		; get screen address into DE
05DF: 5E       [119]    		ld 		e,(hl)
05E0: 260A     [126]    		ld 		h,SPRHighAddress >> 8
05E2: 56       [133]    		ld 		d,(hl)
                        
05E3: 12       [140]    		ld 		(de),a 						; fix up screen
                        
05E4: 18DF     [152]    		jr 		_SPRAllocateUndo 			; and see if there are any more to undo
                        		;
                        		; 		Worked, exit with carry clear.
                        		;
05E6:                   _SPRAllocateOkay: 							; clear carry flag and exit.
05E6: AF       [ 4]     		xor 	a
05E7:                   _SPRAllocateExit:
05E7: ED7B9206 [20]     		ld 		sp,(_SPRAllocSPTemp)		; get SP back
05EB: FDE1     [34]     		pop 	iy 							; restore BC IY
05ED: C1       [44]     		pop 	bc
05EE: C9       [54]     		ret
                        
                        ; *********************************************************************************************
                        ;
                        ; 		Allocate a single UDG sprite, overwriting (IY), saving the original and copying
                        ; 		the definition. On exit HL points to its graphic definition.
                        ;
                        ; *********************************************************************************************
                        
05EF:                   _SPRAllocateOne:
05EF: 3A9406   [13]     		ld 		a,(_SPRFirstUDGSprite)		; L = first sprite UDG
05F2: 6F       [17]     		ld 		l,a
05F3: FD7E00   [36]     		ld 		a,(iy+0) 					; is it a UDG already
05F6: BD       [40]     		cp 		l 							; if so, we don't need to do anything.
05F7: 3032     [47|52]  		jr 		nc,_SPRAllocateOneExit
                        		;
                        		; 		Look for a free UDG, e.g. one where the stored character is $FF.
                        		;
05F9: 2607     [54]     		ld 		h,SPROriginalChar >> 8
05FB:                   _SPRAOFind: 								; look for an available UDG.
05FB: 7E       [ 7]     		ld 		a,(hl)
05FC: FEFF     [14]     		cp 		$FF
05FE: 2805     [21|26]  		jr 		z,_SPRAOFound
0600: 2C       [25]     		inc 	l
0601: 20F8     [32|37]  		jr 		nz,_SPRAOFind
0603: 37       [36]     		scf 								; nope, we just can't do this one.
0604: C9       [46]     		ret
                        ;
                        ;  		Found a sprite we can allocate
                        ;
0605:                   _SPRAOFound:
                        		;
                        		; 		Store the character overwritten by the UDG
                        		;
0605: FD7E00   [19]     		ld 		a,(iy+0) 					; this is the original character e.g. what is underneath
0608: 77       [26]     		ld 		(hl),a 						; put in storage slot for original character
                        		;
0609: FDE5     [41]     		push 	iy 							; save the address of that character so we can restore it.
060B: C1       [51]     		pop 	bc 							; when it drops to zero.
060C: 2609     [58]     		ld 		h,SPRLowAddress >> 8
060E: 71       [65]     		ld 		(hl),c
060F: 260A     [72]     		ld 		h,SPRHighAddress >> 8
0611: 70       [79]     		ld 		(hl),b
                        		;
                        		; 		Copy the graphic definition of the original character into the UDG.
                        		;
                        
0612: FD7E00   [98]     		ld 		a,(iy+0) 					; get the original character , e.g. the non UDG
0615: FD7500   [117]    		ld 		(iy+0),l 					; override it.
                        		;
0618: CD3506   [134]    		call 	_SPRCalculateDefinitionAddr ; HL is the graphic of the original character
061B: EB       [138]    		ex 		de,hl
061C: FD7E00   [157]    		ld 		a,(iy+0) 					; HL is the graphic of the UDG
061F: CD3506   [174]    		call 	_SPRCalculateDefinitionAddr
0622: EB       [178]    		ex 		de,hl 						; we want it copied there
0623: 010800   [188]    		ld 		bc,8 						; copy 8 bytes
0626: EDB0     [204|21] 		ldir
                        
0628: FD7E00   [223]    		ld 		a,(iy+0) 					; get the address of the UDG and exit with CC
062B:                   _SPRAllocateOneExit;
062B: CD3506   [17]     		call 	_SPRCalculateDefinitionAddr ; get the definition address in HL
062E: 3A9106   [30]     		ld 		a,(_SPRInitialYOffset) 		; adjust for initial Y offset
0631: B5       [34]     		or 		l
0632: 6F       [38]     		ld 		l,a
0633: AF       [42]     		xor 	a 							; clear carry.
0634: C9       [52]     		ret
                        ;
                        ; 		A is a character #, point HL to CRAM Address
                        ;
0635:                   _SPRCalculateDefinitionAddr:
0635: 6F       [ 4]     		ld 		l,a
0636: 261E     [11]     		ld 		h,$F0/8
0638: 29       [22]     		add 	hl,hl
0639: 29       [33]     		add 	hl,hl
063A: 29       [44]     		add 	hl,hl
063B: C9       [54]     		ret
                        
                        ; *********************************************************************************************
                        ;
                        ;							Adjust usage counter for (IY)
                        ;
                        ; *********************************************************************************************
                        
063C:                   SPRAdjustUsageCounter:
063C: FD6E00   [19]     		ld 		l,(iy+0) 					; point HL to the usage counter
063F: 2608     [26]     		ld 		h,SPRUsageCount >> 8
0641: DDCB077E [46]     		bit 	7,(ix+SPRstatus)			; if drawn status is non-zero we are erasing
0645: 2002     [53|58]  		jr 		nz,_SPRDecrementUsage
0647: 34       [64]     		inc 	(hl)						; increment usage counter and exit
0648: C9       [74]     		ret
                        ;
0649:                   _SPRDecrementUsage:
0649: 35       [11]     		dec 	(hl) 						; one fewer usage
064A: C0       [16|22]  		ret 	nz 							; still in use.
                        		;
                        		; 		Count zero, free up. Could consider delaying this until actually needed?
                        		;
064B: 2609     [23]     		ld 		h,SPRLowAddress >> 8 		; display address in DE
064D: 5E       [30]     		ld 		e,(hl)
064E: 260A     [37]     		ld 		h,SPRHighAddress >> 8
0650: 56       [44]     		ld 		d,(hl)
0651: 2607     [51]     		ld 		h,SPROriginalChar >> 8 		; original character written to DE
0653: 7E       [58]     		ld 		a,(hl)
0654: 12       [65]     		ld 		(de),a
                        
0655: 36FF     [75]     		ld 		(hl),$FF 					; mark the UDG as free again.
0657: C9       [85]     		ret
                        
                        
                        ; *********************************************************************************************
                        ;
                        ;						Flip ADE - byteflip D or DE and swap.
                        ;
                        ; *********************************************************************************************
                        
0658:                   SPRFlipDE:
0658: 7A       [ 4]     		ld 	 	a,d 						; flip D
0659: CD6A06   [21]     		call 	_SPRFlipA
065C: 57       [25]     		ld 		d,a
065D: DDCB0646 [45]     		bit 	0,(IX+SPRcontrol)  			; if width 1 exit.
0661: C8       [50|56]  		ret 	z
                        
0662: 6B       [54]     		ld 		l,e 						; save E
0663: 5F       [58]     		ld 		e,a 						; put flipped D into E
0664: 7D       [62]     		ld 		a,l 						; get old E, flip into D
0665: CD6A06   [79]     		call 	_SPRFlipA
0668: 57       [83]     		ld 		d,a
0669: C9       [93]     		ret
                        ;
                        ; 		Flip A
                        ;
066A:                   _SPRFlipA:
066A: B7       [ 4]     		or 		a 							; shortcut, reverse zero.
066B: C8       [ 9|15]  		ret 	z
066C: CD7306   [26]     		call 	_SPRFlipLow 				; flip the low nibble
066F: 0F       [30]     		rrca 								; swap halves
0670: 0F       [34]     		rrca
0671: 0F       [38]     		rrca
0672: 0F       [42]     		rrca 								; then fall through to flip high nibble.
0673:                   _SPRFlipLow:
0673: F5       [11]     		push 	af 							; save original
0674: E60F     [18]     		and 	$0F 						; access the flip value.
0676: C680     [25]     		add 	_SPRFlipTable & $FF
0678: 6F       [29]     		ld 		l,a
0679: 2606     [36]     		ld 		h,_SPRFlipTable >> 8
067B: F1       [46]     		pop 	af 							; restore original
067C: E6F0     [53]     		and 	$F0 						; replace lower nibble
067E: B6       [60]     		or 		(hl)
067F: C9       [70]     		ret
                        ;
                        ;		One Nibble Reversed.
                        ;
                        		.align 	16,0 						; all in one page.
                        
0680:                   _SPRFlipTable:
0680: 0008040C          		.db 	0,8,4,12,2,10,6,14
0684: 020A060E          
0688: 0109050D          		.db 	1,9,5,13,3,11,7,15
068C: 030B070F          
                        
                        ; *********************************************************************************************
                        ;
                        ; 									General Data
                        ;
                        ; *********************************************************************************************
                        
0690:                   _SPRRowCount: 								; down counter for completed rows.
0690: 00                		.db 	0
                        
0691:                   _SPRInitialYOffset: 						; the initial vertical offset.
0691: 00                		.db 	0
                        
0692:                   _SPRAllocSPTemp: 							; save SP when storing interim results on stack
0692: 0000              		.dw 	0
                        
0694:                   _SPRFirstUDGSprite: 						; first sprite available as UDG.
0694: 80                		.db 	$80
                        
                        ; *********************************************************************************************
                        ;
                        ;		Sprite/UDG Specific Data. Each of these is a 256 byte array aligned
                        ; 		on a page. This is a bit wasteful if you don't have many sprites but quicker.
                        ;
                        ; *********************************************************************************************
                        
0695: 00000000          		.align 	256,0
0699: 00...             
                        
0700:                   SPRDataBlock:
                        
                        ;
                        ;		This is the original value stored the UDG replaced. When $FF it means
                        ; 		this UDG is not in use.
                        ;
0700:                   SPROriginalChar:
0700: 00000000          		.ds 	256,0
0704: 00...             
                        ;
                        ;
                        ; 		This is the number of sprites using the given UDG, indexed on zero.
                        ;
0800:                   SPRUsageCount:
0800: 00000000          		.ds 	256,0
0804: 00...             
                        ;
                        ; 		The address of that replaced UDG.
                        ;
0900:                   SPRLowAddress:
0900: 00000000          		.ds 	256,0
0904: 00...             
0A00:                   SPRHighAddress:
0A00: 00000000          		.ds 	256,0
0A04: 00...             
                        
0B00:                   SPRDataBlockEnd:


; +++ segments +++

#CODE          = $0202 =   514,  size = $08FE =  2302

; +++ global symbols +++

DIVDivideMod16        = $0253 =   595          _runtime.asm:145
Div16_Loop1           = $025D =   605          _runtime.asm:153
Div16_Loop2           = $026E =   622          _runtime.asm:167
Div16_NoAdd1          = $0265 =   613          _runtime.asm:159
Div16_NoAdd2          = $0276 =   630          _runtime.asm:173
M8_C_0_c45_           = $0333 =   819          _runtime.asm:608 (unused)
M8_C_0_c45__end       = $033B =   827          _runtime.asm:618 (unused)
M8_C_0_c60_           = $033B =   827          _runtime.asm:622 (unused)
M8_C_0_c60__end       = $0343 =   835          _runtime.asm:628 (unused)
M8_C_0_c61_           = $0343 =   835          _runtime.asm:632 (unused)
M8_C_0_c61__end       = $034B =   843          _runtime.asm:639 (unused)
M8_C_16_c47_          = $0370 =   880          _runtime.asm:693 (unused)
M8_C_16_c47__end      = $0380 =   896          _runtime.asm:702 (unused)
M8_C_8_c47_           = $0364 =   868          _runtime.asm:684 (unused)
M8_C_8_c47__end       = $0370 =   880          _runtime.asm:691 (unused)
M8_C__c42_            = $02D8 =   728          _runtime.asm:357 (unused)
M8_C__c42__end        = $02DB =   731          _runtime.asm:359 (unused)
M8_C__c43__c33_       = $0286 =   646          _runtime.asm:212 (unused)
M8_C__c43__c33__end   = $028F =   655          _runtime.asm:222 (unused)
M8_C__c45_            = $0229 =   553          _runtime.asm:57 (unused)
M8_C__c45__end        = $0230 =   560          _runtime.asm:64 (unused)
M8_C__c47_            = $0246 =   582          _runtime.asm:122 (unused)
M8_C__c47__end        = $024D =   589          _runtime.asm:128 (unused)
M8_C__c60_            = $0208 =   520          _runtime.asm:19 (unused)
M8_C__c60__end        = $021D =   541          _runtime.asm:38 (unused)
M8_C__c61_            = $021D =   541          _runtime.asm:42 (unused)
M8_C__c61__end        = $0229 =   553          _runtime.asm:53 (unused)
M8_C_abs              = $0383 =   899          _runtime.asm:711 (unused)
M8_C_abs_end          = $0389 =   905          _runtime.asm:715 (unused)
M8_C_and              = $0231 =   561          _runtime.asm:74 (unused)
M8_C_and_end          = $0238 =   568          _runtime.asm:82 (unused)
M8_C_boot             = $0202 =   514          _runtime.asm:2 (unused)
M8_C_copy             = $02A6 =   678          _runtime.asm:275 (unused)
M8_C_copy_end         = $02C3 =   707          _runtime.asm:306 (unused)
M8_C_fill             = $02C3 =   707          _runtime.asm:310 (unused)
M8_C_fill_end         = $02D3 =   723          _runtime.asm:328 (unused)
M8_C_halt             = $02D3 =   723          _runtime.asm:332 (unused)
M8_C_halt_end         = $02D7 =   727          _runtime.asm:337 (unused)
M8_C_mod              = $024D =   589          _runtime.asm:132 (unused)
M8_C_mod_end          = $0253 =   595          _runtime.asm:137 (unused)
M8_C_not              = $038C =   908          _runtime.asm:727 (unused)
M8_C_not_end          = $0393 =   915          _runtime.asm:735 (unused)
M8_C_or               = $0238 =   568          _runtime.asm:86 (unused)
M8_C_or_end           = $023F =   575          _runtime.asm:94 (unused)
M8_C_p_c33_           = $029C =   668          _runtime.asm:251 (unused)
M8_C_p_c33__end       = $02A6 =   678          _runtime.asm:261 (unused)
M8_C_p_c64_           = $0293 =   659          _runtime.asm:239 (unused)
M8_C_p_c64__end       = $029C =   668          _runtime.asm:247 (unused)
M8_C_random           = $03A2 =   930          _runtime.asm:757 (unused)
M8_C_spr_c46_reset    = $03C3 =   963          _runtime.asm:818 (unused)
M8_C_spr_c46_reset_end = $03EC =  1004          _runtime.asm:851 (unused)
M8_C_spr_c46_select   = $03EC =  1004          _runtime.asm:860 (unused)
M8_C_spr_c46_select_end = $040D =  1037          _runtime.asm:887 (unused)
M8_C_spr_c46_update   = $040D =  1037          _runtime.asm:895 (unused)
M8_C_spr_c46_update_end = $040D =  1037          _runtime.asm:900 (unused)
M8_C_strlen           = $0393 =   915          _runtime.asm:739 (unused)
M8_C_strlen_end       = $03A2 =   930          _runtime.asm:753 (unused)
M8_C_xor              = $023F =   575          _runtime.asm:98 (unused)
M8_C_xor_end          = $0246 =   582          _runtime.asm:106 (unused)
M8_M_16_c42_          = $0351 =   849          _runtime.asm:658 (unused)
M8_M_16_c42__end      = $0355 =   853          _runtime.asm:663 (unused)
M8_M_256_c42_         = $0355 =   853          _runtime.asm:665 (unused)
M8_M_256_c42__end     = $0358 =   856          _runtime.asm:668 (unused)
M8_M_256_c47_         = $0380 =   896          _runtime.asm:704 (unused)
M8_M_256_c47__end     = $0383 =   899          _runtime.asm:707 (unused)
M8_M_2_c42_           = $034B =   843          _runtime.asm:643 (unused)
M8_M_2_c42__end       = $034C =   844          _runtime.asm:645 (unused)
M8_M_2_c47_           = $0358 =   856          _runtime.asm:672 (unused)
M8_M_2_c47__end       = $035C =   860          _runtime.asm:675 (unused)
M8_M_4_c42_           = $034C =   844          _runtime.asm:647 (unused)
M8_M_4_c42__end       = $034E =   846          _runtime.asm:650 (unused)
M8_M_4_c47_           = $035C =   860          _runtime.asm:677 (unused)
M8_M_4_c47__end       = $0364 =   868          _runtime.asm:682 (unused)
M8_M_8_c42_           = $034E =   846          _runtime.asm:652 (unused)
M8_M_8_c42__end       = $0351 =   849          _runtime.asm:656 (unused)
M8_M__c33_            = $027E =   638          _runtime.asm:194 (unused)
M8_M__c33__end        = $0282 =   642          _runtime.asm:199 (unused)
M8_M__c43_            = $0230 =   560          _runtime.asm:68 (unused)
M8_M__c43__c43_       = $0330 =   816          _runtime.asm:595 (unused)
M8_M__c43__c43__c43_  = $0331 =   817          _runtime.asm:601 (unused)
M8_M__c43__c43__c43__end = $0333 =   819          _runtime.asm:604 (unused)
M8_M__c43__c43__end   = $0331 =   817          _runtime.asm:597 (unused)
M8_M__c43__end        = $0231 =   561          _runtime.asm:70 (unused)
M8_M__c45__c45_       = $032F =   815          _runtime.asm:589 (unused)
M8_M__c45__c45__c45_  = $032D =   813          _runtime.asm:582 (unused)
M8_M__c45__c45__c45__end = $032F =   815          _runtime.asm:585 (unused)
M8_M__c45__c45__end   = $0330 =   816          _runtime.asm:591 (unused)
M8_M__c64_            = $0282 =   642          _runtime.asm:203 (unused)
M8_M__c64__end        = $0286 =   646          _runtime.asm:208 (unused)
M8_M_a_c62_b          = $02F6 =   758          _runtime.asm:406 (unused)
M8_M_a_c62_b_end      = $02F8 =   760          _runtime.asm:409 (unused)
M8_M_a_c62_c          = $02F8 =   760          _runtime.asm:411 (unused)
M8_M_a_c62_c_end      = $02FA =   762          _runtime.asm:414 (unused)
M8_M_a_c62_r          = $0311 =   785          _runtime.asm:484 (unused)
M8_M_a_c62_r_end      = $0312 =   786          _runtime.asm:486 (unused)
M8_M_a_c62_x          = $0302 =   770          _runtime.asm:443 (unused)
M8_M_a_c62_x_end      = $0305 =   773          _runtime.asm:446 (unused)
M8_M_a_c62_y          = $0308 =   776          _runtime.asm:453 (unused)
M8_M_a_c62_y_end      = $030B =   779          _runtime.asm:456 (unused)
M8_M_ab_c62_r         = $0317 =   791          _runtime.asm:515 (unused)
M8_M_ab_c62_r_end     = $0319 =   793          _runtime.asm:518 (unused)
M8_M_abc_c62_r        = $031B =   795          _runtime.asm:527 (unused)
M8_M_abc_c62_r_end    = $031E =   798          _runtime.asm:531 (unused)
M8_M_b_c62_a          = $02FA =   762          _runtime.asm:418 (unused)
M8_M_b_c62_a_end      = $02FC =   764          _runtime.asm:421 (unused)
M8_M_b_c62_c          = $02FC =   764          _runtime.asm:423 (unused)
M8_M_b_c62_c_end      = $02FE =   766          _runtime.asm:426 (unused)
M8_M_b_c62_r          = $0313 =   787          _runtime.asm:494 (unused)
M8_M_b_c62_r_end      = $0314 =   788          _runtime.asm:496 (unused)
M8_M_bc_c62_r         = $0321 =   801          _runtime.asm:542 (unused)
M8_M_bc_c62_r_end     = $0323 =   803          _runtime.asm:545 (unused)
M8_M_break            = $02D7 =   727          _runtime.asm:341 (unused)
M8_M_break_end        = $02D8 =   728          _runtime.asm:343 (unused)
M8_M_bswap            = $0389 =   905          _runtime.asm:719 (unused)
M8_M_bswap_end        = $038C =   908          _runtime.asm:723 (unused)
M8_M_c_c33_           = $028F =   655          _runtime.asm:226 (unused)
M8_M_c_c33__end       = $0290 =   656          _runtime.asm:228 (unused)
M8_M_c_c62_a          = $02FE =   766          _runtime.asm:430 (unused)
M8_M_c_c62_a_end      = $0300 =   768          _runtime.asm:433 (unused)
M8_M_c_c62_b          = $0300 =   768          _runtime.asm:435 (unused)
M8_M_c_c62_b_end      = $0302 =   770          _runtime.asm:438 (unused)
M8_M_c_c62_r          = $0315 =   789          _runtime.asm:504 (unused)
M8_M_c_c62_r_end      = $0316 =   790          _runtime.asm:506 (unused)
M8_M_c_c64_           = $0290 =   656          _runtime.asm:232 (unused)
M8_M_c_c64__end       = $0293 =   659          _runtime.asm:235 (unused)
M8_M_pop              = $030F =   783          _runtime.asm:477 (unused)
M8_M_pop_end          = $0311 =   785          _runtime.asm:480 (unused)
M8_M_push             = $030E =   782          _runtime.asm:473 (unused)
M8_M_push_end         = $030F =   783          _runtime.asm:475 (unused)
M8_M_r_c62_a          = $0312 =   786          _runtime.asm:488 (unused)
M8_M_r_c62_a_end      = $0313 =   787          _runtime.asm:490 (unused)
M8_M_r_c62_ab         = $0319 =   793          _runtime.asm:520 (unused)
M8_M_r_c62_ab_end     = $031B =   795          _runtime.asm:523 (unused)
M8_M_r_c62_abc        = $031E =   798          _runtime.asm:533 (unused)
M8_M_r_c62_abc_end    = $0321 =   801          _runtime.asm:537 (unused)
M8_M_r_c62_b          = $0314 =   788          _runtime.asm:498 (unused)
M8_M_r_c62_b_end      = $0315 =   789          _runtime.asm:500 (unused)
M8_M_r_c62_bc         = $0323 =   803          _runtime.asm:547 (unused)
M8_M_r_c62_bc_end     = $0325 =   805          _runtime.asm:550 (unused)
M8_M_r_c62_c          = $0316 =   790          _runtime.asm:508 (unused)
M8_M_r_c62_c_end      = $0317 =   791          _runtime.asm:510 (unused)
M8_M_r_c62_x          = $0327 =   807          _runtime.asm:558 (unused)
M8_M_r_c62_x_end      = $0329 =   809          _runtime.asm:560 (unused)
M8_M_r_c62_y          = $032B =   811          _runtime.asm:568 (unused)
M8_M_r_c62_y_end      = $032D =   813          _runtime.asm:570 (unused)
M8_M_swap             = $02F5 =   757          _runtime.asm:400 (unused)
M8_M_swap_end         = $02F6 =   758          _runtime.asm:402 (unused)
M8_M_x_c62_a          = $0305 =   773          _runtime.asm:448 (unused)
M8_M_x_c62_a_end      = $0308 =   776          _runtime.asm:451 (unused)
M8_M_x_c62_r          = $0325 =   805          _runtime.asm:554 (unused)
M8_M_x_c62_r_end      = $0327 =   807          _runtime.asm:556 (unused)
M8_M_y_c62_a          = $030B =   779          _runtime.asm:458 (unused)
M8_M_y_c62_a_end      = $030E =   782          _runtime.asm:461 (unused)
M8_M_y_c62_r          = $0329 =   809          _runtime.asm:564 (unused)
M8_M_y_c62_r_end      = $032B =   811          _runtime.asm:566 (unused)
MULTMultiply16        = $02DB =   731          _runtime.asm:367
SPMCount              = $040F =  1039          _runtime.asm:904
SPMCurrent            = $0411 =  1041          _runtime.asm:906
SPMData               = $040D =  1037          _runtime.asm:902
SPMReset              = $03C3 =   963          _runtime.asm:820 (unused)
SPMSelect             = $03EC =  1004          _runtime.asm:862 (unused)
SPMUpdate             = $040D =  1037          _runtime.asm:897 (unused)
SPRAdjustUsageCounter = $063C =  1596          _runtime.asm:1468
SPRDataBlock          = $0700 =  1792          _runtime.asm:1570
SPRDataBlockEnd       = $0B00 =  2816          _runtime.asm:1592
SPRFlipDE             = $0658 =  1624          _runtime.asm:1500
SPRHighAddress        = $0A00 =  2560          _runtime.asm:1589
SPRInitialise         = $0413 =  1043          _runtime.asm:999
SPRLowAddress         = $0900 =  2304          _runtime.asm:1587
SPROriginalChar       = $0700 =  1792          _runtime.asm:1576
SPRUsageCount         = $0800 =  2048          _runtime.asm:1582
SPRcontrol            = $0006 =     6          _runtime.asm:986
SPRgraphics           = $0004 =     4          _runtime.asm:985
SPRstatus             = $0007 =     7          _runtime.asm:988
SPRx                  = $0000 =     0          _runtime.asm:983
SPRy                  = $0002 =     2          _runtime.asm:984
SpriteXDraw           = $042E =  1070          _runtime.asm:1032 (unused)
SpriteXErase          = $0435 =  1077          _runtime.asm:1036 (unused)
SpriteXToggle         = $043A =  1082          _runtime.asm:1039
_SLNExit              = $03A0 =   928          _runtime.asm:750
_SLNLoop              = $0398 =   920          _runtime.asm:743
_SPMClear             = $03D0 =   976          _runtime.asm:830
_SPMClear2            = $03D2 =   978          _runtime.asm:832
_SPMSExit             = $0406 =  1030          _runtime.asm:881
_SPMSFail             = $0403 =  1027          _runtime.asm:879
_SPRAOFind            = $05FB =  1531          _runtime.asm:1404
_SPRAOFound           = $0605 =  1541          _runtime.asm:1415
_SPRARNotErasing      = $059B =  1435          _runtime.asm:1319
_SPRAdjustGraphicPtr  = $050B =  1291          _runtime.asm:1190
_SPRAllocSPTemp       = $0692 =  1682          _runtime.asm:1555
_SPRAllocateExit      = $05E7 =  1511          _runtime.asm:1381
_SPRAllocateOkay      = $05E6 =  1510          _runtime.asm:1379
_SPRAllocateOne       = $05EF =  1519          _runtime.asm:1394
_SPRAllocateOneExit   = $062B =  1579          _runtime.asm:1444
_SPRAllocateRow       = $0584 =  1412          _runtime.asm:1305
_SPRAllocateUndo      = $05C5 =  1477          _runtime.asm:1349
_SPRAuNotRight        = $04F9 =  1273          _runtime.asm:1171
_SPRCalcPosition      = $0466 =  1126          _runtime.asm:1074
_SPRCalculateDefinitionAddr = $0635 =  1589          _runtime.asm:1454
_SPRDecrementUsage    = $0649 =  1609          _runtime.asm:1476
_SPRDrawEnd           = $0547 =  1351          _runtime.asm:1244
_SPRExit              = $0575 =  1397          _runtime.asm:1282
_SPRFetchGraphicPtr   = $04FB =  1275          _runtime.asm:1178
_SPRFineHorizontalShift = $051D =  1309          _runtime.asm:1203
_SPRFirstUDGSprite    = $0694 =  1684          _runtime.asm:1558
_SPRFlipA             = $066A =  1642          _runtime.asm:1516
_SPRFlipLow           = $0673 =  1651          _runtime.asm:1524
_SPRFlipTable         = $0680 =  1664          _runtime.asm:1539
_SPRHaveGraphicData   = $050B =  1291          _runtime.asm:1188
_SPRInitialYOffset    = $0691 =  1681          _runtime.asm:1552
_SPRLeftUDGPosition   = $0530 =  1328          _runtime.asm:1228
_SPRMiddleUDGPosition = $0535 =  1333          _runtime.asm:1232
_SPRNextRowUDG        = $04FB =  1275          _runtime.asm:1176
_SPRNoHFlip           = $051B =  1307          _runtime.asm:1200
_SPRRangeFail         = $0463 =  1123          _runtime.asm:1069
_SPRRightUDGPosition  = $0541 =  1345          _runtime.asm:1239
_SPRRowCount          = $0690 =  1680          _runtime.asm:1549
_SPRSGANotDoubleHeight = $04CB =  1227          _runtime.asm:1141
_SPRSGANotDoubleWidth = $04B9 =  1209          _runtime.asm:1129
_SPRSGANotVFlip       = $04D7 =  1239          _runtime.asm:1151
_SPRSingleHeight      = $04A6 =  1190          _runtime.asm:1118
_SPRStartNextCharacterRow = $04DE =  1246          _runtime.asm:1157
_SPRUsageReset        = $0426 =  1062          _runtime.asm:1018
_SPRZeroBlock         = $0418 =  1048          _runtime.asm:1006
__Core__Mult_Loop     = $02E2 =   738          _runtime.asm:373
__Core__Mult_Shift    = $02E7 =   743          _runtime.asm:377
__copy_exit           = $02BF =   703          _runtime.asm:301
__copy_gt_count       = $02BC =   700          _runtime.asm:298
__fill_loop           = $02C8 =   712          _runtime.asm:317
__halt_loop           = $02D3 =   723          _runtime.asm:333
__less_returnc        = $0216 =   534          _runtime.asm:32
__less_samesign       = $0211 =   529          _runtime.asm:27
__negate              = $0333 =   819          _runtime.asm:609
_end                  = $0B00 =  2816          :1 (unused)
_randomSeed1          = $03BF =   959          _runtime.asm:779
_randomSeed2          = $03C1 =   961          _runtime.asm:781
_size                 = $08FE =  2302          :1 (unused)


total time: 0.0081 sec.
no errors
