              	; --------------------------------------
              	; zasm: assemble "_demo.asm"
              	; date: 2021-11-02 12:09:30
              	; --------------------------------------


              	
0202:         			org 	$202
              	
              	;
              	;	 	Defining SPRLowSprite sets the lowest UDG used by sprites. This is a constant
              	; 		so if this is $A0, then $00-$9F are background, and $A0-$FF are used for sprites.
              	;
0080:         	SPRLowSprite = $80 								
              	
0008:         	SpriteCount = 8	
              	
0202: C30009  			jp 		start
              	
              			.include "xsprite.asm"
              	; *********************************************************************************************
              	; *********************************************************************************************
              	;
              	;		Name:		xsprite.asm
              	;		Purpose:	XOR Sprite Drawer
              	;		Created:	29th October 2021
              	;		Author:		Paul Robson (paul@robsons.org.uk)
              	;
              	; *********************************************************************************************
              	; *********************************************************************************************
              	
              	; *********************************************************************************************
              	;
              	;		This is an XOR drawing sprite system. This is useful because the draw is self
              	;		cancelling, and this means you don't have to repaint multiple sprites to restore
              	; 		the display state. The downside is that it doesn't work well on collisions or 
              	; 		especially backgrounds.
              	;
              	;		The original design, which was a simpler draw all/erase all design, was binned 
              	;		because I thought on real hardware it would create too much flash on the display.
              	;
              	;		I don't yet have a real machine so can't evaluate this in practice, as the emulator
              	; 		snapshots the display at 60Mhz, so the effects of endlessly messing with the 
              	;		CRAM and VRAM is largely hidden.
              	;
              	;		At 4Mhz it does about 330 draws/erases a second on a 16x16 sprites, twice as fast on
              	;		8 pixel high sprites.
              	;
              	;		It eats UDGs - a single 16x16 sprite needs 9 UDGs if it doesn't overlap with another.
              	;
              	; *********************************************************************************************
              	;
              	;		How it works. 
              	;
              	;			When drawing a sprite, it will try to allocate UDGs from its pool for the space
              	; 			to draw the sprite. When drawing or erasing it then XORs the bit patterns into this
              	; 			as far as it can. When erased, UDGs are returned to the pool if no longer required.
              	;
              	; *********************************************************************************************
              	;
              	;		Offsets from IX.
              	;
              	;			+0,+1 		Horizontal position (0..319)
              	;			+2,+3 		Vertical position (0..239)
              	;			+4,+5 		Pointer to graphic image data.
              	;							Width : 8  	one byte per row
              	;							Width : 16 	two bytes per row left-right order
              	;			+6 			Control
              	;							Bit 7: 		Set if sprite disabled
              	;							Bit 6: 		Vertical flip
              	;							Bit 5:		Horizontal flip
              	;							Bit 4..2:	0
              	;							Bit 1:		Double width
              	;							Bit 0: 		Double height
              	;			+7 			Status
              	;							Bit 7:		Set when drawn on screen
              	;							Bit 6..0:	0
              	;
              	;			Changes should only be made when the sprite is not drawn, otherwise chaos
              	;			will ensue.
              	;
              	;			Draws will not fail, however, they may not visually work either. If there are more
              	;			UDGs required than available graphics will not be drawn, or possibly drawn
              	;			erratically. It is advised to minimise the number of sprites both for CPU time
              	;			and UDG usage. 
              	;
              	;			Use specific UDGs for static/slow objects. For (say) Pacman the only sprites should
              	;			be the player character and chasing ghosts.
              	;
              	; *********************************************************************************************
              	;
              	;								  Sprite Record entries
              	;
              	; *********************************************************************************************
              	
0000:         	SPRx 	= 0 								; horizontal position, pixels
0002:         	SPRy 	= 2 								; vertical position, pixels
0004:         	SPRgraphics = 4 							; bitmap data
0006:         	SPRcontrol = 6 								; 0:width 1:height 5:HFlip 6:VFlip 7:hidden
              												; (others are zero)
0007:         	SPRstatus = 7 								; 7:currently drawn
              	
              	; *********************************************************************************************
              	;
              	; 								Initialise the sprite system.
              	;
              	; 	At this point sprite records should all have their "currently drawn" bit clear, it will
              	; 	get very confused otherwise.
              	;
              	; *********************************************************************************************
              	
0205:         	SPRInitialise:
0205: F5      			push 	af
0206: E5      			push 	hl
              			;
              			; 		Clear the main data area.
              			;
0207: 210005  			ld 		hl,SPRDataBlock 			
020A:         	_SPRZeroBlock:
020A: 3600    			ld 		(hl),$00
020C: 23      			inc 	hl
020D: 7C      			ld 		a,h
020E: FE09    			cp 		SPRDataBlockEnd >> 8
0210: 20F8    			jr 		nz,_SPRZeroBlock
              			;
              			; 		Set all possible original characters to $FF, indicating they are available.
              			;		
0212: 218005  			ld 		hl,SPROriginalChar+SPRLowSprite
0215:         	_SPRUsageReset:			 					
0215: 36FF    			ld 		(hl),$FF
0217: 2C      			inc 	l
0218: 20FB    			jr 		nz,_SPRUsageReset
021A: E1      			pop 	hl
021B: F1      			pop 	af
021C: C9      			ret
              	
              	; *********************************************************************************************
              	;
              	;						Draw, or Erase, the sprite whose raw data is at IX
              	;
              	; *********************************************************************************************
              	
021D:         	SpriteXDraw: 								; draw only
021D: DDCB077E			bit 	7,(ix+SPRstatus)
0221: C0      			ret 	nz
0222: 1805    			jr 		SpriteXToggle
0224:         	SpriteXErase:								; erase only
0224: DDCB077E			bit 	7,(ix+SPRstatus)
0228: C8      			ret 	z
0229:         	SpriteXToggle:								; flip state
0229: F5      			push 	af 							; save registers 							
022A: C5      			push 	bc
022B: D5      			push 	de
022C: E5      			push 	hl
022D: FDE5    			push 	iy
              			;
              			; 		Check actually visible
              			;
022F: DDCB067E			bit 	7,(ix+SPRcontrol)
0233: C26403  			jp 		nz,_SPRExit
              			;
              			; 		Check range.
              			;
0236: DD7E01  			ld 		a,(ix+SPRx+1) 				; MSB of X must be 0 or 1
0239: 47      			ld 		b,a 						; save in B
023A: E6FE    			and 	$FE
023C: DDB603  			or 		a,(ix+SPRy+1) 				; MSB of Y must be zero.
023F: 2011    			jr 		nz,_SPRRangeFail
              			;
0241: DD7E02  			ld 		a,(ix+SPRy) 				; check Y < 240
0244: FEF0    			cp 		8*30
0246: 300A    			jr 		nc,_SPRRangeFail
              			;
0248: 05      			dec 	b 							; if MSB X was 1, now zero
0249: 200A    			jr 		nz,_SPRCalcPosition 
              			;
024B: DD7E00  			ld 		a,(ix+SPRx) 				; X.MSB was 1, so must be X.LSB < 64
024E: FE40    			cp 		64
0250: 3803    			jr 		c,_SPRCalcPosition
0252:         	_SPRRangeFail:
0252: C36403  			jp 		_SPRExit 	
              			;
              			;		Calculate position in IY
              			;
0255:         	_SPRCalcPosition:		
0255: 2600    			ld 		h,0							; Y position in HL, with lower 3 bits masked, so already x 8
0257: DD7E02  			ld 		a,(ix+SPRy)
025A: E6F8    			and 	$F8
025C: 6F      			ld 		l,a
025D: 54      			ld 		d,h 						; DE = Y x 8
025E: 5D      			ld 		e,l
025F: 29      			add 	hl,hl 						; HL = Y x 32
0260: 29      			add 	hl,hl
0261: 19      			add 	hl,de 						; HL = Y x 40
0262: FD2100F8			ld 		iy,$F800 					; IY = $F800 + Y x 40
0266: EB      			ex 		de,hl
0267: FD19    			add 	iy,de
              	
0269: DD5E00  			ld 		e,(ix+SPRx)					; DE = X position
026C: DD5601  			ld 		d,(ix+SPRx+1)
026F: CB3A    			srl 	d 							; / 8 (after first in range 0-255 hence SRL E)
0271: CB1B    			rr 		e
0273: CB3B    			srl 	e
0275: CB3B    			srl 	e
0277: 1600    			ld 		d,0 						; add to screen position.
0279: FD19    			add 	iy,de
              			;
              			; 		Calculate and patch the fine horizontal shift jump which adjusts the 
              			; 		number of 24 bit left shifts we do to the graphics data.
              			;
027B: DD7E00  			ld 		a,(ix+SPRx)
027E: E607    			and 	7
0280: 87      			add 	a,a
0281: 320D03  			ld 		(_SPRFineHorizontalShift+1),a 
              			;
              			; 		Calculate the horizontal offset which makes it start drawing part way through a UDG
              			;
0284: DD7E02  			ld 		a,(ix+SPRy)
0287: E607    			and 	7
0289: 328104  			ld 		(_SPRInitialYOffset),a
              			;
              			; 		Calculate the row count from bit 1 of the control byte
              			; 		(the number of vertical pixels down)
              			;
028C: 3E08    			ld 		a,8
028E: DDCB064E			bit 	1,(ix+SPRcontrol)
0292: 2801    			jr 		z,_SPRSingleHeight
0294: 87      			add 	a,a
0295:         	_SPRSingleHeight:		
0295: 328004  			ld 		(_SPRRowCount),a
              			;
              			;		Set the sprite graphic address and incrementer.
              			;
0298: DD6E04  			ld 		l,(ix+SPRgraphics) 			; data address
029B: DD6605  			ld 		h,(ix+SPRgraphics+1) 		
029E: 110100  			ld 		de,1 						; increment/decrement
02A1: DDCB0646			bit 	0,(ix+SPRcontrol)
02A5: 2801    			jr 		z,_SPRSGANotDoubleWidth
02A7: 13      			inc 	de 							; 2 if double width
02A8:         	_SPRSGANotDoubleWidth:
02A8: DDCB0676			bit 	6,(ix+SPRcontrol) 			; check for vertical flip.
02AC: 2818    			jr 		z,_SPRSGANotVFlip
              			;
02AE: EB      			ex 		de,hl 						; DE = address, HL = increment x 8
02AF: E5      			push 	hl
02B0: 29      			add 	hl,hl
02B1: 29      			add 	hl,hl
02B2: 29      			add 	hl,hl
02B3: DDCB064E			bit 	1,(ix+SPRcontrol) 			; x 16 if double height
02B7: 2801    			jr 		z,_SPRSGANotDoubleHeight
02B9: 29      			add 	hl,hl		
02BA:         	_SPRSGANotDoubleHeight:
02BA: 19      			add 	hl,de 						; add 8/16 x increment to start
02BB: C1      			pop 	bc 							; original increment -> BC
02BC: E5      			push 	hl 							; save new start on stack.
02BD: 210000  			ld 		hl,0 						; HL = - increment
02C0: AF      			xor 	a
02C1: ED42    			sbc 	hl,bc
02C3: D1      			pop 	de 							; DE = new start off stack
02C4: EB      			ex 		de,hl 						; swap them back so HL = address, DE = -increment
02C5: 19      			add 	hl,de 						; points HL to the last sprite entry.
02C6:         	_SPRSGANotVFlip:
02C6: 22EB02  			ld 		(_SPRFetchGraphicPtr+1),hl 	; write out start address in HL and incrementer in DE.		
02C9: ED53FB02			ld 		(_SPRAdjustGraphicPtr+1),de
              			;
              			; 		Try to allocate UDGs for the current row at IY, 2 or 3 UDGs.
              			;
02CD:         	_SPRStartNextCharacterRow:
02CD: CD7303  			call 	_SPRAllocateRow 			; try to allocate the whole row.
02D0: DA6403  			jp 		c,_SPRExit					; it didn't work, so we abandon drawing here.
              			;
              			; 		Adjust the usage counters.
              			;
02D3: FDE5    			push 	iy
02D5: CD2604  			call 	SPRAdjustUsageCounter
02D8: FD23    			inc 	iy
02DA: CD2604  			call 	SPRAdjustUsageCounter
02DD: DDCB0646			bit 	0,(ix+SPRcontrol)
02E1: 2805    			jr 		z,_SPRAuNotRight
02E3: FD23    			inc 	iy
02E5: CD2604  			call 	SPRAdjustUsageCounter
02E8:         	_SPRAuNotRight:
02E8: FDE1    			pop 	iy		
              			;
              			;		Get the graphics for the next *pixel* line. into ADE
              			;
02EA:         	_SPRNextRowUDG:		
              			;
02EA:         	_SPRFetchGraphicPtr:
02EA: 210000  			ld 		hl,$0000
02ED: 1E00    			ld 		e,0							; DE = $00:(HL)
02EF: 56      			ld 		d,(hl)
02F0: DDCB0646			bit 	0,(ix+SPRcontrol) 			; is the width 1 ?
02F4: 2804    			jr 		z,_SPRHaveGraphicData
02F6: 23      			inc 	hl
02F7: 5A      			ld 		e,d  						; DE = (HL+1):(HL)		
02F8: 56      			ld 		d,(hl)
02F9: 2B      			dec 	hl		
02FA:         	_SPRHaveGraphicData:		
              			;
02FA:         	_SPRAdjustGraphicPtr:
02FA: 010000  			ld 		bc,$0000 					; this is changed to account for size and
02FD: 09      			add 	hl,bc 						; direction.
02FE: 22EB02  			ld 		(_SPRFetchGraphicPtr+1),hl		
              			;
              			; 		Check for Horizontal Flip
              			;
0301: DDCB066E			bit 	5,(ix+SPRcontrol)			; if HFlip bit set
0305: 2803    			jr 		z,_SPRNoHFlip
0307: CD4204  			call 	SPRFlipDE 					; Flip DE
030A:         	_SPRNoHFlip:		
030A: AF      			xor 	a 							; ADE contains 24 bit graphic data.
030B: EB      			ex 		de,hl 						; we put it in AHL
030C:         	_SPRFineHorizontalShift:		
030C: 1800    			jr 		$+2 						; this is altered to do the fine horizontal shift
030E: 29      			add 	hl,hl
030F: 8F      			adc 	a,a
0310: 29      			add 	hl,hl
0311: 8F      			adc 	a,a
0312: 29      			add 	hl,hl
0313: 8F      			adc 	a,a
0314: 29      			add 	hl,hl
0315: 8F      			adc 	a,a
0316: 29      			add 	hl,hl
0317: 8F      			adc 	a,a
0318: 29      			add 	hl,hl
0319: 8F      			adc 	a,a
031A: 29      			add 	hl,hl
031B: 8F      			adc 	a,a
031C: 29      			add 	hl,hl
031D: 8F      			adc 	a,a
031E: EB      			ex 		de,hl 						; put it back in ADE
              			;
              			;		Now XOR the data with the previously calculated addresses. 
              			;		If (ix+5)[0] is clear then don't do the third one, it's an 8x8 sprite
              			;
              			;		These addresses (the ld hl,xxxx ones) are modified in situ.
              			;
031F:         	_SPRLeftUDGPosition:		
031F: 2108F6  			ld 		hl,$F000+$C1*8
0322: AE      			xor 	(hl)
0323: 77      			ld 		(hl),a
0324:         	_SPRMiddleUDGPosition:		
0324: 2110F6  			ld 		hl,$F000+$C2*8
0327: 7A      			ld 		a,d
0328: AE      			xor 	(hl)
0329: 77      			ld 		(hl),a
032A: DDCB0646			bit 	0,(ix+SPRcontrol) 					; if width 1, skip the last draw
032E: 2806    			jr 		z,_SPRDrawEnd
0330:         	_SPRRightUDGPosition:		
0330: 2118F6  			ld 		hl,$F000+$C3*8
0333: 7B      			ld 		a,e
0334: AE      			xor 	(hl)
0335: 77      			ld 		(hl),a
0336:         	_SPRDrawEnd:
              			;
              			; 		Check if we have done all the rows
              			;
0336: 218004  			ld 		hl,_SPRRowCount 
0339: 35      			dec 	(hl)
033A: 2828    			jr 		z,_SPRExit
              			;
              			; 		Now go to the next line down. Initially this just advances the vertical offset
              			;		in the UDG pointers
              			;
033C: 212503  			ld 		hl,_SPRMiddleUDGPosition+1
033F: 34      			inc 	(hl)
0340: 213103  			ld 		hl,_SPRRightUDGPosition+1 	; not guaranteed initialised.
0343: 34      			inc 	(hl)
0344: 212003  			ld 		hl,_SPRLeftUDGPosition+1
0347: 34      			inc 	(hl)
              			;
0348: 7E      			ld 		a,(hl) 						; check crossed 8 byte boundary
0349: E607    			and 	7
034B: 209D    			jr 		nz,_SPRNextRowUDG 			; if not complete it.
              	
034D: AF      			xor 	a 							; clear the initial offset
034E: 328104  			ld 		(_SPRInitialYOffset),a
              	
              	
0351: 112800  			ld 		de,40 						; advance down one row.
0354: FD19    			add 	iy,de 
              	
0356: 11B0FC  			ld 		de,$F800+40*30 				; the end of the physical display
0359: FDE5    			push 	iy
035B: E1      			pop 	hl
035C: 37      			scf
035D: ED52    			sbc 	hl,de
035F: 3003    			jr 		nc,_SPRExit 				; past the bottom,exit.
              	
0361: C3CD02  			jp 		_SPRStartNextCharacterRow 	; do the next character row.
              	
0364:         	_SPRExit:
0364: DD7E07  			ld 		a,(ix+SPRstatus) 			; toggle the drawn status bit
0367: EE80    			xor 	$80
0369: DD7707  			ld 		(ix+SPRstatus),a 		
              	
036C: FDE1    			pop 	iy 							; restore registers
036E: E1      			pop 	hl
036F: D1      			pop 	de
0370: C1      			pop 	bc
0371: F1      			pop 	af
0372: C9      			ret
              	
              	; *********************************************************************************************
              	;
              	;		Allocate 0-3 UDGs to the character space according to need and availability.
              	; 		Fail with CS if can't.
              	;		If possible,
              	;			all new UDGs should have the copied graphic from the background and the
              	;			old background set up.
              	;			the UDGs should replace the graphics in IY.
              	;
              	; *********************************************************************************************
              	
0373:         	_SPRAllocateRow:
0373: C5      			push 	bc 							; save BC.
0374: FDE5    			push 	iy 							; save IY
0376: ED738204			ld 		(_SPRAllocSPTemp),sp		; save SP as we are using it for temp.
              	
037A: DDCB077E			bit 	7,(ix+SPRstatus) 			; are we erasing ?
037E: 2807    			jr 		z,_SPRARNotErasing
              	
0380: FD7E00  			ld 		a,(iy+0) 					; if erasing, check if row is drawn on UDGs
0383: FE80    			cp 		SPRLowSprite
0385: 384C    			jr 		c,_SPRAllocateExit 			; and if so don't allocate the row, exit.
              	
0387:         	_SPRARNotErasing:		
0387: 210000  			ld 		hl,$0000 					; we save all the allocated so far on the stack
038A: E5      			push 	hl 		 					; this is the end marker.					
              			;
              			; 		Do 2 or 3. For each overwrite the XOR code addresses and save
              			;		it on the stack. If it fails, then unwind everything.
              			;
038B: CDDB03  			call 	_SPRAllocateOne 			; do (IY)
038E: 3821    			jr 		c,_SPRAllocateUndo 			; if done, then Undo.
0390: 222003  			ld 		(_SPRLeftUDGPosition+1),hl 	; overwrite the code.
0393: E5      			push 	hl
              	
0394: FD23    			inc 	iy		
0396: CDDB03  			call 	_SPRAllocateOne 			; do (IY+1)
0399: 3816    			jr 		c,_SPRAllocateUndo 			; if done, then Undo.
039B: 222503  			ld 		(_SPRMiddleUDGPosition+1),hl ; overwrite the code.
039E: E5      			push 	hl
              	
039F: DDCB0646			bit 	0,(ix+SPRcontrol) 			; if 8 width then we are done.
03A3: 282D    			jr 		z,_SPRAllocateOkay 
              	
03A5: FD23    			inc 	iy		
03A7: CDDB03  			call 	_SPRAllocateOne 			; do (IY+2)
03AA: 3805    			jr 		c,_SPRAllocateUndo 			; if done, then Undo.
03AC: 223103  			ld 		(_SPRRightUDGPosition+1),hl ; overwrite the code.
03AF: 1821    			jr 		_SPRAllocateOkay 
              			;
              			; 		Failed, so pop the saved UDG addresses on the stack and reset
              			;	 	as if we hadn't allocated it. We haven't bumped the usage count yet.
              			;
03B1:         	_SPRAllocateUndo:
03B1: D1      			pop 	de 							; address of UDG into DE
03B2: 7A      			ld 		a,d 						; have we done the whole lot ?
03B3: B3      			or 		e
03B4: 37      			scf
03B5: 281C    			jr 		z,_SPRAllocateExit 			; if so, e.g. popped $0000 with carry set.
              	
03B7: CB3A    			srl 	d 							; divide by 8 - will put the UDG number into E
03B9: CB1B    			rr 		e
03BB: CB3A    			srl 	d
03BD: CB1B    			rr 		e
03BF: CB3A    			srl 	d
03C1: CB1B    			rr 		e
              			;
03C3: 6B      			ld 		l,e 						; HL is the address of the original character for this UDG.
03C4: 2605    			ld 		h,SPROriginalChar >> 8 		
03C6: 7E      			ld 		a,(hl) 						; character the UDG replaced
03C7: 36FF    			ld 		(hl),$FF 					; mark that UDG as now available
              	
03C9: 2607    			ld 		h,SPRLowAddress >> 8 		; get screen address into DE
03CB: 5E      			ld 		e,(hl)
03CC: 2608    			ld 		h,SPRHighAddress >> 8 
03CE: 56      			ld 		d,(hl)
              	
03CF: 12      			ld 		(de),a 						; fix up screen
              	
03D0: 18DF    			jr 		_SPRAllocateUndo 			; and see if there are any more to undo
              			;
              			; 		Worked, exit with carry clear.
              			;
03D2:         	_SPRAllocateOkay: 							; clear carry flag and exit.
03D2: AF      			xor 	a		
03D3:         	_SPRAllocateExit:
03D3: ED7B8204			ld 		sp,(_SPRAllocSPTemp)		; get SP back
03D7: FDE1    			pop 	iy 							; restore BC IY
03D9: C1      			pop 	bc				
03DA: C9      			ret
              	
              	; *********************************************************************************************
              	;
              	; 		Allocate a single UDG sprite, overwriting (IY), saving the original and copying
              	; 		the definition. On exit HL points to its graphic definition.
              	;
              	; *********************************************************************************************
              	
03DB:         	_SPRAllocateOne:
03DB: FD7E00  			ld 		a,(iy+0) 					; is it a UDG already
03DE: FE80    			cp 		SPRLowSprite 				; if so, we don't need to do anything.
03E0: 3033    			jr 		nc,_SPRAllocateOneExit
              			;
              			; 		Look for a free UDG, e.g. one where the stored character is $FF.
              			;
03E2: 218005  			ld 		hl,SPROriginalChar+SPRLowSprite
03E5:         	_SPRAOFind: 								; look for an available UDG.
03E5: 7E      			ld 		a,(hl)
03E6: FEFF    			cp 		$FF
03E8: 2805    			jr 		z,_SPRAOFound
03EA: 2C      			inc 	l
03EB: 20F8    			jr 		nz,_SPRAOFind		
03ED: 37      			scf 								; nope, we just can't do this one.
03EE: C9      			ret
              	;
              	;  		Found a sprite we can allocate
              	;
03EF:         	_SPRAOFound:
              			;
              			; 		Store the character overwritten by the UDG
              			;
03EF: FD7E00  			ld 		a,(iy+0) 					; this is the original character e.g. what is underneath
03F2: 77      			ld 		(hl),a 						; put in storage slot for original character
              			;
03F3: FDE5    			push 	iy 							; save the address of that character so we can restore it.
03F5: C1      			pop 	bc 							; when it drops to zero.
03F6: 2607    			ld 		h,SPRLowAddress >> 8
03F8: 71      			ld 		(hl),c
03F9: 2608    			ld 		h,SPRHighAddress >> 8
03FB: 70      			ld 		(hl),b
              			;
              			; 		Copy the graphic definition of the original character into the UDG.
              			;
              	
03FC: FD7E00  			ld 		a,(iy+0) 					; get the original character , e.g. the non UDG
03FF: FD7500  			ld 		(iy+0),l 					; override it.
              			;
0402: CD1F04  			call 	_SPRCalculateDefinitionAddr ; HL is the graphic of the original character
0405: EB      			ex 		de,hl
0406: FD7E00  			ld 		a,(iy+0) 					; HL is the graphic of the UDG
0409: CD1F04  			call 	_SPRCalculateDefinitionAddr
040C: EB      			ex 		de,hl 						; we want it copied there
040D: 010800  			ld 		bc,8 						; copy 8 bytes
0410: EDB0    			ldir
              	
0412: FD7E00  			ld 		a,(iy+0) 					; get the address of the UDG and exit with CC
0415:         	_SPRAllocateOneExit;
0415: CD1F04  			call 	_SPRCalculateDefinitionAddr ; get the definition address in HL
0418: 3A8104  			ld 		a,(_SPRInitialYOffset) 		; adjust for initial Y offset
041B: B5      			or 		l
041C: 6F      			ld 		l,a
041D: AF      			xor 	a 							; clear carry.
041E: C9      			ret 			
              	;
              	; 		A is a character #, point HL to CRAM Address
              	;
041F:         	_SPRCalculateDefinitionAddr:
041F: 6F      			ld 		l,a
0420: 261E    			ld 		h,$F0/8
0422: 29      			add 	hl,hl
0423: 29      			add 	hl,hl
0424: 29      			add 	hl,hl
0425: C9      			ret
              	
              	; *********************************************************************************************
              	;
              	;							Adjust usage counter for (IY)
              	;
              	; *********************************************************************************************
              	
0426:         	SPRAdjustUsageCounter:
0426: FD6E00  			ld 		l,(iy+0) 					; point HL to the usage counter
0429: 2606    			ld 		h,SPRUsageCount >> 8
042B: DDCB077E			bit 	7,(ix+SPRstatus)			; if drawn status is non-zero we are erasing
042F: 2002    			jr 		nz,_SPRDecrementUsage
0431: 34      			inc 	(hl)						; increment usage counter and exit
0432: C9      			ret
              	;
0433:         	_SPRDecrementUsage:
0433: 35      			dec 	(hl) 						; one fewer usage
0434: C0      			ret 	nz 							; still in use.
              			;
              			; 		Count zero, free up. Could consider delaying this until actually needed?
              			;
0435: 2607    			ld 		h,SPRLowAddress >> 8 		; display address in DE
0437: 5E      			ld 		e,(hl)
0438: 2608    			ld 		h,SPRHighAddress >> 8
043A: 56      			ld 		d,(hl)
043B: 2605    			ld 		h,SPROriginalChar >> 8 		; original character written to DE
043D: 7E      			ld 		a,(hl)
043E: 12      			ld 		(de),a 					
              	
043F: 36FF    			ld 		(hl),$FF 					; mark the UDG as free again.
0441: C9      			ret
              	
              	
              	; *********************************************************************************************
              	;
              	;						Flip ADE - byteflip D or DE and swap.
              	;
              	; *********************************************************************************************
              	
0442:         	SPRFlipDE:
0442: 7A      			ld 	 	a,d 						; flip D
0443: CD5404  			call 	_SPRFlipA
0446: 57      			ld 		d,a
0447: DDCB0646			bit 	0,(IX+SPRcontrol)  			; if width 1 exit.
044B: C8      			ret 	z
              	
044C: 6B      			ld 		l,e 						; save E
044D: 5F      			ld 		e,a 						; put flipped D into E
044E: 7D      			ld 		a,l 						; get old E, flip into D
044F: CD5404  			call 	_SPRFlipA
0452: 57      			ld 		d,a
0453: C9      			ret
              	;
              	; 		Flip A
              	;		
0454:         	_SPRFlipA:
0454: B7      			or 		a 							; shortcut, reverse zero.
0455: C8      			ret 	z
0456: CD5D04  			call 	_SPRFlipLow 				; flip the low nibble
0459: 0F      			rrca 								; swap halves
045A: 0F      			rrca
045B: 0F      			rrca
045C: 0F      			rrca 								; then fall through to flip high nibble.
045D:         	_SPRFlipLow:			
045D: F5      			push 	af 							; save original
045E: E60F    			and 	$0F 						; access the flip value.
0460: C670    			add 	_SPRFlipTable & $FF
0462: 6F      			ld 		l,a
0463: 2604    			ld 		h,_SPRFlipTable >> 8 
0465: F1      			pop 	af 							; restore original
0466: E6F0    			and 	$F0 						; replace lower nibble
0468: B6      			or 		(hl)
0469: C9      			ret
              	;
              	;		One Nibble Reversed.
              	;
046A: 00000000			.align 	16,0 						; all in one page.
046E: 0000    	
              	
0470:         	_SPRFlipTable:
0470: 0008040C			.db 	0,8,4,12,2,10,6,14
0474: 020A060E	
0478: 0109050D			.db 	1,9,5,13,3,11,7,15
047C: 030B070F	
              	
              	; *********************************************************************************************
              	;
              	; 									General Data
              	;
              	; *********************************************************************************************
              	
0480:         	_SPRRowCount: 								; down counter for completed rows.
0480: 00      			.db 	0
              	
0481:         	_SPRInitialYOffset: 						; the initial vertical offset.
0481: 00      			.db 	0
              	
0482:         	_SPRAllocSPTemp: 							; save SP when storing interim results on stack
0482: 0000    			.dw 	0
              	
              	; *********************************************************************************************
              	;
              	;		Sprite/UDG Specific Data. Each of these is a 256 byte array aligned
              	; 		on a page. This is a bit wasteful if you don't have many sprites but quicker.
              	;
              	; *********************************************************************************************
              	
0484: 00000000			.align 	256,0
0488: 00...   	
              	
0500:         	SPRDataBlock:
              	
              	;
              	;		This is the original value stored the UDG replaced. When $FF it means
              	; 		this UDG is not in use.
              	;
0500:         	SPROriginalChar:
0500: FFFFFFFF			.ds 	256
0504: FF...   	
              	;
              	;
              	; 		This is the number of sprites using the given UDG, indexed on zero.
              	;
0600:         	SPRUsageCount:
0600: FFFFFFFF			.ds 	256
0604: FF...   	
              	;
              	; 		The address of that replaced UDG. 
              	;
0700:         	SPRLowAddress:
0700: FFFFFFFF			.ds 	256
0704: FF...   	
0800:         	SPRHighAddress:
0800: FFFFFFFF			.ds 	256
0804: FF...   	
              	
0900:         	SPRDataBlockEnd:
              	
              	;
              	; 		Copy a lightweight pattern to the screen.
              	;
0900:         	start:
0900: 3100F0  			ld 		sp,$F000
0903: 21B0FC  			ld 		hl,$F800+40*30
0906: 2B      	_fill:	dec 	hl	
0907: 3620    	 		ld 		(hl),$20
0909: 7D      	 		ld 		a,l
090A: C602    	 		add 	a,2
090C: E603    	 		and 	3
090E: 2002    	 		jr 		nz,_fill3
0910: 3601    	 		ld 		(hl),1
0912:         	_fill3: 		
0912: CB5C    	 		bit 	3,h
0914: 20F0    	 		jr 		nz,_fill
              	
0916: 2108F0  	 		ld 		hl,$F008
0919: 3601    	_fill4:	ld 		(hl),1
091B: 23      			inc 	hl
091C: CB5D    			bit 	3,l
091E: 20F9    			jr 		nz,_fill4 		
              	
0920: 3E01    			ld 		a,1
0922: 3204F1  			ld 		($F000+32*8+4),a
0925: CD0502  	 		call 	SPRInitialise
              	
0928: DD21F709	 		ld 		ix,SpriteBuffer
092C: 0608    	 		ld 		b,SpriteCount
092E:         	_create:
092E: 78      			ld 		a,b
092F: 87      			add 	a,a
0930: 87      			add 	a,a		
0931: 87      			add 	a,a
0932: C608    			add 	a,8
0934: DD7700  			ld 		(ix+0),a
0937: DD360100			ld 		(ix+1),0
093B: 87      			add 	a,a
093C: DD7702  			ld 		(ix+2),a
093F: DD360300			ld 		(ix+3),0
0943: DD360497			ld 		(ix+4),SpriteGraphic & 0xFF
0947: DD36050A			ld 		(ix+5),SpriteGraphic >> 8
094B: DD360603			ld 		(ix+6),$3
094F: DD360700			ld 		(ix+7),0
0953: DD360801			ld 		(ix+8),1 				; xi
0957: CB40    			bit 	0,b
0959: 2804    			jr 		z,_create1
095B: DD3608FF			ld 		(ix+8),255 
095F:         	_create1:		
095F: DD360901			ld 		(ix+9),1 				; yi
0963: CB48    			bit 	1,b
0965: 2804    			jr 		z,_create2
0967: DD3609FF			ld 		(ix+9),255
096B:         	_create2:		
096B: 110A00  	 		ld 		de,10
096E: DD19    	 		add 	ix,de
0970: 10BC    	 		djnz 	_create
              	
0972: 210000  	 		ld 		hl,0
0975: 220001  	 		ld 		($0100),hl
              	
0978: DD21F709	_loop1:	ld 		ix,SpriteBuffer
097C: 0608    			ld 		b,SpriteCount
097E:         	_loop2:	
097E: CD2402  			call 	SpriteXErase
0981: CD9B09  			call 	moveOne
0984: CD1D02  			call 	SpriteXDraw
              	
0987: 2A0001  			ld 		hl,($0100)
098A: 23      			inc 	hl
098B: 23      			inc 	hl
098C: 220001  	 		ld 		($0100),hl
              	
098F: 110A00  	 		ld 		de,10
0992: DD19    	 		add 	ix,de
0994: 10E8    			djnz 	_loop2
0996: 18E0    			jr 		_loop1
              	
0998: F3      	_stop:	di
0999: 18FD    			jr		_stop 		
              	
099B:         	moveOne:
099B: DD7E08  			ld 		a,(ix+8)
099E: CDE009  			call 	advance
09A1: DD7708  			ld 		(ix+8),a
09A4: DD7E09  			ld 		a,(ix+9)
09A7: DDE5    			push 	ix
09A9: DD23    			inc 	ix
09AB: DD23    			inc 	ix
09AD: CDE009  			call 	advance
09B0: DDE1    			pop 	ix		
09B2: DD7709  			ld 		(ix+9),a
              	
09B5: DD7E06  			ld 		a,(ix+6)
09B8: E69F    			and 	#$9F
09BA: DDCB087E			bit 	7,(ix+8)
09BE: 2802    			jr 		z,_notright
09C0: CBEF    			set 	5,a
09C2:         	_notright:		
09C2: DDCB097E			bit 	7,(ix+9)
09C6: 2802    			jr 		z,_notleft
09C8: CBF7    			set 	6,a
09CA:         	_notleft:		
09CA: DD7706  			ld 		(ix+6),a
              	
09CD: 21970A  			ld 	 	hl,SpriteGraphic
09D0: DDCB0066			bit 	4,(ix+0)
09D4: 2803    			jr 		z,_anim1
09D6: 21B70A  			ld 		hl,SpriteGraphic2
09D9:         	_anim1:		
09D9: DD7504  			ld 		(ix+4),l
09DC: DD7405  			ld 		(ix+5),h
09DF: C9      			ret
              	
09E0: 4F      	advance:ld 		c,a
09E1: 87      			add 	a,a
09E2: 87      			add 	a,a
09E3: DD8600  			add 	a,(ix+0)
09E6: DD7700  			ld 		(ix+0),a
09E9: FE10    			cp 		16
09EB: 3806    			jr 		c,_adv2
09ED: FEF0    			cp 		240
09EF: 3002    			jr 		nc,_adv2
09F1: 79      			ld 		a,c
09F2: C9      			ret
09F3:         	_adv2:
09F3: 79      			ld 		a,c
09F4: ED44    			neg
09F6: C9      			ret
              	
              	; *********************************************************************************************
              	;										Test data
              	; *********************************************************************************************
              	
09F7:         	SpriteBuffer:		
09F7: FFFFFFFF			.ds 	SpriteCount * 20
09FB: FF...   	
              	
              	
0A97:         	SpriteGraphic:
0A97: F00F0810			.dw 	$0FF0,$1008,$2004,$4002,$8001,$8001,$8001,$8001
0A9B: 04200240	
0A9F: 01800180	
0AA3: 01800180	
0AA7: FF808080			.dw 	$80FF,$8080,$8080,$8080,$4080,$2080,$1080,$0F80
0AAB: 80808080	
0AAF: 80408020	
0AB3: 8010800F	
              	
0AB7:         	SpriteGraphic2:
0AB7: F00F0810			.dw 	$0FF0,$1008,$2004,$4002,$8001,$8001,$8001,$8001
0ABB: 04200240	
0ABF: 01800180	
0AC3: 01800180	
0AC7: 01800180			.dw 	$8001,$8001,$8001,$8001,$4002,$2004,$1008,$0FF0
0ACB: 01800180	
0ACF: 02400420	
0AD3: 0810F00F	
              	


total time: 0.0038 sec.
no errors
