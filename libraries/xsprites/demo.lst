              	; --------------------------------------
              	; zasm: assemble "_demo.asm"
              	; date: 2021-10-31 05:46:15
              	; --------------------------------------


              	
              	
              	
0202:         			org 	$202
              	
              	;
              	;	 	Defining SPRLowSprite sets the lowest UDG used by sprites. This is a constant
              	; 		so if this is $A0, then $00-$9F are background, and $A0-$FF are used for sprites.
              	;
0080:         	SPRLowSprite = $80 								
              	
000A:         	SpriteCount = 10
              	
0202: C30008  			jp 		start
              			.include "xsprite.asm"
              	; *********************************************************************************************
              	; *********************************************************************************************
              	;
              	;		Name:		xsprite.asm
              	;		Purpose:	XOR Sprite Drawer
              	;		Created:	29th October 2021
              	;		Author:		Paul Robson (paul@robsons.org.uk)
              	;
              	; *********************************************************************************************
              	; *********************************************************************************************
              	
              	; *********************************************************************************************
              	;
              	;		This is an XOR drawing sprite system. This is useful because the draw is self
              	;		cancelling, and this means you don't have to repaint multiple sprites to restore
              	; 		the display state. The downside is that it doesn't work well on collisions or 
              	; 		especially backgrounds.
              	;
              	;		The original design, which was a simpler draw all/erase all design, was binned 
              	;		because I thought on real hardware it would create too much flash on the display.
              	;
              	;		I don't yet have a real machine so can't evaluate this in practice, as the emulator
              	; 		snapshots the display at 60Mhz, so the effects of endlessly messing with the 
              	;		CRAM and VRAM is largely hidden.
              	;
              	;		At 4Mhz it does about 330 draws/erases a second on a 16x16 sprites, twice as fast on
              	;		8 pixel high sprites.
              	;
              	;		It eats UDGs - a single 16x16 sprite needs 9 UDGs if it doesn't overlap with another.
              	;
              	; *********************************************************************************************
              	
              	
              	; *********************************************************************************************
              	;
              	;								  Sprite Record entries
              	;
              	; *********************************************************************************************
              	
0000:         	SPRx 	= 0 								; horizontal position, pixels
0002:         	SPRy 	= 2 								; vertical position, pixels
0004:         	SPRgraphics = 4 							; bitmap data
0006:         	SPRcontrol = 6 								; 0:width 1,2:height others zero
0007:         	SPRstatus = 7 								; 7:currently drawn
              	
              	; *********************************************************************************************
              	;
              	; 								Initialise the sprite system.
              	;
              	; 	At this point sprite records should all have their "currently drawn" bit clear, it will
              	; 	get very confused otherwise.
              	;
              	; *********************************************************************************************
              	
0205:         	SPRInitialise:
0205: F5      			push 	af
0206: E5      			push 	hl
              			;
              			; 		Clear the main data area.
              			;
0207: 210004  			ld 		hl,SPRDataBlock 			
020A:         	_SPRZeroBlock:
020A: 3600    			ld 		(hl),$00
020C: 23      			inc 	hl
020D: 7C      			ld 		a,h
020E: FE08    			cp 		SPRDataBlockEnd >> 8
0210: 20F8    			jr 		nz,_SPRZeroBlock
              			;
              			; 		Set all possible original characters to $FF, indicating they are available.
              			;		
0212: 218004  			ld 		hl,SPROriginalChar+SPRLowSprite
0215:         	_SPRUsageReset:			 					
0215: 36FF    			ld 		(hl),$FF
0217: 2C      			inc 	l
0218: 20FB    			jr 		nz,_SPRUsageReset
021A: E1      			pop 	hl
021B: F1      			pop 	af
021C: C9      			ret
              	
              	; *********************************************************************************************
              	;
              	;						Draw, or Erase, the sprite whose raw data is at IX
              	;
              	; *********************************************************************************************
              	
021D:         	SpriteXDraw: 								; draw only
021D: DDCB077E			bit 	7,(ix+SPRstatus)
0221: C0      			ret 	nz
0222: 1805    			jr 		SpriteXToggle
0224:         	SpriteXErase:								; erase only
0224: DDCB077E			bit 	7,(ix+SPRstatus)
0228: C8      			ret 	z
0229:         	SpriteXToggle:								; flip state
0229: F5      			push 	af 							; save registers 							
022A: C5      			push 	bc
022B: D5      			push 	de
022C: E5      			push 	hl
022D: FDE5    			push 	iy
              			;
              			;		Calculate position in IY
              			;
022F: 2600    			ld 		h,0							; Y position in HL, with lower 3 bits masked, so already x 8
0231: DD7E02  			ld 		a,(ix+SPRy)
0234: E6F8    			and 	$F8
0236: 6F      			ld 		l,a
0237: 54      			ld 		d,h 						; DE = Y x 8
0238: 5D      			ld 		e,l
0239: 29      			add 	hl,hl 						; HL = Y x 32
023A: 29      			add 	hl,hl
023B: 19      			add 	hl,de 						; HL = Y x 40
023C: FD2100F8			ld 		iy,$F800 					; IY = $F800 + Y x 40
0240: EB      			ex 		de,hl
0241: FD19    			add 	iy,de
              	
0243: DD5E00  			ld 		e,(ix+SPRx)					; DE = X position
0246: DD5601  			ld 		d,(ix+SPRx+1)
0249: CB3A    			srl 	d 							; / 8 (after first in range 0-255 hence SRL E)
024B: CB1B    			rr 		e
024D: CB3B    			srl 	e
024F: CB3B    			srl 	e
0251: 1600    			ld 		d,0 						; add to screen position.
0253: FD19    			add 	iy,de
              			;
              			; 		Calculate and patch the fine horizontal shift jump which adjusts the 
              			; 		number of 24 bit left shifts we do to the graphics data.
              			;
0255: DD7E00  			ld 		a,(ix+SPRx)
0258: E607    			and 	7
025A: 87      			add 	a,a
025B: 32AC02  			ld 		(_SPRFineHorizontalShift+1),a 
              			;
              			; 		Calculate the horizontal offset which makes it start drawing part way through a UDG
              			;
025E: DD7E02  			ld 		a,(ix+SPRy)
0261: E607    			and 	7
0263: 32D503  			ld 		(_SPRInitialYOffset),a
              			;
              			; 		Calculate the row count from bits 1 and 2 of the control byte.
              			; 		(the number of vertical pixels down)
              			;
0266: DD7E06  			ld 		a,(ix+SPRcontrol)
0269: E606    			and 	$06
026B: 47      			ld 		b,a 						; B is 0,2,4,6 for 8,16,24,32
026C: AF      			xor 	a
026D:         	_SPRCalcRows:
026D: C608    			add 	a,8
026F: 05      			dec 	b	
0270: 05      			dec 	b
0271: F26D02  			jp 		p,_SPRCalcRows	
0274: 32D403  			ld 		(_SPRRowCount),a
              			;
              			; 		Load BC with the sprite graphic data, we preserve this throughout
              			; 		drawing.
              			;
0277: DD4E04  			ld 		c,(ix+SPRgraphics)
027A: DD4605  			ld 		b,(ix+SPRgraphics+1)
              			;
              			; 		Try to allocate UDGs for the current row at IY, 2 or 3 UDGs.
              			;
027D:         	_SPRStartNextCharacterRow:
027D: CD1203  			call 	_SPRAllocateRow 			; try to allocate the whole row.
0280: DA0303  			jp 		c,_SPRExit					; it didn't work, so we abandon drawing here.
              			;
              			; 		Adjust the usage counters.
              			;
0283: FDE5    			push 	iy
0285: CDB803  			call 	SPRAdjustUsageCounter
0288: FD23    			inc 	iy
028A: CDB803  			call 	SPRAdjustUsageCounter
028D: DDCB0646			bit 	0,(ix+SPRcontrol)
0291: 2805    			jr 		z,_SPRAuNotRight
0293: FD23    			inc 	iy
0295: CDB803  			call 	SPRAdjustUsageCounter
0298:         	_SPRAuNotRight:
0298: FDE1    			pop 	iy		
              			;
              			;		Get the graphics for the next *pixel* line. into ADE
              			;
029A:         	_SPRNextRowUDG:		
029A: 1E00    			ld 		e,0							; DE = $00:BC
029C: 0A      			ld 		a,(bc)
029D: 57      			ld 		d,a
029E: 03      			inc 	bc
029F: DDCB0646			bit 	0,(ix+SPRcontrol) 					; is the width 1 ?
02A3: 2804    			jr 		z,_SPRHaveGraphicData
02A5: 5A      			ld 		e,d  						; DE = (BC+1):(BC)		
02A6: 0A      			ld 		a,(bc)
02A7: 57      			ld 		d,a 
02A8: 03      			inc 	bc
02A9:         	_SPRHaveGraphicData:		
02A9: AF      			xor 	a 							; ADE contains 24 bit graphic data.
02AA: EB      			ex 		de,hl 						; we put it in AHL
02AB:         	_SPRFineHorizontalShift:		
02AB: 1800    			jr 		$+2 						; this is altered to do the fine horizontal shift
02AD: 29      			add 	hl,hl
02AE: 8F      			adc 	a,a
02AF: 29      			add 	hl,hl
02B0: 8F      			adc 	a,a
02B1: 29      			add 	hl,hl
02B2: 8F      			adc 	a,a
02B3: 29      			add 	hl,hl
02B4: 8F      			adc 	a,a
02B5: 29      			add 	hl,hl
02B6: 8F      			adc 	a,a
02B7: 29      			add 	hl,hl
02B8: 8F      			adc 	a,a
02B9: 29      			add 	hl,hl
02BA: 8F      			adc 	a,a
02BB: 29      			add 	hl,hl
02BC: 8F      			adc 	a,a
02BD: EB      			ex 		de,hl 						; put it back in ADE
              			;
              			;		Now XOR the data with the previously calculated addresses. 
              			;		If (ix+5)[0] is clear then don't do the third one, it's an 8x8 sprite
              			;
              			;		These addresses (the ld hl,xxxx ones) are modified in situ.
              			;
02BE:         	_SPRLeftUDGPosition:		
02BE: 2108F6  			ld 		hl,$F000+$C1*8
02C1: AE      			xor 	(hl)
02C2: 77      			ld 		(hl),a
02C3:         	_SPRMiddleUDGPosition:		
02C3: 2110F6  			ld 		hl,$F000+$C2*8
02C6: 7A      			ld 		a,d
02C7: AE      			xor 	(hl)
02C8: 77      			ld 		(hl),a
02C9: DDCB0646			bit 	0,(ix+SPRcontrol) 					; if width 1, skip the last draw
02CD: 2806    			jr 		z,_SPRDrawEnd
02CF:         	_SPRRightUDGPosition:		
02CF: 2118F6  			ld 		hl,$F000+$C3*8
02D2: 7B      			ld 		a,e
02D3: AE      			xor 	(hl)
02D4: 77      			ld 		(hl),a
02D5:         	_SPRDrawEnd:
              			;
              			; 		Check if we have done all the rows
              			;
02D5: 21D403  			ld 		hl,_SPRRowCount 
02D8: 35      			dec 	(hl)
02D9: 2828    			jr 		z,_SPRExit
              			;
              			; 		Now go to the next line down. Initially this just advances the vertical offset
              			;		in the UDG pointers
              			;
02DB: 21C402  			ld 		hl,_SPRMiddleUDGPosition+1
02DE: 34      			inc 	(hl)
02DF: 21D002  			ld 		hl,_SPRRightUDGPosition+1 	; not guaranteed initialised.
02E2: 34      			inc 	(hl)
02E3: 21BF02  			ld 		hl,_SPRLeftUDGPosition+1
02E6: 34      			inc 	(hl)
              			;
02E7: 7E      			ld 		a,(hl) 						; check crossed 8 byte boundary
02E8: E607    			and 	7
02EA: 20AE    			jr 		nz,_SPRNextRowUDG 			; if not complete it.
              	
02EC: AF      			xor 	a 							; clear the initial offset
02ED: 32D503  			ld 		(_SPRInitialYOffset),a
              	
              	
02F0: 112800  			ld 		de,40 						; advance down one row.
02F3: FD19    			add 	iy,de 
              	
02F5: 11B0FC  			ld 		de,$F800+40*30 				; the end of the physical display
02F8: FDE5    			push 	iy
02FA: E1      			pop 	hl
02FB: 37      			scf
02FC: ED52    			sbc 	hl,de
02FE: 3003    			jr 		nc,_SPRExit 				; past the bottom,exit.
              	
0300: C37D02  			jp 		_SPRStartNextCharacterRow 	; do the next character row.
              	
0303:         	_SPRExit:
0303: DD7E07  			ld 		a,(ix+SPRstatus) 			; toggle the drawn status bit
0306: EE80    			xor 	$80
0308: DD7707  			ld 		(ix+SPRstatus),a 		
              	
030B: FDE1    			pop 	iy 							; restore registers
030D: E1      			pop 	hl
030E: D1      			pop 	de
030F: C1      			pop 	bc
0310: F1      			pop 	af
0311: C9      			ret
              	
              	; *********************************************************************************************
              	;
              	;		Allocate 0-3 UDGs to the character space according to need and availability.
              	; 		Fail with CS if can't.
              	;		If possible,
              	;			all new UDGs should have the copied graphic from the background and the
              	;			old background set up.
              	;			the UDGs should replace the graphics in IY.
              	;
              	; *********************************************************************************************
              	
0312:         	_SPRAllocateRow:
0312: C5      			push 	bc 							; save BC.
0313: FDE5    			push 	iy 							; save IY
0315: ED73D603			ld 		(_SPRAllocSPTemp),sp		; save SP as we are using it for temp.
              	
0319: 210000  			ld 		hl,$0000 					; we save all the allocated so far on the stack
031C: E5      			push 	hl 		 					; this is the end marker.					
              			;
              			; 		Do 2 or 3. For each overwrite the XOR code addresses and save
              			;		it on the stack. If it fails, then unwind everything.
              			;
031D: CD6D03  			call 	_SPRAllocateOne 			; do (IY)
0320: 3821    			jr 		c,_SPRAllocateUndo 			; if done, then Undo.
0322: 22BF02  			ld 		(_SPRLeftUDGPosition+1),hl 	; overwrite the code.
0325: E5      			push 	hl
              	
0326: FD23    			inc 	iy		
0328: CD6D03  			call 	_SPRAllocateOne 			; do (IY+1)
032B: 3816    			jr 		c,_SPRAllocateUndo 			; if done, then Undo.
032D: 22C402  			ld 		(_SPRMiddleUDGPosition+1),hl ; overwrite the code.
0330: E5      			push 	hl
              	
0331: DDCB0646			bit 	0,(ix+SPRcontrol) 			; if 8 width then we are done.
0335: 282D    			jr 		z,_SPRAllocateOkay 
              	
0337: FD23    			inc 	iy		
0339: CD6D03  			call 	_SPRAllocateOne 			; do (IY+2)
033C: 3805    			jr 		c,_SPRAllocateUndo 			; if done, then Undo.
033E: 22D002  			ld 		(_SPRRightUDGPosition+1),hl ; overwrite the code.
0341: 1821    			jr 		_SPRAllocateOkay 
              			;
              			; 		Failed, so pop the saved UDG addresses on the stack and reset
              			;	 	as if we hadn't allocated it. We haven't bumped the usage count yet.
              			;
0343:         	_SPRAllocateUndo:
0343: D1      			pop 	de 							; address of UDG into DE
0344: 7A      			ld 		a,d 						; have we done the whole lot ?
0345: B3      			or 		e
0346: 37      			scf
0347: 281C    			jr 		z,_SPRAllocateExit 			; if so, e.g. popped $0000 with carry set.
              	
0349: CB3A    			srl 	d 							; divide by 8 - will put the UDG number into E
034B: CB1B    			rr 		e
034D: CB3A    			srl 	d
034F: CB1B    			rr 		e
0351: CB3A    			srl 	d
0353: CB1B    			rr 		e
              			;
0355: 6F      			ld 		l,a 						; HL is the address of the original character for this UDG.
0356: 2604    			ld 		h,SPROriginalChar >> 8 		
0358: 7E      			ld 		a,(hl) 						; character the UDG replaced
0359: 36FF    			ld 		(hl),$FF 					; mark that UDG as now available
              	
035B: 2606    			ld 		h,SPRLowAddress >> 8 		; get screen address into DE
035D: 5E      			ld 		e,(hl)
035E: 2607    			ld 		h,SPRHighAddress >> 8 
0360: 56      			ld 		d,(hl)
              	
0361: 12      			ld 		(de),a 						; fix up screen
              	
0362: 18DF    			jr 		_SPRAllocateUndo 			; and see if there are any more to undo
              			;
              			; 		Worked, exit with carry clear.
              			;
0364:         	_SPRAllocateOkay: 							; clear carry flag and exit.
0364: AF      			xor 	a		
0365:         	_SPRAllocateExit:
0365: ED7BD603			ld 		sp,(_SPRAllocSPTemp)		; get SP back
0369: FDE1    			pop 	iy 							; restore BC IY
036B: C1      			pop 	bc				
036C: C9      			ret
              	
              	; *********************************************************************************************
              	;
              	; 		Allocate a single UDG sprite, overwriting (IY), saving the original and copying
              	; 		the definition. On exit HL points to its graphic definition.
              	;
              	; *********************************************************************************************
              	
036D:         	_SPRAllocateOne:
036D: FD7E00  			ld 		a,(iy+0) 					; is it a UDG already
0370: FE80    			cp 		SPRLowSprite 				; if so, we don't need to do anything.
0372: 3033    			jr 		nc,_SPRAllocateOneExit
              			;
              			; 		Look for a free UDG, e.g. one where the stored character is $FF.
              			;
0374: 218004  			ld 		hl,SPROriginalChar+SPRLowSprite
0377:         	_SPRAOFind: 								; look for an available UDG.
0377: 7E      			ld 		a,(hl)
0378: FEFF    			cp 		$FF
037A: 2805    			jr 		z,_SPRAOFound
037C: 2C      			inc 	l
037D: 20F8    			jr 		nz,_SPRAOFind		
037F: 37      			scf 								; nope, we just can't do this one.
0380: C9      			ret
              	;
              	;  		Found a sprite we can allocate
              	;
0381:         	_SPRAOFound:
              			;
              			; 		Store the character overwritten by the UDG
              			;
0381: FD7E00  			ld 		a,(iy+0) 					; this is the original character e.g. what is underneath
0384: 77      			ld 		(hl),a 						; put in storage slot for original character
              			;
0385: FDE5    			push 	iy 							; save the address of that character so we can restore it.
0387: C1      			pop 	bc 							; when it drops to zero.
0388: 2606    			ld 		h,SPRLowAddress >> 8
038A: 71      			ld 		(hl),c
038B: 2607    			ld 		h,SPRHighAddress >> 8
038D: 70      			ld 		(hl),b
              			;
              			; 		Copy the graphic definition of the original character into the UDG.
              			;
              	
038E: FD7E00  			ld 		a,(iy+0) 					; get the original character , e.g. the non UDG
0391: FD7500  			ld 		(iy+0),l 					; override it.
              			;
0394: CDB103  			call 	_SPRCalculateDefinitionAddr ; HL is the graphic of the original character
0397: EB      			ex 		de,hl
0398: FD7E00  			ld 		a,(iy+0) 					; HL is the graphic of the UDG
039B: CDB103  			call 	_SPRCalculateDefinitionAddr
039E: EB      			ex 		de,hl 						; we want it copied there
039F: 010800  			ld 		bc,8 						; copy 8 bytes
03A2: EDB0    			ldir
              	
03A4: FD7E00  			ld 		a,(iy+0) 					; get the address of the UDG and exit with CC
03A7:         	_SPRAllocateOneExit;
03A7: CDB103  			call 	_SPRCalculateDefinitionAddr ; get the definition address in HL
03AA: 3AD503  			ld 		a,(_SPRInitialYOffset) 		; adjust for initial Y offset
03AD: B5      			or 		l
03AE: 6F      			ld 		l,a
03AF: AF      			xor 	a 							; clear carry.
03B0: C9      			ret 			
              	;
              	; 		A is a character #, point HL to CRAM Address
              	;
03B1:         	_SPRCalculateDefinitionAddr:
03B1: 6F      			ld 		l,a
03B2: 261E    			ld 		h,$F0/8
03B4: 29      			add 	hl,hl
03B5: 29      			add 	hl,hl
03B6: 29      			add 	hl,hl
03B7: C9      			ret
              	
              	; *********************************************************************************************
              	;
              	;							Adjust usage counter for (IY)
              	;
              	; *********************************************************************************************
              	
03B8:         	SPRAdjustUsageCounter:
03B8: FD6E00  			ld 		l,(iy+0) 					; point HL to the usage counter
03BB: 2605    			ld 		h,SPRUsageCount >> 8
03BD: DDCB077E			bit 	7,(ix+SPRstatus)			; if drawn status is non-zero we are erasing
03C1: 2002    			jr 		nz,_SPRDecrementUsage
03C3: 34      			inc 	(hl)						; increment usage counter and exit
03C4: C9      			ret
              	;
03C5:         	_SPRDecrementUsage:
03C5: 35      			dec 	(hl) 						; one fewer usage
03C6: C0      			ret 	nz 							; still in use.
              			;
              			; 		Count zero, free up. Could consider delaying this until actually needed?
              			;
03C7: 2606    			ld 		h,SPRLowAddress >> 8 		; display address in DE
03C9: 5E      			ld 		e,(hl)
03CA: 2607    			ld 		h,SPRHighAddress >> 8
03CC: 56      			ld 		d,(hl)
03CD: 2604    			ld 		h,SPROriginalChar >> 8 		; original character written to DE
03CF: 7E      			ld 		a,(hl)
03D0: 12      			ld 		(de),a 					
              	
03D1: 36FF    			ld 		(hl),$FF 					; mark the UDG as free again.
03D3: C9      			ret
              	
              	; *********************************************************************************************
              	;
              	; 									General Data
              	;
              	; *********************************************************************************************
              	
03D4:         	_SPRRowCount: 								; down counter for completed rows.
03D4: 00      			.db 	0
              	
03D5:         	_SPRInitialYOffset: 						; the initial vertical offset.
03D5: 00      			.db 	0
              	
03D6:         	_SPRAllocSPTemp: 							; save SP when storing interim results on stack
03D6: 0000    			.dw 	0
              	
              	; *********************************************************************************************
              	;
              	;		Sprite/UDG Specific Data. Each of these is a 256 byte array aligned
              	; 		on a page. This is a bit wasteful if you don't have many sprites but quicker.
              	;
              	; *********************************************************************************************
              	
03D8: 00000000			.align 	256,0
03DC: 00...   	
              	
0400:         	SPRDataBlock:
              	
              	;
              	;		This is the original value stored the UDG replaced. When $FF it means
              	; 		this UDG is not in use.
              	;
0400:         	SPROriginalChar:
0400: FFFFFFFF			.ds 	256
0404: FF...   	
              	;
              	;
              	; 		This is the number of sprites using the given UDG, indexed on zero.
              	;
0500:         	SPRUsageCount:
0500: FFFFFFFF			.ds 	256
0504: FF...   	
              	;
              	; 		The address of that replaced UDG. 
              	;
0600:         	SPRLowAddress:
0600: FFFFFFFF			.ds 	256
0604: FF...   	
0700:         	SPRHighAddress:
0700: FFFFFFFF			.ds 	256
0704: FF...   	
              	
0800:         	SPRDataBlockEnd:
              	
              	
              	;
              	; 		Copy a lightweight pattern to the screen.
              	;
0800:         	start:
0800: 3100F0  			ld 		sp,$F000
0803: 21B0FC  			ld 		hl,$F800+40*30
0806: 2B      	_fill:	dec 	hl	
0807: 3620    	 		ld 		(hl),$20
0809: 7D      	 		ld 		a,l
080A: C602    	 		add 	a,2
080C: E603    	 		and 	3
080E: 2002    	 		jr 		nz,_fill3
0810: 3601    	 		ld 		(hl),1
0812:         	_fill3: 		
0812: CB5C    	 		bit 	3,h
0814: 20F0    	 		jr 		nz,_fill
              	
0816: 2108F0  	 		ld 		hl,$F008
0819: 3601    	_fill4:	ld 		(hl),1
081B: 23      			inc 	hl
081C: CB5D    			bit 	3,l
081E: 20F9    			jr 		nz,_fill4 		
              	
0820: CD0502  	 		call 	SPRInitialise
              	
0823: DD21C108	 		ld 		ix,SpriteBuffer
0827: 060A    	 		ld 		b,SpriteCount
0829:         	_create:
0829: 78      			ld 		a,b
082A: 87      			add 	a,a
082B: 87      			add 	a,a		
082C: 87      			add 	a,a
082D: 87      			add 	a,a
082E: C618    			add 	a,24
0830: DD7700  			ld 		(ix+0),a
0833: DD360100			ld 		(ix+1),0
0837: 87      			add 	a,a
0838: DD7702  			ld 		(ix+2),a
083B: DD360300			ld 		(ix+3),0
083F: DD360489			ld 		(ix+4),SpriteGraphic & 0xFF
0843: DD360509			ld 		(ix+5),SpriteGraphic >> 8
0847: DD360603			ld 		(ix+6),$03
084B: DD360700			ld 		(ix+7),0
084F: DD360801			ld 		(ix+8),1
0853: CB40    			bit 	0,b
0855: 2804    			jr 		z,_create1
0857: DD3608FF			ld 		(ix+8),255
085B:         	_create1:		
085B: DD360901			ld 		(ix+9),1
085F: 110A00  	 		ld 		de,10
0862: DD19    	 		add 	ix,de
0864: 10C3    	 		djnz 	_create
              	
0866: 210000  	 		ld 		hl,0
0869: 220001  	 		ld 		($0100),hl
              	
086C: DD21C108	_loop1:	ld 		ix,SpriteBuffer
0870: 060A    			ld 		b,SpriteCount
0872: CD2402  	_loop2:	call 	SpriteXErase
0875: CD8F08  			call 	moveOne
0878: CD1D02  			call 	SpriteXDraw
              	
087B: 2A0001  			ld 		hl,($0100)
087E: 23      			inc 	hl
087F: 23      			inc 	hl
0880: 220001  	 		ld 		($0100),hl
              	
0883: 110A00  	 		ld 		de,10
0886: DD19    	 		add 	ix,de
0888: 10E8    			djnz 	_loop2
088A: 18E0    			jr 		_loop1
              	
088C: F3      	_stop:	di
088D: 18FD    			jr		_stop 		
              	
088F:         	moveOne:
088F: DD7E08  			ld 		a,(ix+8)
0892: CDAA08  			call 	advance
0895: DD7708  			ld 		(ix+8),a
0898: DD7E09  			ld 		a,(ix+9)
089B: DDE5    			push 	ix
089D: DD23    			inc 	ix
089F: DD23    			inc 	ix
08A1: CDAA08  			call 	advance
08A4: DDE1    			pop 	ix		
08A6: DD7709  			ld 		(ix+9),a
08A9: C9      			ret
              	
08AA: 4F      	advance:ld 		c,a
08AB: 87      			add 	a,a
08AC: 87      			add 	a,a
08AD: DD8600  			add 	a,(ix+0)
08B0: DD7700  			ld 		(ix+0),a
08B3: FE10    			cp 		16
08B5: 3806    			jr 		c,_adv2
08B7: FEF0    			cp 		240
08B9: 3002    			jr 		nc,_adv2
08BB: 79      			ld 		a,c
08BC: C9      			ret
08BD:         	_adv2:
08BD: 79      			ld 		a,c
08BE: ED44    			neg
08C0: C9      			ret
              	
              	; *********************************************************************************************
              	;										Test data
              	; *********************************************************************************************
              	
08C1:         	SpriteBuffer:		
08C1: FFFFFFFF			.ds 	SpriteCount * 20
08C5: FF...   	
              	
              	
0989:         	SpriteGraphic:
0989: F00F0810			.dw 	$0FF0,$1008,$2004,$4002,$8001,$FFFF,$AAAB,$D555
098D: 04200240	
0991: 0180FFFF	
0995: ABAA55D5	
0999: 03C003C0			.dw 	$C003,$C003,$FFFF,$8001,$4002,$2004,$1008,$0FF0
099D: FFFF0180	
09A1: 02400420	
09A5: 0810F00F	
              	


total time: 0.0030 sec.
no errors
